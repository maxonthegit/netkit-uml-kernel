===============================================================================

This patch adds an implementation of the MPLS (MultiProtocol Label Switching)
architecture inside the Linux kernel.

This MPLS implementation is (c) James Leu, Ramon Casellas, and David S. Miller,
and is distributed under the terms of the GNU GPL, either version 2 or (at your
option) any later version.

TECHNICAL INFORMATION:

MPLS version 0x01090602 (1.962), checked out from the project's P4 repository on
Oct 17th, 2008.

Applies to vanilla kernel 2.6.26.5.

The patch was obtained by diff'ing the linux-kernel-rpm-f8 against the
mpls-kernel-rpm-f8 tree. Due to the way project updates had been merged, the
mpls-kernel-rpm-f8 tree still contained some files from a previous kernel
release (<=2.6.25.18). These files have been removed in advance (i.e., before
producing the patch) based on the files that disappeared between a vanilla
kernel 2.6.25.18 and a 2.6.26. Redhat-specific files (configuration files,
makefiles) were then removed too from the final patch.

===============================================================================

diff -Naur linux-kernel-rpm-f8/include/linux/genetlink.h mpls-kernel-rpm-f8_modified/include/linux/genetlink.h
--- linux-kernel-rpm-f8/include/linux/genetlink.h	2008-10-17 09:59:13.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/include/linux/genetlink.h	2008-10-17 09:42:06.000000000 +0200
@@ -79,4 +79,35 @@
 
 #define CTRL_ATTR_MCAST_GRP_MAX (__CTRL_ATTR_MCAST_GRP_MAX - 1)
 
+enum {
+	MPLS_CMD_UNSPEC,
+	MPLS_CMD_NEWILM,
+	MPLS_CMD_DELILM,
+	MPLS_CMD_GETILM,
+	MPLS_CMD_NEWNHLFE,
+	MPLS_CMD_DELNHLFE,
+	MPLS_CMD_GETNHLFE,
+	MPLS_CMD_NEWXC,
+	MPLS_CMD_DELXC,
+	MPLS_CMD_GETXC,
+	MPLS_CMD_SETLABELSPACE,
+	MPLS_CMD_GETLABELSPACE,
+	__MPLS_CMD_MAX,
+};
+
+#define MPLS_CMD_MAX (__MPLS_CMD_MAX - 1)
+
+enum {
+	MPLS_ATTR_UNSPEC,
+	MPLS_ATTR_ILM,
+	MPLS_ATTR_NHLFE,
+	MPLS_ATTR_XC,
+	MPLS_ATTR_LABELSPACE,
+	MPLS_ATTR_INSTR,
+	MPLS_ATTR_STATS,
+	__MPLS_ATTR_MAX,
+};
+
+#define MPLS_ATTR_MAX (__MPLS_ATTR_MAX - 1)
+
 #endif	/* __LINUX_GENERIC_NETLINK_H */
diff -Naur linux-kernel-rpm-f8/include/linux/if_arp.h mpls-kernel-rpm-f8_modified/include/linux/if_arp.h
--- linux-kernel-rpm-f8/include/linux/if_arp.h	2008-10-17 09:59:16.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/include/linux/if_arp.h	2008-10-17 09:42:10.000000000 +0200
@@ -86,6 +86,7 @@
 #define ARPHRD_IEEE80211 801		/* IEEE 802.11			*/
 #define ARPHRD_IEEE80211_PRISM 802	/* IEEE 802.11 + Prism2 header  */
 #define ARPHRD_IEEE80211_RADIOTAP 803	/* IEEE 802.11 + radiotap header */
+#define ARPHRD_MPLS_TUNNEL 899		/* MPLS Tunnel Interface	*/
 
 #define ARPHRD_VOID	  0xFFFF	/* Void type, nothing is known */
 #define ARPHRD_NONE	  0xFFFE	/* zero header length */
diff -Naur linux-kernel-rpm-f8/include/linux/mpls.h mpls-kernel-rpm-f8_modified/include/linux/mpls.h
--- linux-kernel-rpm-f8/include/linux/mpls.h	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/include/linux/mpls.h	2008-10-17 09:42:15.000000000 +0200
@@ -0,0 +1,248 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *          James Leu        <jleu@mindspring.com>
+ *          Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu        <jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ * include/linux/mpls.h
+ *      Data types and structs used by userspace programs to access MPLS
+ *      forwarding. Most interface with the MPLS subsystem is IOCTL based
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ ****************************************************************************/
+
+#ifndef _LINUX_MPLS_H_
+#define _LINUX_MPLS_H_
+
+#ifdef __KERNEL__
+#include <linux/socket.h>
+#include <linux/if.h>
+#else
+#include <sys/socket.h>
+#include <linux/types.h>
+#include <net/if.h>
+#endif
+
+#define MPLS_NUM_OPS		8
+
+#define MPLS_LINUX_VERSION	0x01090602
+
+#define	MPLS_GRP_ILM	1
+#define	MPLS_GRP_NHLFE	2
+#define	MPLS_GRP_XC	4
+#define	MPLS_GRP_LABELSPACE 8
+
+#define MPLS_IPV4_EXPLICIT_NULL	0       /* only valid as sole label stack entry
+					   Pop label and send to IPv4 stack */
+#define MPLS_ROUTER_ALERT	1       /* anywhere except bottom, packet it is
+					   forwared to a software module
+					   determined by the next label,
+					   if the packet is forwarded, push this
+					   label back on */
+#define MPLS_IPV6_EXPLICIT_NULL	2       /* only valid as sole label stack entry
+					   Pop label and send to IPv6 stack */
+#define MPLS_IMPLICIT_NULL	3       /* a LIB with this, signifies to pop
+					   the next label and use that */
+
+#define MPLS_CHANGE_MTU		0x01
+#define MPLS_CHANGE_PROP_TTL	0x02
+#define MPLS_CHANGE_INSTR	0x04
+#define MPLS_CHANGE_PROTO	0x10
+
+enum mpls_dir {
+	MPLS_IN = 0x10,
+	MPLS_OUT = 0x20
+};
+
+enum mpls_opcode_enum {
+	MPLS_OP_NOP = 0x00,
+	MPLS_OP_POP,
+	MPLS_OP_PEEK,
+	MPLS_OP_PUSH,
+	MPLS_OP_DLV,
+	MPLS_OP_FWD,
+	MPLS_OP_NF_FWD,
+	MPLS_OP_DS_FWD,
+	MPLS_OP_EXP_FWD,
+	MPLS_OP_SET,
+	MPLS_OP_SET_RX,
+	MPLS_OP_SET_TC,
+	MPLS_OP_SET_DS,
+	MPLS_OP_SET_EXP,
+	MPLS_OP_EXP2TC,
+	MPLS_OP_EXP2DS,
+	MPLS_OP_TC2EXP,
+	MPLS_OP_DS2EXP,
+	MPLS_OP_NF2EXP,
+	MPLS_OP_SET_NF,
+	MPLS_OP_MAX
+};
+
+enum mpls_label_type_enum {
+	MPLS_LABEL_GEN = 1,
+	MPLS_LABEL_ATM,
+	MPLS_LABEL_FR,
+	MPLS_LABEL_KEY
+};
+
+struct mpls_label_atm {
+	u_int16_t  mla_vpi;
+	u_int16_t  mla_vci;
+};
+
+struct mpls_label {
+	enum mpls_label_type_enum ml_type;
+	union {
+		u_int32_t ml_key;
+		u_int32_t ml_gen;
+		u_int32_t ml_fr;
+		struct mpls_label_atm ml_atm;
+	} u;
+	int ml_index;
+};
+
+struct mpls_in_label_req {
+	unsigned int      mil_proto;
+	struct mpls_label mil_label;
+	unsigned char     mil_change_flag;
+};
+
+#define MPLS_LABELSPACE_MAX	255
+
+struct mpls_labelspace_req {
+	int mls_ifindex;                  /* Index to the MPLS-enab. interface*/
+	int mls_labelspace;               /* Labelspace IN/SET -- OUT/GET     */
+};
+
+struct mpls_nexthop_info {
+	unsigned int    mni_if;
+	struct sockaddr mni_addr;
+};
+
+struct mpls_out_label_req {
+	struct mpls_label mol_label;
+	u_int32_t         mol_mtu;
+	int8_t            mol_propagate_ttl;
+	unsigned char     mol_change_flag;
+};
+
+struct mpls_xconnect_req {
+	struct mpls_label mx_in;
+	struct mpls_label mx_out;
+};
+
+struct mpls_tunnel_req {
+	char mt_ifname[IFNAMSIZ];
+	unsigned int mt_nhlfe_key;
+};
+
+#define MPLS_NFMARK_NUM 64
+
+struct mpls_nfmark_fwd {
+	unsigned int nf_key[MPLS_NFMARK_NUM];
+	unsigned short nf_mask;
+};
+
+#define MPLS_DSMARK_NUM 64
+
+struct mpls_dsmark_fwd {
+	unsigned int df_key[MPLS_DSMARK_NUM];
+	unsigned char df_mask;
+};
+
+#define MPLS_TCINDEX_NUM 64
+
+struct mpls_tcindex_fwd {
+	unsigned int tc_key[MPLS_TCINDEX_NUM];
+	unsigned short tc_mask;
+};
+
+#define MPLS_EXP_NUM 8
+
+struct mpls_exp_fwd {
+	unsigned int ef_key[MPLS_EXP_NUM];
+};
+
+struct mpls_exp2tcindex {
+	unsigned short e2t[MPLS_EXP_NUM];
+};
+
+struct mpls_exp2dsmark {
+	unsigned char e2d[MPLS_EXP_NUM];
+};
+
+struct mpls_tcindex2exp {
+	unsigned char t2e_mask;
+	unsigned char t2e[MPLS_TCINDEX_NUM];
+};
+
+struct mpls_dsmark2exp {
+	unsigned char d2e_mask;
+	unsigned char d2e[MPLS_DSMARK_NUM];
+};
+
+struct mpls_nfmark2exp {
+	unsigned char n2e_mask;
+	unsigned char n2e[MPLS_NFMARK_NUM];
+};
+
+struct mpls_instr_elem {
+	unsigned short mir_opcode;
+	unsigned char mir_direction;
+	union {
+		struct mpls_label        push;
+		struct mpls_label        fwd;
+		struct mpls_nfmark_fwd   nf_fwd;
+		struct mpls_dsmark_fwd   ds_fwd;
+		struct mpls_exp_fwd      exp_fwd;
+		struct mpls_nexthop_info set;
+		unsigned int             set_rx;
+		unsigned short           set_tc;
+		unsigned short           set_ds;
+		unsigned char            set_exp;
+		struct mpls_exp2tcindex  exp2tc;
+		struct mpls_exp2dsmark   exp2ds;
+		struct mpls_tcindex2exp  tc2exp;
+		struct mpls_dsmark2exp   ds2exp;
+		struct mpls_nfmark2exp   nf2exp;
+		unsigned long            set_nf;
+	} mir_data;
+};
+
+/* Standard shortcuts */
+#define mir_push       mir_data.push
+#define mir_fwd        mir_data.fwd
+#define mir_nf_fwd     mir_data.nf_fwd
+#define mir_ds_fwd     mir_data.ds_fwd
+#define mir_exp_fwd    mir_data.exp_fwd
+#define mir_set        mir_data.set
+#define mir_set_rx     mir_data.set_rx
+#define mir_set_tc     mir_data.set_tc
+#define mir_set_tx     mir_data.set_tx
+#define mir_set_ds     mir_data.set_ds
+#define mir_set_exp    mir_data.set_exp
+#define mir_set_nf     mir_data.set_nf
+#define mir_exp2tc     mir_data.exp2tc
+#define mir_exp2ds     mir_data.exp2ds
+#define mir_tc2exp     mir_data.tc2exp
+#define mir_ds2exp     mir_data.ds2exp
+#define mir_nf2exp     mir_data.nf2exp
+
+struct mpls_instr_req {
+	struct mpls_instr_elem       mir_instr[MPLS_NUM_OPS];
+	unsigned char                mir_instr_length;
+	unsigned char                mir_direction;
+	int                          mir_index;
+	struct mpls_label            mir_label;
+};
+
+#endif
diff -Naur linux-kernel-rpm-f8/include/linux/netdevice.h mpls-kernel-rpm-f8_modified/include/linux/netdevice.h
--- linux-kernel-rpm-f8/include/linux/netdevice.h	2008-10-17 09:59:23.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/include/linux/netdevice.h	2008-10-17 09:42:18.000000000 +0200
@@ -613,6 +613,7 @@
 	void			*ax25_ptr;	/* AX.25 specific data */
 	struct wireless_dev	*ieee80211_ptr;	/* IEEE 802.11 specific data,
 						   assign before registering */
+	void			*mpls_ptr;	/* MPLS specific data */
 
 /*
  * Cache line mostly used on receive path (including eth_type_trans())
diff -Naur linux-kernel-rpm-f8/include/linux/netfilter/xt_mpls.h mpls-kernel-rpm-f8_modified/include/linux/netfilter/xt_mpls.h
--- linux-kernel-rpm-f8/include/linux/netfilter/xt_mpls.h	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/include/linux/netfilter/xt_mpls.h	2008-10-17 09:42:18.000000000 +0200
@@ -0,0 +1,12 @@
+#ifndef _XT_MPLS_H_target
+#define _XT_MPLS_H_target
+
+struct xt_mpls_target_info {
+	u_int32_t key;
+
+	/* only used by the netfilter kernel modules */
+	void *nhlfe;
+	void *proto;
+};
+
+#endif /*_XT_MPLS_H_target */
diff -Naur linux-kernel-rpm-f8/include/linux/ppp_defs.h mpls-kernel-rpm-f8_modified/include/linux/ppp_defs.h
--- linux-kernel-rpm-f8/include/linux/ppp_defs.h	2008-10-17 09:59:25.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/include/linux/ppp_defs.h	2008-10-17 09:42:20.000000000 +0200
@@ -82,7 +82,7 @@
 #define PPP_IPV6CP	0x8057	/* IPv6 Control Protocol */
 #define PPP_CCPFRAG	0x80fb	/* CCP at link level (below MP bundle) */
 #define PPP_CCP		0x80fd	/* Compression Control Protocol */
-#define PPP_MPLSCP	0x80fd	/* MPLS Control Protocol */
+#define PPP_MPLSCP	0x8281	/* MPLS Control Protocol */
 #define PPP_LCP		0xc021	/* Link Control Protocol */
 #define PPP_PAP		0xc023	/* Password Authentication Protocol */
 #define PPP_LQR		0xc025	/* Link Quality Report protocol */
diff -Naur linux-kernel-rpm-f8/include/linux/rtnetlink.h mpls-kernel-rpm-f8_modified/include/linux/rtnetlink.h
--- linux-kernel-rpm-f8/include/linux/rtnetlink.h	2008-10-17 09:59:30.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/include/linux/rtnetlink.h	2008-10-17 09:42:24.000000000 +0200
@@ -274,6 +274,7 @@
 	RTA_SESSION, /* no longer used */
 	RTA_MP_ALGO, /* no longer used */
 	RTA_TABLE,
+	RTA_SHIM = 30,
 	__RTA_MAX
 };
 
diff -Naur linux-kernel-rpm-f8/include/linux/shim.h mpls-kernel-rpm-f8_modified/include/linux/shim.h
--- linux-kernel-rpm-f8/include/linux/shim.h	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/include/linux/shim.h	2008-10-17 09:42:23.000000000 +0200
@@ -0,0 +1,12 @@
+#ifndef LINUX_SHIM_H
+#define LINUX_SHIM_H
+
+#define SHIMNAMSIZ 16
+struct rtshim
+{
+	char name[SHIMNAMSIZ+1];
+	short datalen;
+	char data[0];
+};
+
+#endif
diff -Naur linux-kernel-rpm-f8/include/linux/socket.h mpls-kernel-rpm-f8_modified/include/linux/socket.h
--- linux-kernel-rpm-f8/include/linux/socket.h	2008-10-17 09:59:28.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/include/linux/socket.h	2008-10-17 09:42:24.000000000 +0200
@@ -184,6 +184,7 @@
 #define AF_PPPOX	24	/* PPPoX sockets		*/
 #define AF_WANPIPE	25	/* Wanpipe API Sockets */
 #define AF_LLC		26	/* Linux LLC			*/
+#define AF_MPLS		28	/* MPLS sockets			*/
 #define AF_CAN		29	/* Controller Area Network      */
 #define AF_TIPC		30	/* TIPC sockets			*/
 #define AF_BLUETOOTH	31	/* Bluetooth sockets 		*/
@@ -220,6 +221,7 @@
 #define PF_PPPOX	AF_PPPOX
 #define PF_WANPIPE	AF_WANPIPE
 #define PF_LLC		AF_LLC
+#define PF_MPLS		AF_MPLS
 #define PF_CAN		AF_CAN
 #define PF_TIPC		AF_TIPC
 #define PF_BLUETOOTH	AF_BLUETOOTH
diff -Naur linux-kernel-rpm-f8/include/linux/sysctl.h mpls-kernel-rpm-f8_modified/include/linux/sysctl.h
--- linux-kernel-rpm-f8/include/linux/sysctl.h	2008-10-17 09:59:33.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/include/linux/sysctl.h	2008-10-17 09:42:33.000000000 +0200
@@ -231,6 +231,7 @@
 	NET_LLC=18,
 	NET_NETFILTER=19,
 	NET_DCCP=20,
+	NET_MPLS=21,
 	NET_IRDA=412,
 };
 
@@ -789,6 +790,13 @@
 	NET_BRIDGE_NF_FILTER_PPPOE_TAGGED = 5,
 };
 
+/* /proc/sys/net/mpls */
+enum
+{
+	NET_MPLS_DEBUG=1,
+	NET_MPLS_DEFAULT_TTL=2,
+};
+
 /* proc/sys/net/irda */
 enum {
 	NET_IRDA_DISCOVERY=1,
@@ -807,7 +815,6 @@
 	NET_IRDA_LAP_KEEPALIVE_TIME=14,
 };
 
-
 /* CTL_FS names: */
 enum
 {
diff -Naur linux-kernel-rpm-f8/include/net/ip6_fib.h mpls-kernel-rpm-f8_modified/include/net/ip6_fib.h
--- linux-kernel-rpm-f8/include/net/ip6_fib.h	2008-10-17 09:59:42.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/include/net/ip6_fib.h	2008-10-17 09:42:44.000000000 +0200
@@ -21,6 +21,7 @@
 #include <net/dst.h>
 #include <net/flow.h>
 #include <net/netlink.h>
+#include <net/shim.h>
 
 struct rt6_info;
 
@@ -43,6 +44,8 @@
 	int		fc_mx_len;
 
 	struct nl_info	fc_nlinfo;
+	struct rtshim	fc_shim;
+
 };
 
 struct fib6_node
@@ -114,6 +117,7 @@
 #endif
 
 	struct rt6key			rt6i_src;
+	struct shim_blk			*rt6i_shim;
 };
 
 static inline struct inet6_dev *ip6_dst_idev(struct dst_entry *dst)
diff -Naur linux-kernel-rpm-f8/include/net/ip_fib.h mpls-kernel-rpm-f8_modified/include/net/ip_fib.h
--- linux-kernel-rpm-f8/include/net/ip_fib.h	2008-10-17 09:59:42.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/include/net/ip_fib.h	2008-10-17 09:42:40.000000000 +0200
@@ -19,6 +19,7 @@
 #include <net/flow.h>
 #include <linux/seq_file.h>
 #include <net/fib_rules.h>
+#include <net/shim.h>
 
 struct fib_config {
 	u8			fc_dst_len;
@@ -41,6 +42,7 @@
 	u32			fc_flow;
 	u32			fc_nlflags;
 	struct nl_info		fc_nlinfo;
+	struct rtshim		fc_shim;
  };
 
 struct fib_info;
@@ -60,6 +62,7 @@
 #endif
 	int			nh_oif;
 	__be32			nh_gw;
+	struct shim_blk		*nh_shim;
 };
 
 /*
@@ -141,6 +144,7 @@
 #define FIB_RES_GW(res)			(FIB_RES_NH(res).nh_gw)
 #define FIB_RES_DEV(res)		(FIB_RES_NH(res).nh_dev)
 #define FIB_RES_OIF(res)		(FIB_RES_NH(res).nh_oif)
+#define FIB_RES_SHIM(res)		(FIB_RES_NH(res).nh_shim)
 
 struct fib_table {
 	struct hlist_node tb_hlist;
diff -Naur linux-kernel-rpm-f8/include/net/mpls.h mpls-kernel-rpm-f8_modified/include/net/mpls.h
--- linux-kernel-rpm-f8/include/net/mpls.h	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/include/net/mpls.h	2008-10-17 09:42:45.000000000 +0200
@@ -0,0 +1,696 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * File:  linux/include/net/mpls.h
+ *
+ * Authors:
+ *          James Leu        <jleu@mindspring.com>
+ *          Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu        <jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ *   Changes:
+ *   20031126 RCAS:
+ *         - Rewrite the debugging macros.
+ *   20040319 JLEU:
+ *	   - switch to gen_stats
+ *   20041018 JLEU
+ *	   - added cache_flush to the prot driver
+ *****************************************************************************
+ */
+#ifndef __LINUX_NET_MPLS__H_
+#define __LINUX_NET_MPLS__H_
+
+#include <linux/autoconf.h>
+#include <net/shim.h>
+#include <net/dst.h>
+#include <asm/atomic.h>
+#include <linux/init.h>
+#include <linux/mpls.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/rtnetlink.h>
+#include <linux/gen_stats.h>
+#include <linux/sysctl.h>
+
+/* 
+ * Forward declarations
+ */
+
+struct fib_result;
+struct rtable;
+
+extern int sysctl_mpls_debug;
+extern int sysctl_mpls_default_ttl;
+extern struct dst_ops mpls_dst_ops;
+
+#define MPLS_ERR KERN_ERR
+#define MPLS_INF KERN_ALERT
+#define MPLS_DBG KERN_DEBUG
+
+/* Comment this to suppress MPLS_DEBUG calls */
+#define MPLS_ENABLE_DEBUG 1
+
+/* Comment this to suppress TRACING enter/exit functions */
+#define MPLS_ENABLE_DEBUG_FUNC 1
+
+#ifdef  MPLS_ENABLE_DEBUG
+#define MPLS_DEBUG(f, a...) \
+{ \
+	if (sysctl_mpls_debug) {\
+		printk (MPLS_DBG "MPLS DEBUG %s:%d:%s: ", \
+			__FILE__, __LINE__, __FUNCTION__); \
+		printk (f, ##a); \
+	}\
+}
+
+#define MPLS_DEBUG_CALL(f) \
+{ \
+	if (sysctl_mpls_debug) {\
+		f; \
+	} \
+}
+#else
+#define MPLS_DEBUG(f, a...) /**/
+#define MPLS_DEBUG_CALL(f) /**/
+#endif /* MPLS_ENABLE_DEBUG */
+
+#ifdef MPLS_ENABLE_DEBUG_FUNC
+#define MPLS_ENTER MPLS_DEBUG("enter\n")
+#define MPLS_EXIT  MPLS_DEBUG("exit\n")
+#else
+#define MPLS_ENTER /**/
+#define MPLS_EXIT  /**/
+#endif
+
+#define MPLS_INFO(f, a...) printk (KERN_INFO "MPLS INFO " f, ##a);
+
+#ifdef MPLS_ENABLE_DEBUG 
+#define MPLS_ASSERT(expr) \
+if(unlikely(!(expr))) { \
+	printk(KERN_ERR "MPLS Assertion failed! %s,%s,%s,line=%d\n",#expr,\
+	__FILE__,__FUNCTION__,__LINE__);          \
+}
+#else
+#define MPLS_ASSERT(expr) /**/
+#endif /* MPLS_ENABLE_DEBUG */
+
+/****************************************************************************
+ * MPLS Interface "Extension" 
+ * In the current implementation the "all loved" net_device struct is 
+ * extended with one field struct mpls_interface (cast'd to void) called
+ * mpls_ptr; This holds basically the "per interface" labelspace.
+ ****************************************************************************/
+
+struct mpls_interface {
+	/*  
+	 * (any mif object)->list_out is a circular d-linked list. Each node
+	 * of this list is a NHLFE. NHLFE's are added to this list when adding a 
+	 * OP_SET opcode to a nhlfe instruction array.
+	 * 
+	 * list_add(&nhlfe->dev_entry, &mpls_if->list_out) : adds nhlfe to this 
+	 * list.
+	 *
+	 * "List of all NHLFEs that use this device (e.g. eth0) as output"
+	 * cf. mpls_init.c
+	 */
+	struct list_head list_out;
+	                         
+
+	/*  
+	 * (any mif object)->list_in is a circular d-linked list. Each node
+	 * of this list is a ILM. ILM's are added to this list when 
+	 */
+	struct list_head list_in;  
+
+	/* 
+	 * Label Space for this interface 
+	 */
+	int  labelspace;  
+};
+
+
+
+extern struct mpls_interface* mpls_create_if_info(void);
+extern void                   mpls_delete_if_info(struct mpls_interface *mpls_if);
+
+/****************************************************************************
+ * Socket Buffer Mangement
+ ****************************************************************************/
+
+struct mpls_skb_parm {
+	struct mpls_prot_driver *prot;
+	unsigned int  gap;
+	unsigned int  label:20;
+	unsigned int  ttl:8;
+	unsigned int  exp:3;
+	unsigned int  bos:1;
+	unsigned char flag;
+	unsigned char popped_bos;
+	unsigned char *top_of_stack;
+};
+
+#define MPLSCB(skb) ((struct mpls_skb_parm*)((skb)->cb))
+
+
+/****************************************************************************
+ * Result codes for Input/Output Opcodes. 
+ * net/mpls/{mpls_opcode,mpls_opcode_all}.c
+ ****************************************************************************/
+
+#define MPLS_RESULT_SUCCESS	0
+#define MPLS_RESULT_RECURSE	1
+#define MPLS_RESULT_DROP	2
+#define MPLS_RESULT_DLV		3
+#define MPLS_RESULT_FWD		4
+
+
+/**
+ * mpls_instr - Struct to hold one instruction
+ * @mi_opcode: Opcode. MPLS_OP_POP,etc...       
+ * @mi_data:   Opcode data.
+ * @mi_next:   Next Instruction to execute. 
+ **/
+struct mpls_instr {
+	struct mpls_instr  *mi_next;
+	unsigned short      mi_opcode;
+	enum mpls_dir       mi_dir;
+	void               *mi_data; 
+	void *              mi_parent;
+};
+
+
+struct mpls_nfmark_fwd_info {
+	struct mpls_nhlfe *nfi_nhlfe[MPLS_NFMARK_NUM];
+	unsigned short        nfi_mask;
+};
+
+struct mpls_dsmark_fwd_info {
+	struct mpls_nhlfe *dfi_nhlfe[MPLS_DSMARK_NUM];
+	unsigned char         dfi_mask;
+};
+
+struct mpls_tcindex_fwd_info {
+	struct mpls_nhlfe *tfi_nhlfe[MPLS_TCINDEX_NUM];
+	unsigned short        tfi_mask;
+};
+
+struct mpls_exp_fwd_info {
+	struct mpls_nhlfe *efi_nhlfe[MPLS_EXP_NUM];
+};
+
+struct mpls_exp2dsmark_info {
+	unsigned char e2d[MPLS_EXP_NUM];
+};
+
+struct mpls_exp2tcindex_info {
+	unsigned short e2t[MPLS_EXP_NUM];
+};
+
+struct mpls_tcindex2exp_info {
+	unsigned char t2e_mask;
+	unsigned char t2e[MPLS_TCINDEX_NUM];
+};
+
+struct mpls_dsmark2exp_info {
+	unsigned char d2e_mask;
+	unsigned char d2e[MPLS_DSMARK_NUM];
+};
+
+struct mpls_nfmark2exp_info {
+	unsigned char n2e_mask;
+	unsigned char n2e[MPLS_NFMARK_NUM];
+};
+
+/****************************************************************************
+ * Instruction (OPCODEs) Management 
+ * net/mpls/mpls_instr.c
+ ****************************************************************************/
+
+void               mpls_instr_release(struct mpls_instr *mi);
+struct mpls_instr* mpls_instr_alloc(unsigned short opcode);
+void               mpls_instrs_free(struct mpls_instr *list);
+int                mpls_instrs_build(struct mpls_instr_elem *mie, 
+				struct mpls_instr **instr, int length, 
+				enum mpls_dir dir,void *parent);
+void		   mpls_instrs_unbuild(struct mpls_instr *instr,
+				struct mpls_instr_req *req);
+
+/****************************************************************************
+ * Layer 3 protocol driver
+ *
+ * most of this code is taken from DaveM&JHadi implementation
+ ****************************************************************************/
+#define MPLSPROTONAMSIZ 16
+struct mpls_prot_driver {
+	atomic_t	__refcnt;
+	struct list_head list;
+
+	unsigned short	family;
+	unsigned short	ethertype;
+	char		name[MPLSPROTONAMSIZ + 1];
+
+	void		(*cache_flush)(void);
+	void		(*set_ttl)(struct sk_buff *skb, int ttl);
+	int		(*get_ttl)(struct sk_buff *skb);
+	void		(*change_dsfield)(struct sk_buff *skb, int ds);
+	int		(*get_dsfield)(struct sk_buff *skb);
+	int		(*ttl_expired)(struct sk_buff **skb);
+	int		(*mtu_exceeded)(struct sk_buff **skb, int mtu);
+	int		(*local_deliver)(struct sk_buff *skb);
+
+	int		(*nexthop_resolve)(struct neighbour **,
+				struct sockaddr *, struct net_device *);
+
+	struct module	*owner;
+};
+
+/****************************************************************************
+ * Protocol driver Management 
+ * net/mpls/mpls_proto.c
+ ****************************************************************************/
+
+void                     mpls_proto_init(void);
+void                     mpls_proto_exit(void);
+int                      mpls_proto_add(struct mpls_prot_driver *);
+int                      mpls_proto_remove(struct mpls_prot_driver *);
+struct mpls_prot_driver *mpls_proto_find_by_family(unsigned short);
+struct mpls_prot_driver *mpls_proto_find_by_ethertype(unsigned short);
+struct mpls_prot_driver *mpls_proto_find_by_name(char *);
+void                     mpls_proto_cache_flush_all (void);
+
+#define mpls_proto_release(V)   atomic_dec((&V->__refcnt));
+#define mpls_proto_hold(V)      atomic_inc((&V->__refcnt));
+
+/****************************************************************************
+ * MPLS INPUT INFO (ILM) OBJECT MANAGEMENT
+ * net/mpls/mpls_ilm.c
+ ****************************************************************************/
+
+struct mpls_ilm {
+
+	union {
+		struct dst_entry     dst;
+		struct mpls_ilm *next;
+	} u;
+
+	struct list_head             global;
+
+	/* To appear as an entry in the device ILM list                     */ 
+	struct list_head             dev_entry;
+	/* Generic stats						    */
+	struct gnet_stats_basic	     ilm_stats;
+	unsigned int		     ilm_drops;
+	/* List of NHLFE                                                    */ 
+	struct list_head             nhlfe_entry;
+	/* Instructions to execute for this ILM                             */ 
+	struct mpls_instr           *ilm_instr;
+	/* Incoming Label for this ILM                                      */
+	struct mpls_label            ilm_label;
+	/* Key used to lookup this object in a data structure               */
+	unsigned int                 ilm_key;
+	/* Jiffies                                                          */
+	unsigned int                 ilm_age;
+	/* L3 protocol driver for packets that use this ILM                 */
+	struct mpls_prot_driver     *ilm_proto;
+	/* Incoming Labelspace (see doc)                                    */
+	unsigned short               ilm_labelspace;
+};
+
+
+/****************************************************************************
+ * Input Radix Tree Management
+ ****************************************************************************/
+
+extern spinlock_t               mpls_ilm_lock;
+extern struct radix_tree_root   mpls_ilm_tree;
+
+int               mpls_ilm_init(void);
+void              mpls_ilm_exit(void);
+int               mpls_insert_ilm(unsigned int, struct mpls_ilm* ilm);
+struct mpls_ilm*  mpls_delete_ilm(unsigned int key);
+struct mpls_ilm*  mpls_get_ilm(unsigned int key);
+struct mpls_ilm*  mpls_get_ilm_by_label(struct mpls_label *label,
+				int labelspace, char bos);
+extern struct mpls_ilm* mpls_ilm_dst_alloc(unsigned int key,
+				struct mpls_label *ml, unsigned short family,
+				struct mpls_instr_elem *instr, int instr_len);
+
+
+
+/****************************************************************************
+ * MPLS OUTPUT INFO (NHLFE) OBJECT MANAGEMENT
+ * net/mpls/mpls_ilm.c
+ ****************************************************************************/
+
+struct mpls_nhlfe {
+	/* since most higher lay protocol operate on dst_entries, representing
+	 * a NHLFE as a dst_enttry make sense.  Higher layer protocols
+	 * may hold references to the dst_entry.  The result is that
+	 * a NHLFE may exist after the user deletes it from the RADIX tree.
+	 */
+	union {
+		struct dst_entry	dst;
+		struct mpls_nhlfe	*next;
+	} u;
+#define nhlfe_mtu		u.dst.metrics[RTAX_MTU-1]
+
+	/* user configured references as opposed to the references
+	 * created by protocol drivers (ie IPv4 route cache)
+	 */
+	atomic_t		__refcnt;
+
+	struct list_head	global;
+
+	/* Generic stats						    */
+	struct gnet_stats_basic	nhlfe_stats;
+	unsigned int		nhlfe_drops;
+	/* List of notif                                                    */
+	struct notifier_block*  nhlfe_notifier_list;
+	/* List of NHLFE that are linked to this NHLFE                      */
+	struct list_head        list_out;
+	/* List of ILM that are linked to this NHLFE                        */
+	struct list_head        list_in;
+	/* To be added into a device list_out if the NHLFE uses (SET) the dev */
+	struct list_head        dev_entry;
+	/* To be added into list_out if this nhlfe uses (FWD) another NHLFE */
+	struct list_head        nhlfe_entry;
+	/* Array of instructions for this NHLFE                             */ 
+	struct mpls_instr      *nhlfe_instr;
+	/* Key to used to store/lookup a given NHLFE in the tree            */
+	unsigned int            nhlfe_key;
+	/* Age in jiffies                                                   */
+	unsigned int            nhlfe_age;
+	/* MTU Limit (e.g. from device MTU + number of pushes               */
+	unsigned short          nhlfe_mtu_limit;
+	unsigned char           nhlfe_propagate_ttl;
+};
+
+
+struct mpls_fwd_block {
+	struct notifier_block notifier_block;
+	struct mpls_nhlfe *owner;
+	struct mpls_nhlfe *fwd;
+};
+
+/****************************************************************************
+ * Output Radix Tree Management
+ ****************************************************************************/
+
+extern struct radix_tree_root mpls_nhlfe_tree;
+extern spinlock_t             mpls_nhlfe_lock;
+
+int                 mpls_nhlfe_init(void);
+void                mpls_nhlfe_exit(void);
+int                 mpls_insert_nhlfe(unsigned int, struct mpls_nhlfe*);
+struct mpls_nhlfe*  mpls_delete_nhlfe(unsigned int);
+struct mpls_nhlfe*  mpls_get_nhlfe(unsigned int);
+
+
+/****************************************************************************
+ * Helper Functions
+ ****************************************************************************/
+
+void                mpls_skb_dump(struct sk_buff* sk);
+char                mpls_find_payload(struct sk_buff* skb);
+unsigned int        mpls_label2key(const int, const struct mpls_label*);
+
+
+/****************************************************************************
+ * INCOMING (INPUT) LABELLED PACKET MANAGEMENT
+ * net/mpls/mpls_input.c
+ ****************************************************************************/
+
+int  mpls_skb_recv    (struct sk_buff *skb, struct net_device *dev,
+                              struct packet_type* ptype, struct net_device *orig);
+int  mpls_skb_recv_mc (struct sk_buff *skb, struct net_device *dev,
+                              struct packet_type* ptype, struct net_device *orig);
+
+
+/****************************************************************************
+ * OUTGOING (OUTPUT) LABELLED PACKET MANAGEMENT
+ * net/mpls/mpls_output.c
+ ****************************************************************************/
+
+struct mpls_dst {
+	union {
+		struct dst_entry	dst;
+		struct mpls_dst		*next;
+        } u;
+
+	struct sockaddr			md_nh;
+};
+
+int  mpls_bogus_output(struct sk_buff *skb);
+int  mpls_set_nexthop(struct shim_blk* blk,struct dst_entry *dst);
+int  mpls_set_nexthop2(struct mpls_nhlfe *nhlfe, struct dst_entry *dst);
+int  mpls_output(struct sk_buff *skb); 
+int  mpls_switch(struct sk_buff *skb); 
+int  mpls_output_shim (struct sk_buff *skb, struct mpls_nhlfe *nhlfe);
+int  mpls_output2(struct sk_buff *skb,struct mpls_nhlfe *nhlfe);
+
+/****************************************************************************
+ * MPLS Destination (dst) Next hop (neighbour) cache management
+ * net/mpls/mpls_dst.c
+ ****************************************************************************/
+
+int              mpls_dst_init(void);
+void             mpls_dst_exit(void);
+struct mpls_dst *mpls_dst_alloc(struct net_device *dev, struct sockaddr *nh);
+void             mpls_dst_release(struct mpls_dst *);
+
+
+/****************************************************************************
+ * INPUT/OUTPUT INSTRUCTION OPCODES 
+ * net/mpls/{mpls_opcode,mpls_opcode_in,mpls_opcode_out}.c
+ *
+ ****************************************************************************/
+ 
+/*
+ * skb:       Socket buffer. May be modified [OUT] 
+ * ilm:       ILM entry object that owns this opcode. 
+ * nhlfe:       NHLF entry to apply. May be modified (e.g. MTU) [OUT] 
+ * data:      opcode dependant data. Cast to NHLFEs, DS marks, etc.
+ */
+#define MPLS_OPCODE_PROTOTYPE(NAME) \
+int (NAME) (struct sk_buff** skb,struct mpls_ilm *ilm, \
+	struct mpls_nhlfe **nhlfe, void *data) 
+
+/*
+ * instr:     Instruction array. 
+ * direction: MPLS_IN (ILM) or MPLS_OUT(NHLFE)
+ * parent:    ILM/NHLFE parent object for opcode.
+ * data:      opcode dependant data. [OUT]
+ * last_able: Nonzero if this can be the last opcode. [OUT]
+ * num_push:  Number of pushes for this opcode. [OUT] (Incr. by OP_PUSH
+ */
+#define MPLS_BUILD_OPCODE_PROTOTYPE(NAME) \
+int (NAME) (struct mpls_instr_elem *instr, \
+	enum mpls_dir direction, void *parent,\
+        void **data, int *last_able, int *num_push)
+
+/*
+ * instr:     Instruction array. 
+ * data:      opcode dependant data. [OUT]
+ */
+#define MPLS_UNBUILD_OPCODE_PROTOTYPE(NAME) \
+int (NAME) (struct mpls_instr_elem *instr, void *data)
+
+/*
+ * data:      opcode dependant data.
+ * parent:    ILM/NHLFE parent object for opcode.
+ * direction: MPLS_IN (ILM) or MPLS_OUT(NHLFE)
+ */
+#define MPLS_CLEAN_OPCODE_PROTOTYPE(NAME) \
+void (NAME) (void *data, void *parent, enum mpls_dir direction)
+
+/*
+ * seq:       seq_file output stream. 
+ * data:      opcode dependant data.
+ * direction: MPLS_IN (ILM) or MPLS_OUT(NHLFE)
+ */
+#define MPLS_PRINT_OPCODE_PROTOTYPE(NAME) \
+void (NAME) (struct seq_file *seq, void *data, enum mpls_dir direction)
+
+#define MPLS_IN_OPCODE_PROTOTYPE(NAME)  MPLS_OPCODE_PROTOTYPE(NAME) 
+#define MPLS_OUT_OPCODE_PROTOTYPE(NAME) MPLS_OPCODE_PROTOTYPE(NAME) 
+
+struct mpls_ops {
+	MPLS_IN_OPCODE_PROTOTYPE(*in);
+	MPLS_OUT_OPCODE_PROTOTYPE(*out);
+	MPLS_BUILD_OPCODE_PROTOTYPE(*build);
+	MPLS_UNBUILD_OPCODE_PROTOTYPE(*unbuild);
+	MPLS_CLEAN_OPCODE_PROTOTYPE(*cleanup);
+	MPLS_PRINT_OPCODE_PROTOTYPE(*print);
+	int  extra;
+	char *msg;
+};
+
+/* Array holding opcodes */
+extern struct mpls_ops mpls_ops[];
+
+void   mpls_finish(struct sk_buff *skb);
+int    mpls_opcode_peek(struct sk_buff *skb);
+int    mpls_push(struct sk_buff **skb, struct mpls_label *label);
+
+
+/* Query/Update Incoming Labels */
+int  mpls_add_in_label        (const struct mpls_in_label_req *in);
+int  mpls_get_in_label        (struct mpls_in_label_req *in);
+void __mpls_del_in_label      (struct mpls_ilm *ilm);
+int  mpls_del_in_label        (struct mpls_in_label_req *in);
+int  mpls_set_in_label_proto  (struct mpls_in_label_req *in);
+int  mpls_add_reserved_label  (int label, struct mpls_ilm* ilm);
+struct mpls_ilm* mpls_del_reserved_label (int label);
+
+/* Query/Update Outgoing Labels */
+extern int mpls_add_out_label     (struct mpls_out_label_req *out, int seq,
+				   int pid);
+int mpls_get_out_label     (struct mpls_out_label_req *out);
+int mpls_del_out_label     (struct mpls_out_label_req *out);
+int mpls_set_out_label_mtu (struct mpls_out_label_req *out);
+
+/* Query/Update Crossconnects */
+int mpls_attach_in2out       (struct mpls_xconnect_req *req);
+int mpls_detach_in2out       (struct mpls_xconnect_req *req);
+int mpls_get_in2out          (struct mpls_xconnect_req *req);
+
+/* Instruction Management */
+int  mpls_set_in_label_instrs   (struct mpls_instr_req *mir);
+int  mpls_set_out_label_instrs  (struct mpls_instr_req *mir);
+int  mpls_set_in_instrs         (struct mpls_instr_elem *mie, 
+	int length, struct mpls_ilm *ilm);
+int  mpls_set_out_instrs        (struct mpls_instr_elem *mie, 
+	int length, struct mpls_nhlfe *nhlfe);
+int mpls_set_out_label_propagate_ttl(struct mpls_out_label_req *mol);
+
+void mpls_destroy_out_instrs    (struct mpls_nhlfe *nhlfe);
+void mpls_destroy_in_instrs     (struct mpls_ilm  *ilm);
+
+/* Query/Update Labelspaces*/
+int mpls_get_labelspace             (struct mpls_labelspace_req *req);
+int mpls_get_labelspace_by_name     (const char *name);
+int mpls_get_labelspace_by_index    (int ifindex);
+int mpls_set_labelspace             (struct mpls_labelspace_req *req);
+int mpls_set_labelspace_by_name     (const char *name, int labelspace);
+int mpls_set_labelspace_by_index    (int ifindex, int labelspace);
+
+/* Netlink event notification */
+void mpls_ilm_event(int event, struct mpls_ilm *ilm);
+void mpls_nhlfe_event(int event, struct mpls_nhlfe *nhlfe, int seq, int pid);
+void mpls_labelspace_event(int event, struct net_device *dev);
+void mpls_xc_event(int event, struct mpls_ilm *ilm,
+	struct mpls_nhlfe *nhlfe);
+
+/****************************************************************************
+ * REFERENCE COUNT MANAGEMENT 
+ ****************************************************************************/
+
+/* Hold */
+static inline struct mpls_ilm* mpls_ilm_hold(struct mpls_ilm* ilm)
+{
+	BUG_ON(!ilm);
+	dst_hold (&ilm->u.dst);
+	return ilm;
+}
+
+
+/* Release */
+static inline void mpls_ilm_release(struct mpls_ilm* ilm)
+{
+	BUG_ON(!ilm);
+	dst_release(&ilm->u.dst);
+}
+
+
+/* Hold */
+static inline struct mpls_nhlfe* mpls_nhlfe_hold(struct mpls_nhlfe* nhlfe)
+{
+	BUG_ON(!nhlfe);
+	atomic_inc(&nhlfe->__refcnt);
+	return nhlfe;
+}
+
+/* Release */
+static inline void mpls_nhlfe_release(struct mpls_nhlfe* nhlfe)
+{
+	BUG_ON(!nhlfe);
+	atomic_dec(&nhlfe->__refcnt);
+}
+
+/****************************************************************************
+ * sysctl Implementation
+ * net/mpls/sysctl_net_mpls.c
+ ****************************************************************************/
+
+int   mpls_sysctl_init(void);
+void  mpls_sysctl_exit(void);
+
+/****************************************************************************
+ * ProcFS Implementation
+ * net/mpls/mpls_procfs.c
+ ****************************************************************************/
+
+int   mpls_procfs_init(void);
+void  mpls_procfs_exit(void);
+
+/****************************************************************************
+ * Shim Implementation
+ * net/mpls/mpls_shim.c
+ ****************************************************************************/
+
+void  mpls_shim_init(void);
+void  mpls_shim_exit(void);
+
+/****************************************************************************
+ * NetLink Implementation  
+ * net/mpls/mpls_netlink.c
+ ****************************************************************************/
+
+int  mpls_netlink_init (void);
+void mpls_netlink_exit (void);
+
+/****************************************************************************
+ * Virtual Intefaces (Tunnel) Management 
+ * (e.g. mpls0, mpls1, TXXethN, etc.)
+ * net/mpls/mpls_tunnel.c
+ ****************************************************************************/
+
+struct mpls_tunnel_private {
+	/* NHLFE Object to apply to this tunnel traffic */
+	struct mpls_nhlfe             *mtp_nhlfe;
+	/* Netdevice for this tunnel                  */
+	struct net_device             *mtp_dev;
+	/* Next tunnel in list                        */
+	struct mpls_tunnel_private    *next;
+	/* Netdevice (this tunnel) traffic stats      */
+	struct net_device_stats        stat;
+};
+
+
+struct net_device* mpls_tunnel_get_by_name (const char* name);
+struct net_device* mpls_tunnel_get         (struct mpls_tunnel_req *mt);
+void               mpls_tunnel_put         (struct net_device *dev); 
+struct net_device* mpls_tunnel_create      (struct mpls_tunnel_req *mt);
+void               mpls_tunnel_destroy     (struct mpls_tunnel_req *mt); 
+
+/* Casts */
+#define _mpls_as_if(PTR)    ((struct mpls_interface*)(PTR))
+#define _mpls_as_label(PTR) ((struct mpls_label*)(PTR))
+#define _mpls_as_ilm(PTR)   ((struct mpls_ilm*)(PTR))
+#define _mpls_as_nhlfe(PTR) ((struct mpls_nhlfe*)(PTR))
+#define _mpls_as_dfi(PTR)   ((struct mpls_dsmark_fwd_info*)(PTR))
+#define _mpls_as_nfi(PTR)   ((struct mpls_nfmark_fwd_info*)(PTR))
+#define _mpls_as_efi(PTR)   ((struct mpls_exp_fwd_info*)(PTR))
+#define _mpls_as_netdev(PTR)((struct net_device*)(PTR))
+#define _mpls_as_dst(PTR)   ((struct mpls_dst*)(PTR))
+
+#endif
diff -Naur linux-kernel-rpm-f8/include/net/shim.h mpls-kernel-rpm-f8_modified/include/net/shim.h
--- linux-kernel-rpm-f8/include/net/shim.h	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/include/net/shim.h	2008-10-17 09:42:45.000000000 +0200
@@ -0,0 +1,45 @@
+/*
+ *	Network shim interface for protocols that live below L3 but above L2
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ *	Authors:	James R. Leu <jleu@mindspring.com>
+ */
+#ifndef _NET_SHIM_H
+#define _NET_SHIM_H
+
+#include <net/dst.h>
+#include <linux/list.h>
+#include <linux/shim.h>
+
+struct shim_blk;
+
+struct shim {
+	atomic_t		refcnt;
+	struct list_head	list;
+	int			(*build)(struct shim_blk *, struct dst_entry *);
+	char			name[SHIMNAMSIZ + 1];
+};
+
+struct shim_blk {
+	struct shim *shim;
+	short datalen;
+	char data[0];
+};
+
+extern void shim_proto_add(struct shim *spec);
+extern int shim_proto_remove(struct shim *spec);
+extern struct shim *shim_proto_find_by_name(const char* name);
+extern struct shim_blk *shim_build_blk(struct rtshim* data);
+extern  void shim_destroy_blk(struct shim_blk* sblk);
+extern int shim_blk_cmp(struct shim_blk* a, struct shim_blk* b);
+extern int shim_cfg_blk_cmp(struct rtshim* data, struct shim_blk* sblk);
+extern void shim_unbuild_blk(struct rtshim* data, struct shim_blk* sblk);
+
+#define shim_proto_release(V)	atomic_dec((&V->refcnt));
+#define shim_proto_hold(V)	atomic_inc((&V->refcnt));
+
+#endif
diff -Naur linux-kernel-rpm-f8/kernel/sysctl_check.c mpls-kernel-rpm-f8_modified/kernel/sysctl_check.c
--- linux-kernel-rpm-f8/kernel/sysctl_check.c	2008-10-17 09:59:59.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/kernel/sysctl_check.c	2008-10-17 09:43:15.000000000 +0200
@@ -672,6 +672,12 @@
 	{}
 };
 
+static const struct trans_ctl_table trans_net_mpls_table[] = {
+	{ NET_MPLS_DEBUG,		"debug" },
+	{ NET_MPLS_DEFAULT_TTL,		"default_ttl" },
+	{}
+};
+
 static const struct trans_ctl_table trans_net_irda_table[] = {
 	{ NET_IRDA_DISCOVERY,		"discovery" },
 	{ NET_IRDA_DEVNAME,		"devname" },
@@ -711,6 +717,7 @@
 	{ NET_LLC,		"llc",		trans_net_llc_table },
 	{ NET_NETFILTER,	"netfilter",	trans_net_netfilter_table },
 	{ NET_DCCP,		"dccp",		trans_net_dccp_table },
+	{ NET_MPLS,		"mpls",		trans_net_mpls_table },
 	{ NET_IRDA,		"irda",		trans_net_irda_table },
 	{ 2089,			"nf_conntrack_max" },
 	{}
diff -Naur linux-kernel-rpm-f8/net/bridge/Kconfig mpls-kernel-rpm-f8_modified/net/bridge/Kconfig
--- linux-kernel-rpm-f8/net/bridge/Kconfig	2008-10-17 10:00:22.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/bridge/Kconfig	2008-10-17 09:43:56.000000000 +0200
@@ -30,3 +30,13 @@
 	  will be called bridge.
 
 	  If unsure, say N.
+
+config BRIDGE_MPLS
+	tristate "Bridge: MPLS support"
+	depends on BRIDGE && MPLS
+	---help---
+	  If you say Y here, the kernel will support being an egress for
+	  Ethernet over MPLS packets
+
+	  If unsure, say N.
+
diff -Naur linux-kernel-rpm-f8/net/bridge/Makefile mpls-kernel-rpm-f8_modified/net/bridge/Makefile
--- linux-kernel-rpm-f8/net/bridge/Makefile	2008-10-17 10:00:22.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/bridge/Makefile	2008-10-17 09:43:56.000000000 +0200
@@ -8,6 +8,7 @@
 			br_ioctl.o br_notify.o br_stp.o br_stp_bpdu.o \
 			br_stp_if.o br_stp_timer.o br_netlink.o
 
+obj-$(CONFIG_BRIDGE_MPLS) += mplsbr.o
 bridge-$(CONFIG_SYSFS) += br_sysfs_if.o br_sysfs_br.o
 
 bridge-$(CONFIG_BRIDGE_NETFILTER) += br_netfilter.o
diff -Naur linux-kernel-rpm-f8/net/bridge/mplsbr.c mpls-kernel-rpm-f8_modified/net/bridge/mplsbr.c
--- linux-kernel-rpm-f8/net/bridge/mplsbr.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/bridge/mplsbr.c	2008-10-17 09:43:56.000000000 +0200
@@ -0,0 +1,168 @@
+/* mplsbr.c: ethernet over MPLS protocol driver.
+ *
+ * Copyright (C) 2005 James R. Leu (jleu@mindspring.com)
+ */
+
+#include <linux/module.h>
+#include <linux/socket.h>
+#include <linux/skbuff.h>
+#include <linux/init.h>
+#include <net/neighbour.h>
+#include <net/dst.h>
+#include <net/mpls.h>
+
+MODULE_LICENSE("GPL");
+
+static void dumb_neigh_solicit(struct neighbour *neigh,struct sk_buff *skb)
+{
+}
+
+static void dumb_neigh_error(struct neighbour *neigh,struct sk_buff *skb)
+{
+	kfree_skb(skb);
+}
+
+static int dumb_neigh_dev_xmit(struct sk_buff *skb)
+{
+	skb->dev = skb->dst->dev;
+	skb->ip_summed = CHECKSUM_NONE;
+	dev_queue_xmit(skb);
+	return 0;
+}
+
+
+static struct neigh_ops dumb_neigh_ops = {
+	.family =               AF_PACKET,
+	.solicit =              dumb_neigh_solicit,
+	.error_report =         dumb_neigh_error,
+	.output =               dumb_neigh_dev_xmit,
+	.connected_output =     dumb_neigh_dev_xmit,
+	.hh_output =            dumb_neigh_dev_xmit,
+	.queue_xmit =           dumb_neigh_dev_xmit,
+};
+
+static u32 dumb_neigh_hash(const void *pkey, const struct net_device *dev)
+{
+	return dev->ifindex;
+}
+
+static int dumb_neigh_constructor(struct neighbour *neigh)
+{
+	neigh->ops = &dumb_neigh_ops;
+	neigh->output = neigh->ops->output;
+	return 0;
+}
+
+static struct neigh_table dumb_tbl = {
+	.family         = AF_PACKET,
+	.entry_size     = sizeof(struct neighbour),
+	.key_len        = 4,
+	.hash           = dumb_neigh_hash,
+	.constructor    = dumb_neigh_constructor,
+	.id             = "dumb_neigh",
+
+	/* parameters are copied from ARP ... */
+	.parms = {
+		.tbl                    = &dumb_tbl,
+		.base_reachable_time    = 30 * HZ,
+		.retrans_time           = 1 * HZ,
+		.gc_staletime           = 60 * HZ,
+		.reachable_time         = 30 * HZ,
+		.delay_probe_time       = 5 * HZ,
+		.queue_len              = 3,
+		.ucast_probes           = 3,
+		.mcast_probes           = 3,
+		.anycast_delay          = 1 * HZ,
+		.proxy_delay            = (8 * HZ) / 10,
+		.proxy_qlen             = 64,
+		.locktime               = 1 * HZ,
+	},
+	.gc_interval    = 30 * HZ,
+	.gc_thresh1     = 128,
+	.gc_thresh2     = 512,
+	.gc_thresh3     = 1024,
+};
+
+static void mplsbr_cache_flush(void)
+{
+}
+
+static void mplsbr_set_ttl(struct sk_buff *skb, int ttl)
+{
+}
+
+static int mplsbr_get_ttl(struct sk_buff *skb)
+{
+	return 255;
+}
+
+static void mplsbr_change_dsfield(struct sk_buff *skb, int ds)
+{
+	/* 802.1q? */
+}
+
+static int mplsbr_get_dsfield(struct sk_buff *skb)
+{
+	/* 802.1q? */
+	return 0;
+}
+
+static int mplsbr_ttl_expired(struct sk_buff **skb)
+{
+	return NET_RX_DROP;
+}
+
+static int mplsbr_mtu_exceeded(struct sk_buff **skb, int mtu)
+{
+	return MPLS_RESULT_DROP;
+}
+
+static int mplsbr_local_deliver(struct sk_buff *skb)
+{
+	return NET_RX_DROP;
+}
+
+static int mplsbr_nexthop_resolve(struct neighbour **np,
+	struct sockaddr *sock_addr, struct net_device *dev)
+{
+	struct neighbour *n;
+	u32 index = dev->ifindex;
+
+	n = __neigh_lookup_errno(&dumb_tbl, &index, dev);
+	if (IS_ERR(n))
+		return PTR_ERR(n);
+
+	*np = n;
+	return 0;
+}
+
+static struct mpls_prot_driver mplsbr_driver = {
+	.name			=	"bridge",
+	.family                 =       AF_PACKET,
+	.ethertype              =       __constant_htons(ETH_P_ALL),
+	.cache_flush            =       mplsbr_cache_flush,
+	.set_ttl                =       mplsbr_set_ttl,
+	.get_ttl                =       mplsbr_get_ttl,
+	.change_dsfield         =       mplsbr_change_dsfield,
+	.get_dsfield            =       mplsbr_get_dsfield,
+	.ttl_expired            =       mplsbr_ttl_expired,
+	.mtu_exceeded		=	mplsbr_mtu_exceeded,
+	.local_deliver		=	mplsbr_local_deliver,
+	.nexthop_resolve        =       mplsbr_nexthop_resolve,
+	.owner                  =       THIS_MODULE,
+};
+
+static int __init mplsbr_init(void)
+{
+	printk("MPLS: Ethernet over MPLS support\n");
+	neigh_table_init(&dumb_tbl);
+	return mpls_proto_add(&mplsbr_driver);
+}
+
+static void __exit mplsbr_fini(void)
+{
+	mpls_proto_remove(&mplsbr_driver);
+}
+
+module_init(mplsbr_init);
+module_exit(mplsbr_fini);
diff -Naur linux-kernel-rpm-f8/net/bridge/netfilter/ebt_mpls.c mpls-kernel-rpm-f8_modified/net/bridge/netfilter/ebt_mpls.c
--- linux-kernel-rpm-f8/net/bridge/netfilter/ebt_mpls.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/bridge/netfilter/ebt_mpls.c	2008-10-17 09:43:56.000000000 +0200
@@ -0,0 +1,107 @@
+/* This is a module which is used for setting up a SKB to use a mpls. */
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <net/mpls.h>
+#include <net/sock.h>
+
+#include <linux/netfilter/xt_mpls.h>
+#include <linux/netfilter_bridge/ebtables.h>
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("James R. Leu <jle@mindspring.com>");
+MODULE_DESCRIPTION("ebtables mpls module");
+
+static int target(struct sk_buff *skb, unsigned int hooknr,
+   const struct net_device *in, const struct net_device *out,
+   const void *targinfo, unsigned int datalen)
+{
+	const struct xt_mpls_target_info *mplsinfo = targinfo;
+	struct mpls_nhlfe *nhlfe = mplsinfo->nhlfe;
+
+	if (!skb_make_writable(skb, 0))
+		return EBT_DROP;
+
+	/* until we can pass the proto driver via mpls_output_shim
+	 * we'll let it look it up for us based on skb->protocol */
+	skb->protocol = htons(ETH_P_ALL);
+
+	/* skb->mac_header is where the L2 header begins, push
+	 * the SKB to make skb->data == skb->mac_header, then
+	 * set skb->network_header = skb->data, skb->network_header
+	 * is where we put the MPLS shim
+	 */
+	skb_push(skb, skb->data - skb->mac_header);
+	skb->network_header = skb->data;
+	mpls_output_shim(skb, nhlfe);
+
+	/* don't let anyone else use this frame */
+	return EBT_DROP;
+}
+
+static int checkentry(const char *tablename, unsigned int hookmask,
+   const struct ebt_entry *e, void *targinfo, unsigned int targinfosize)
+{
+	struct xt_mpls_target_info *mplsinfo = targinfo;
+
+	if (targinfosize
+		!= EBT_ALIGN(sizeof(struct xt_mpls_target_info))) {
+		printk(KERN_WARNING "mpls: targinfosize %u != %Zu\n",
+		       targinfosize,
+		       EBT_ALIGN(sizeof(struct xt_mpls_target_info)));
+		return -EINVAL;
+	}
+
+	mplsinfo->nhlfe = mpls_get_nhlfe(mplsinfo->key);
+	if (!mplsinfo->nhlfe) {
+		printk(KERN_WARNING "mpls: unable to find NHLFE with key %x\n",
+			mplsinfo->key);
+		return -EINVAL;
+	}
+
+	mplsinfo->proto = mpls_proto_find_by_ethertype(htons(ETH_P_ALL));
+	if (!mplsinfo->proto) {
+		printk(KERN_WARNING "mpls: unable to find ETH_P_ALL driver\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void destroy(void *targinfo, unsigned int targinfosize)
+{
+	struct xt_mpls_target_info *mplsinfo = targinfo;
+	struct mpls_nhlfe *nhlfe = mplsinfo->nhlfe;
+	struct mpls_prot_driver *prot = mplsinfo->proto;
+
+	if (nhlfe) {
+		mpls_nhlfe_release(nhlfe);
+		mplsinfo->nhlfe = NULL;
+	}
+
+	if (prot) {
+		mpls_proto_release(prot);
+		mplsinfo->proto = NULL;
+	}
+}
+
+static struct ebt_target mpls_target =
+{
+	.name		= "mpls",
+	.target		= target,
+	.destroy	= destroy,
+	.check		= checkentry,
+	.me		= THIS_MODULE,
+};
+
+static int __init init(void)
+{
+	return ebt_register_target(&mpls_target);
+}
+
+static void __exit fini(void)
+{
+	ebt_unregister_target(&mpls_target);
+}
+
+module_init(init);
+module_exit(fini);
diff -Naur linux-kernel-rpm-f8/net/bridge/netfilter/Kconfig mpls-kernel-rpm-f8_modified/net/bridge/netfilter/Kconfig
--- linux-kernel-rpm-f8/net/bridge/netfilter/Kconfig	2008-10-17 10:00:25.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/bridge/netfilter/Kconfig	2008-10-17 09:44:00.000000000 +0200
@@ -165,6 +165,15 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config BRIDGE_EBT_MPLS
+	tristate "ebt: MPLS target support"
+	depends on BRIDGE_NF_EBTABLES && MPLS
+	help
+	  This option adds the ebtables MPLS target which allows for
+	  bridging ethernets frame onto a MPLS LSP
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 config BRIDGE_EBT_REDIRECT
 	tristate "ebt: redirect target support"
 	depends on BRIDGE_NF_EBTABLES
diff -Naur linux-kernel-rpm-f8/net/bridge/netfilter/Makefile mpls-kernel-rpm-f8_modified/net/bridge/netfilter/Makefile
--- linux-kernel-rpm-f8/net/bridge/netfilter/Makefile	2008-10-17 10:00:25.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/bridge/netfilter/Makefile	2008-10-17 09:44:00.000000000 +0200
@@ -24,6 +24,7 @@
 obj-$(CONFIG_BRIDGE_EBT_ARPREPLY) += ebt_arpreply.o
 obj-$(CONFIG_BRIDGE_EBT_MARK_T) += ebt_mark.o
 obj-$(CONFIG_BRIDGE_EBT_DNAT) += ebt_dnat.o
+obj-$(CONFIG_BRIDGE_EBT_MPLS) += ebt_mpls.o
 obj-$(CONFIG_BRIDGE_EBT_REDIRECT) += ebt_redirect.o
 obj-$(CONFIG_BRIDGE_EBT_SNAT) += ebt_snat.o
 
diff -Naur linux-kernel-rpm-f8/net/core/dev.c mpls-kernel-rpm-f8_modified/net/core/dev.c
--- linux-kernel-rpm-f8/net/core/dev.c	2008-10-17 10:00:26.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/core/dev.c	2008-10-17 09:44:02.000000000 +0200
@@ -120,6 +120,7 @@
 #include <linux/ctype.h>
 #include <linux/if_arp.h>
 #include <linux/if_vlan.h>
+#include <net/shim.h>
 
 #include "net-sysfs.h"
 
@@ -4591,6 +4592,7 @@
 	hotcpu_notifier(dev_cpu_callback, 0);
 	dst_init();
 	dev_mcast_init();
+
 	rc = 0;
 out:
 	return rc;
diff -Naur linux-kernel-rpm-f8/net/core/Makefile mpls-kernel-rpm-f8_modified/net/core/Makefile
--- linux-kernel-rpm-f8/net/core/Makefile	2008-10-17 10:00:23.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/core/Makefile	2008-10-17 09:43:56.000000000 +0200
@@ -8,7 +8,8 @@
 obj-$(CONFIG_SYSCTL) += sysctl_net_core.o
 
 obj-y		     += dev.o ethtool.o dev_mcast.o dst.o netevent.o \
-			neighbour.o rtnetlink.o utils.o link_watch.o filter.o
+			neighbour.o rtnetlink.o utils.o link_watch.o filter.o \
+			shim.o
 
 obj-$(CONFIG_XFRM) += flow.o
 obj-y += net-sysfs.o
diff -Naur linux-kernel-rpm-f8/net/core/shim.c mpls-kernel-rpm-f8_modified/net/core/shim.c
--- linux-kernel-rpm-f8/net/core/shim.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/core/shim.c	2008-10-17 09:43:58.000000000 +0200
@@ -0,0 +1,331 @@
+/*
+ *      Network shim interface for protocols that live below L3 and above L2
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ *	Heavily borrowed from dev_remove_pack/dev_add_pack
+ *
+ *	Authors:	James R. Leu <jleu@mindspring.com>
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <asm/byteorder.h>
+#include <linux/list.h>
+#include <net/shim.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+spinlock_t shim_proto_lock = SPIN_LOCK_UNLOCKED;
+struct list_head shim_proto_list;
+
+/**
+ *	shim_proto_add - add a shim protocol handler
+ *	@shim: shim declaration
+ *
+ * 	Add a shim protocol handler to the networking stack.  The
+ *	passed &shim is linked into the kernel list and may not be
+ *	freed until it has been removed from the kernel list.
+ *
+ *	This call does not sleep therefore is can not guarantee all
+ *	CPU's that are in middle of processing packets will see the
+ *	new shim handler (until they process another packet)
+ */
+
+void shim_proto_add(struct shim *shim)
+{
+	spin_lock_bh(&shim_proto_lock);
+
+	atomic_set(&shim->refcnt, 1);
+	list_add_rcu(&shim->list, &shim_proto_list);
+
+	spin_unlock_bh(&shim_proto_lock);
+}
+
+/**
+ *	shim_proto_remove - remove a shim protocol handler
+ *	@shim: shim declaration
+ *
+ *	Remove a shim handler that was previously added to the
+ *	kernels list of shim handlers by shim_proto_add().  The
+ *	pass &shim is removed from the kernels list and can be freed
+ *	or reused once this function returns.
+ *
+ *	This call sleeps to guarantee that no CPU is looking at the
+ *	special nexthop handler after return.
+ */
+
+int shim_proto_remove(struct shim *shim)
+{
+	struct shim *shim1;
+	int retval = -EPROTONOSUPPORT;
+
+	spin_lock_bh(&shim_proto_lock);
+
+	list_for_each_entry(shim1, &shim_proto_list, list) {
+		if (shim == shim1) {
+			if (atomic_read(&shim->refcnt) != 1) {
+				retval = -EADDRINUSE;
+			} else {
+				list_del_rcu(&shim->list);
+				retval = 0;
+			}
+			break;
+		}
+	}
+	spin_unlock_bh(&shim_proto_lock);
+
+	synchronize_net();
+	return retval;
+}
+
+/**
+ *	shim_proto_find_by_name - find a shim handler by it's registered name
+ *	@name: protocol name
+ *
+ *	Search the kernels list of shim handlers looking for
+ *	a handler with this specific name
+ */
+struct shim *shim_proto_find_by_name(const char *name)
+{
+	struct shim *shim;
+
+	spin_lock_bh(&shim_proto_lock);
+
+	list_for_each_entry(shim, &shim_proto_list, list) {
+		if (!strncmp(name, shim->name, SHIMNAMSIZ)) {
+			shim_proto_hold(shim);
+			goto out;
+		}
+	}
+	shim = NULL;
+out:
+	spin_unlock_bh(&shim_proto_lock);
+
+	return shim;
+}
+
+/*
+ * Shim block utilities
+ */
+
+/**
+ *	shim_build_blk - allocate memory for a shim blk and fill it with data
+ *			 from rta
+ *	@rta: data describing shim
+ *
+ *	Allocate a shim blk which links directly to the shim
+ *	proto for use by the forwarding plane
+ */
+struct shim_blk *shim_build_blk(struct rtshim* rta)
+{
+	struct shim_blk *sblk;
+
+	if (!rta)
+		return NULL;
+
+	sblk = kmalloc(sizeof(*sblk) + rta->datalen, GFP_ATOMIC);
+	if (sblk) {
+		sblk->shim = shim_proto_find_by_name(rta->name);
+		if (sblk->shim) {
+			sblk->datalen = rta->datalen;
+			memcpy(sblk->data, rta->data, rta->datalen);
+			return sblk;
+		}
+		kfree (sblk);
+	}
+	return NULL;
+}
+
+/**
+ *	shim_destroy_blk - free memory a refcnts used bt a shim blk
+ *	@sblk: shim blk
+ *
+ *	Release ref to shim proto and free memory
+ */
+void shim_destroy_blk(struct shim_blk *sblk)
+{
+	shim_proto_release(sblk->shim);
+	kfree(sblk);
+}
+
+/**
+ *	shim_unbuild_blk - copy data from various parts of a shim block
+ *			   into a form which can be used by netlink
+ *	@rta: contigous destination memory of size rtshim + datalen
+ *	@sblk: active shim blk
+ *
+ *	Search the kernels list of shim handlers looking for
+ *	a handler with this specific name
+ */
+void shim_unbuild_blk(struct rtshim* rta, struct shim_blk *sblk)
+{
+	rta->datalen = sblk->datalen;
+	memcpy(rta->data, sblk->data, sblk->datalen);
+	strncpy(rta->name, sblk->shim->name, SHIMNAMSIZ);
+}
+
+/**
+ *	shim_rta_blk_cmp - compare config info with an active shim blk
+ *	@rta: config data
+ *	@sblk: shim blk
+ *
+ *	Used for comparing new config data with existing shim blks
+ */
+int shim_cfg_blk_cmp(struct rtshim *a, struct shim_blk *b)
+{
+	int n = 0;
+	if (a && b) {
+		if (!(n = strncmp(a->name, b->shim->name, SHIMNAMSIZ)))
+		    n = memcmp(a->data, b->data, a->datalen);
+	} else {
+		if (a) n = 1;
+		if (b) n = -1;
+	}
+	return n;
+}
+
+/**
+ *	shim_blk_cmp - compare two active shim blks
+ *	@a: shim blk
+ *	@b: shim blk
+ *
+ *	Used for comparing two existing shim blks
+ */
+int shim_blk_cmp(struct shim_blk *a, struct shim_blk *b)
+{
+	int n = 0;
+	if (a && b) {
+		if (!(n = strncmp(a->shim->name, b->shim->name, SHIMNAMSIZ)))
+		    n = memcmp(a->data, b->data, a->datalen);
+	} else {
+		if (a) n = 1;
+		if (b) n = -1;
+	}
+	return n;
+}
+
+#ifdef CONFIG_PROC_FS
+static struct shim *shim_skip(struct shim *shim)
+{
+	struct shim *shim1;
+	int next = 0;
+
+	if (!shim)
+		next = 1;
+		
+	list_for_each_entry(shim1, &shim_proto_list, list) {
+		if (next)
+			return shim1;
+
+		if (shim1 == shim)
+			next = 1;
+	}
+
+	return NULL;
+}
+
+static void *shim_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	struct shim *shim;
+	loff_t i = 1;
+
+	spin_lock_bh(&shim_proto_lock);
+
+	if (*pos == 0)
+		return SEQ_START_TOKEN;
+
+	for (shim = shim_skip(NULL); shim && i < *pos;
+		shim = shim_skip(shim), ++i);
+										
+	return (i == *pos) ? shim : NULL;
+}
+
+static void *shim_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	++*pos;
+										
+	return shim_skip((v == SEQ_START_TOKEN)
+			    ? NULL
+			    : (struct shim *)v);
+}
+										
+static void shim_seq_stop(struct seq_file *seq, void *v)
+{
+	spin_unlock_bh(&shim_proto_lock);
+}
+
+static int shim_seq_show(struct seq_file *seq, void *v)
+{
+	struct shim* shim = (struct shim*)v;
+	if (v != SEQ_START_TOKEN)
+		seq_printf(seq, "%s\t%d\n",
+		    shim->name ? shim->name : "(none)",
+		    atomic_read(&shim->refcnt));
+	return 0;
+}
+
+static struct seq_operations shim_seq_ops = {
+	.start = shim_seq_start,
+	.next = shim_seq_next,
+	.stop = shim_seq_stop,
+	.show = shim_seq_show,
+};
+										
+static int shim_seq_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &shim_seq_ops);
+}
+										
+static struct file_operations shim_seq_fops = {
+	.owner   = THIS_MODULE,
+	.open    = shim_seq_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = seq_release,
+};
+
+static int __net_init shim_proc_net_init(struct net *net)
+{
+	if (!proc_net_fops_create(net, "shim",  S_IRUGO, &shim_seq_fops))
+	    return -ENOMEM;
+	return 0;
+}
+
+static void __net_exit shim_proc_net_exit(struct net *net)
+{
+	proc_net_remove(net, "shim");
+}
+
+static struct pernet_operations __net_initdata shim_proc_ops = {
+	.init = shim_proc_net_init,
+	.exit = shim_proc_net_exit,
+};
+
+static int __init shim_proc_init(void)
+{
+	return register_pernet_subsys(&shim_proc_ops);
+}
+#else
+#define shim_proc_init() 0
+#endif
+
+static int __init shim_init(void)
+{
+	printk("NET: shim interface - <jleu@mindspring.com>\n");
+	INIT_LIST_HEAD(&shim_proto_list);
+	if (shim_proc_init())
+	    return -ENOMEM;
+	return 0;
+}
+
+subsys_initcall(shim_init);
+
+EXPORT_SYMBOL(shim_proto_add);
+EXPORT_SYMBOL(shim_proto_remove);
+EXPORT_SYMBOL(shim_build_blk);
+EXPORT_SYMBOL(shim_destroy_blk);
diff -Naur linux-kernel-rpm-f8/net/ipv4/fib_frontend.c mpls-kernel-rpm-f8_modified/net/ipv4/fib_frontend.c
--- linux-kernel-rpm-f8/net/ipv4/fib_frontend.c	2008-10-17 10:00:34.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/ipv4/fib_frontend.c	2008-10-17 09:44:17.000000000 +0200
@@ -507,6 +507,7 @@
 	[RTA_METRICS]		= { .type = NLA_NESTED },
 	[RTA_MULTIPATH]		= { .len = sizeof(struct rtnexthop) },
 	[RTA_FLOW]		= { .type = NLA_U32 },
+	[RTA_SHIM]		= { .len = sizeof(struct rtshim) },
 };
 
 static int rtm_to_fib_config(struct net *net, struct sk_buff *skb,
@@ -572,6 +573,9 @@
 		case RTA_TABLE:
 			cfg->fc_table = nla_get_u32(attr);
 			break;
+		case RTA_SHIM:
+			memcpy(&cfg->fc_shim, nla_data(attr), nla_len(attr));
+			break;
 		}
 	}
 
diff -Naur linux-kernel-rpm-f8/net/ipv4/fib_semantics.c mpls-kernel-rpm-f8_modified/net/ipv4/fib_semantics.c
--- linux-kernel-rpm-f8/net/ipv4/fib_semantics.c	2008-10-17 10:00:35.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/ipv4/fib_semantics.c	2008-10-17 09:44:17.000000000 +0200
@@ -44,6 +44,7 @@
 #include <net/ip_fib.h>
 #include <net/netlink.h>
 #include <net/nexthop.h>
+#include <net/shim.h>
 
 #include "fib_lookup.h"
 
@@ -147,9 +148,12 @@
 		return;
 	}
 	change_nexthops(fi) {
+		if (nh->nh_shim)
+			shim_destroy_blk(nh->nh_shim);
 		if (nh->nh_dev)
 			dev_put(nh->nh_dev);
 		nh->nh_dev = NULL;
+		nh->nh_shim = NULL;
 	} endfor_nexthops(fi);
 	fib_info_cnt--;
 	release_net(fi->fib_net);
@@ -188,6 +192,7 @@
 #ifdef CONFIG_NET_CLS_ROUTE
 		    nh->nh_tclassid != onh->nh_tclassid ||
 #endif
+		    shim_blk_cmp(nh->nh_shim, onh->nh_shim) ||
 		    ((nh->nh_flags^onh->nh_flags)&~RTNH_F_DEAD))
 			return -1;
 		onh++;
@@ -410,6 +415,8 @@
 			nla = nla_find(attrs, attrlen, RTA_FLOW);
 			nh->nh_tclassid = nla ? nla_get_u32(nla) : 0;
 #endif
+			nla = nla_find(attrs, attrlen, RTA_SHIM);
+			nh->nh_shim = nla ? shim_build_blk(nla_data(nla)):NULL;
 		}
 
 		rtnh = rtnh_next(rtnh, &remaining);
@@ -432,6 +439,7 @@
 
 	if (cfg->fc_oif || cfg->fc_gw) {
 		if ((!cfg->fc_oif || cfg->fc_oif == fi->fib_nh->nh_oif) &&
+		    (!cfg->fc_shim.datalen || shim_cfg_blk_cmp(&cfg->fc_shim, fi->fib_nh->nh_shim) == 0) &&
 		    (!cfg->fc_gw  || cfg->fc_gw == fi->fib_nh->nh_gw))
 			return 0;
 		return 1;
@@ -465,6 +473,9 @@
 			if (nla && nla_get_u32(nla) != nh->nh_tclassid)
 				return 1;
 #endif
+			nla = nla_find(attrs, attrlen, RTA_SHIM);
+			if (nla && shim_cfg_blk_cmp(nla_data(nla), nh->nh_shim))
+				return 1;
 		}
 
 		rtnh = rtnh_next(rtnh, &remaining);
@@ -766,6 +777,8 @@
 			goto err_inval;
 		if (cfg->fc_gw && fi->fib_nh->nh_gw != cfg->fc_gw)
 			goto err_inval;
+		if (cfg->fc_shim.datalen && shim_cfg_blk_cmp(&cfg->fc_shim, fi->fib_nh->nh_shim))
+			goto err_inval;
 #ifdef CONFIG_NET_CLS_ROUTE
 		if (cfg->fc_flow && fi->fib_nh->nh_tclassid != cfg->fc_flow)
 			goto err_inval;
@@ -785,10 +798,15 @@
 #ifdef CONFIG_IP_ROUTE_MULTIPATH
 		nh->nh_weight = 1;
 #endif
+		if (cfg->fc_shim.datalen) {
+			nh->nh_shim = shim_build_blk(&cfg->fc_shim);
+			if (!nh->nh_shim)
+				goto err_inval;
+		}
 	}
 
 	if (fib_props[cfg->fc_type].error) {
-		if (cfg->fc_gw || cfg->fc_oif || cfg->fc_mp)
+		if (cfg->fc_gw || cfg->fc_oif || cfg->fc_mp || cfg->fc_shim.datalen)
 			goto err_inval;
 		goto link_it;
 	}
@@ -992,6 +1010,16 @@
 		if (fi->fib_nh[0].nh_tclassid)
 			NLA_PUT_U32(skb, RTA_FLOW, fi->fib_nh[0].nh_tclassid);
 #endif
+		if (fi->fib_nh->nh_shim) {
+			struct nlattr *nla = nla_reserve(skb, RTA_SHIM,
+				sizeof(struct rtshim) +
+				fi->fib_nh->nh_shim->datalen);
+			struct rtshim *shim = nla_data(nla);
+			if (nla == NULL)
+				goto nla_put_failure;
+
+			shim_unbuild_blk(shim, fi->fib_nh->nh_shim);
+		}
 	}
 #ifdef CONFIG_IP_ROUTE_MULTIPATH
 	if (fi->fib_nhs > 1) {
@@ -1017,6 +1045,16 @@
 			if (nh->nh_tclassid)
 				NLA_PUT_U32(skb, RTA_FLOW, nh->nh_tclassid);
 #endif
+			if (nh->nh_shim) {
+				struct nlattr *nla = nla_reserve(skb, RTA_SHIM,
+					sizeof(struct rtshim) +
+					nh->nh_shim->datalen);
+				struct rtshim *shim = nla_data(nla);
+				if (nla == NULL)
+					goto nla_put_failure;
+
+				shim_unbuild_blk(shim, nh->nh_shim);
+			}
 			/* length of rtnetlink header + attributes */
 			rtnh->rtnh_len = nlmsg_get_pos(skb) - (void *) rtnh;
 		} endfor_nexthops(fi);
diff -Naur linux-kernel-rpm-f8/net/ipv4/ip_input.c mpls-kernel-rpm-f8_modified/net/ipv4/ip_input.c
--- linux-kernel-rpm-f8/net/ipv4/ip_input.c	2008-10-17 10:00:37.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/ipv4/ip_input.c	2008-10-17 09:44:20.000000000 +0200
@@ -449,3 +449,4 @@
 }
 
 EXPORT_SYMBOL(ip_statistics);
+EXPORT_SYMBOL(ip_rcv);
diff -Naur linux-kernel-rpm-f8/net/ipv4/ip_output.c mpls-kernel-rpm-f8_modified/net/ipv4/ip_output.c
--- linux-kernel-rpm-f8/net/ipv4/ip_output.c	2008-10-17 10:00:37.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/ipv4/ip_output.c	2008-10-17 09:44:21.000000000 +0200
@@ -188,6 +188,11 @@
 	else if (rt->rt_type == RTN_BROADCAST)
 		IP_INC_STATS(IPSTATS_MIB_OUTBCASTPKTS);
 
+	if (dst->child) {
+		skb->dst = dst_pop(skb->dst);
+		return dst_output(skb);
+	}
+
 	/* Be paranoid, rather than too clever. */
 	if (unlikely(skb_headroom(skb) < hh_len && dev->header_ops)) {
 		struct sk_buff *skb2;
diff -Naur linux-kernel-rpm-f8/net/ipv4/Kconfig mpls-kernel-rpm-f8_modified/net/ipv4/Kconfig
--- linux-kernel-rpm-f8/net/ipv4/Kconfig	2008-10-17 10:00:30.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/ipv4/Kconfig	2008-10-17 09:44:09.000000000 +0200
@@ -190,6 +190,15 @@
 	  operating on your network. Read
 	  <file:Documentation/filesystems/nfsroot.txt> for details.
 
+config IP_MPLS
+	tristate "IP: MPLS support"
+	depends on INET && MPLS
+	---help---
+	  If you say Y here, the kernel will support being an ingress and
+	  egress LER for IPv4 packets
+
+	  If unsure, say N.
+
 # not yet ready..
 #   bool '    IP: ARP support' CONFIG_IP_PNP_ARP		
 config NET_IPIP
diff -Naur linux-kernel-rpm-f8/net/ipv4/Makefile mpls-kernel-rpm-f8_modified/net/ipv4/Makefile
--- linux-kernel-rpm-f8/net/ipv4/Makefile	2008-10-17 10:00:30.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/ipv4/Makefile	2008-10-17 09:44:09.000000000 +0200
@@ -32,6 +32,7 @@
 obj-$(CONFIG_INET_XFRM_MODE_TRANSPORT) += xfrm4_mode_transport.o
 obj-$(CONFIG_INET_XFRM_MODE_TUNNEL) += xfrm4_mode_tunnel.o
 obj-$(CONFIG_IP_PNP) += ipconfig.o
+obj-$(CONFIG_IP_MPLS) += mpls4.o
 obj-$(CONFIG_NETFILTER)	+= netfilter.o netfilter/
 obj-$(CONFIG_IP_VS) += ipvs/
 obj-$(CONFIG_INET_DIAG) += inet_diag.o 
diff -Naur linux-kernel-rpm-f8/net/ipv4/mpls4.c mpls-kernel-rpm-f8_modified/net/ipv4/mpls4.c
--- linux-kernel-rpm-f8/net/ipv4/mpls4.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/ipv4/mpls4.c	2008-10-17 09:44:14.000000000 +0200
@@ -0,0 +1,394 @@
+/* mpls4.c: IPv4 MPLS protocol driver.
+ *
+ * Copyright (C) 2003 David S. Miller (davem@redhat.com)
+ *
+ * Changes:
+ *	JLEU: 	Add ICMP handling
+ *		Add nexthop printing
+ *		Change nexthop resolve signature
+ *	JLEU:	Added mpls4_cache_flush()
+ *	JLEU:	un/register reserved labels in fini/init
+ *	JLEU:	removed sysfs print routin
+ */
+
+#include <linux/module.h>
+#include <linux/socket.h>
+#include <linux/skbuff.h>
+#include <linux/in.h>
+#include <linux/init.h>
+#include <net/dsfield.h>
+#include <net/neighbour.h>
+#include <net/route.h>
+#include <net/ip.h>
+#include <net/mpls.h>
+#include <net/icmp.h>
+#include <net/checksum.h>
+#include <net/arp.h>
+
+MODULE_LICENSE("GPL");
+
+static void mpls4_cache_flush(void)
+{
+	rt_cache_flush(0);
+}
+
+static void mpls4_set_ttl(struct sk_buff *skb, int ttl)
+{
+	ip_hdr(skb)->ttl = ttl;
+	ip_send_check(ip_hdr(skb));
+}
+
+static int mpls4_get_ttl(struct sk_buff *skb)
+{
+	return ip_hdr(skb)->ttl;
+}
+
+static void mpls4_change_dsfield(struct sk_buff *skb, int ds)
+{
+	ipv4_change_dsfield(ip_hdr(skb), 0x3, ds << 2);
+}
+
+static int mpls4_get_dsfield(struct sk_buff *skb)
+{
+	return ipv4_get_dsfield(ip_hdr(skb)) >> 2;
+}
+
+struct mpls_icmp_common {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8    res1:4,
+		version:4;
+#elif defined (__BIG_ENDIAN_BITFIELD)
+	__u8    version:4,
+		res1:4;
+#else
+#error  "Please fix <asm/byteorder.h>"
+#endif
+	__u8	res2;
+	__u16	check;
+};
+
+struct mpls_icmp_object {
+	__u16	length;
+	__u8	class;
+	__u8	type;
+};
+
+/* we can probably used a modified ip_append_data to build this */
+static struct sk_buff*
+mpls4_build_icmp(struct sk_buff *skb, int type, unsigned int icmp_data,
+	int mpls)
+{
+	unsigned char buf[576];
+
+	struct icmphdr *icmph;
+	struct sk_buff *nskb;
+	unsigned char *data;
+	struct rtable *rt;
+	struct iphdr *iph;
+
+	unsigned int icmp_start = 0;
+	unsigned int len = 0;
+	unsigned int real;
+	unsigned int max;
+	unsigned int height;
+	int pull;
+
+	/* find the distance to the bottom of the MPLS stack */
+	pull = mpls_find_payload(skb);
+	if (pull < 0)
+		goto error_0;
+
+	if (!skb_pull(skb, pull))
+		goto error_0;
+
+	height = skb->data - MPLSCB(skb)->top_of_stack;
+
+	/* now where at the payload, for now we're
+	 * assuming this is IPv4
+	 */
+	skb->network_header = skb->data;
+
+	/* buid a new skb, that will be big enough to hold
+	 * a maximum of 576 bytes (RFC792)
+	 */
+	if ((skb->len + skb_tailroom(skb)) < 576) {
+		nskb = skb_copy_expand(skb, skb_headroom(skb),
+			(576 + 16) - skb->len, GFP_ATOMIC);
+	} else {
+		nskb = skb_copy(skb, GFP_ATOMIC);
+	}
+
+	if (!nskb)
+		goto error_0;
+
+	/* I don't handle IP options */
+	if (ip_hdr(nskb)->ihl > 5) {
+		printk("Options!!!!\n");
+		goto error_1;
+	}
+
+	memset(buf, 0, sizeof(buf));
+
+	/* point to the buf, we'll build our ICMP message there
+	 * then copy to nskb when we're done
+	 */
+	iph = (struct iphdr*)&buf[len];
+	iph->version = 4;
+	iph->ihl = 5;
+	iph->tos = ip_hdr(nskb)->tos;
+	iph->tot_len = 0;
+	iph->id = 0;
+	iph->frag_off = 0;
+	iph->ttl = sysctl_mpls_default_ttl;
+	iph->protocol = IPPROTO_ICMP;
+	iph->check = 0;
+	iph->saddr = ip_hdr(nskb)->daddr;
+	iph->daddr = ip_hdr(nskb)->saddr;
+	len += sizeof(struct iphdr);
+
+	icmp_start = len;
+ 	icmph = (struct icmphdr*)&buf[len];
+	icmph->checksum = 0;
+	icmph->un.gateway = icmp_data;
+
+	switch (type) {
+		case ICMP_TIME_EXCEEDED:
+			icmph->type = ICMP_TIME_EXCEEDED;
+			icmph->code = ICMP_EXC_TTL;
+			break;
+		case ICMP_DEST_UNREACH:
+			icmph->type = ICMP_DEST_UNREACH;
+			icmph->code = ICMP_FRAG_NEEDED;
+			break;
+		default:
+			BUG_ON(1);
+			break;
+	}
+	len += sizeof(struct icmphdr);
+
+ 	data = &buf[len];
+	if (mpls) {
+		max = 128;
+	} else {
+		max = 576 - len;
+	}
+	real = (nskb->len > max) ? max : skb->len;
+	memcpy(data, nskb->data, real);
+
+	if (!mpls) {
+		len += real;
+	} else {
+		struct mpls_icmp_common *common;
+		struct mpls_icmp_object *object;
+		unsigned char *mpls_data = NULL;
+		unsigned int obj_start = 0;
+		unsigned int mpls_start = 0;
+
+		len += 128;
+
+		mpls_start = len;
+		common = (struct mpls_icmp_common*)&buf[len];
+		common->version = 2;
+		common->res1 = 0;
+		common->res2 = 0;
+		common->check = 0;
+		len += sizeof(struct mpls_icmp_common);
+
+		obj_start = len;
+		object = (struct mpls_icmp_object*)&buf[len];
+		object->length = 0;
+		object->class = 1;
+		object->type = 1;
+		len += sizeof(struct mpls_icmp_object);
+
+		mpls_data = &buf[len];
+		memcpy(mpls_data, MPLSCB(skb)->top_of_stack, height);
+		len += height;
+
+		object->length = htons(len - obj_start);
+		common->check = csum_fold (csum_partial ((char*)common,
+			len - mpls_start, 0));
+	}
+
+	iph->tot_len = htons(len);
+	ip_send_check(iph);
+	icmph->checksum = csum_fold (csum_partial ((char*)icmph,
+		len - icmp_start, 0));
+
+	nskb->len = len;
+	memcpy(nskb->data, buf, nskb->len);
+	nskb->tail = nskb->data + nskb->len;
+
+	nskb->ip_summed = CHECKSUM_NONE;
+	nskb->csum = 0;
+
+	{
+		struct flowi fl = {
+			.nl_u = { .ip4_u = {
+					.daddr = iph->daddr,
+					.saddr = iph->saddr,
+					.tos = RT_TOS(iph->tos) } },
+			.proto = IPPROTO_ICMP };
+
+		if (ip_route_output_key(&init_net, &rt, &fl))
+			goto error_1;
+	}
+
+	if (nskb->dst)
+		dst_release(nskb->dst);
+
+	nskb->dst = &rt->u.dst;
+
+	return nskb;
+
+error_1:
+	kfree_skb(nskb);
+error_0:
+	return NULL;
+}
+
+/* Policy decision, several options:
+ *
+ * 1) Silently discard
+ * 2) Pops all MPLS headers, use resulting upper-layer
+ *    protocol packet to generate ICMP.
+ * 3) Walk down MPLS headers to upper-layer header,
+ *    generate ICMP using that and then prepend
+ *    IDENTICAL MPLS header stack to ICMP packet.
+ *
+ * Problem with #2 is that there may be no route to
+ * upper-level packet source for us to use.  (f.e. we
+ * are switching VPN packets that we have no routes to).
+ *
+ * Option #3 should work even in those cases, because it
+ * is more likely that egress of this MPLS path knows how
+ * to route such packets back to source.  It should also
+ * not be susceptible to loops in MPLS fabric, since one
+ * never responds to ICMP with ICMP.  It is deliberate
+ * assumption made about upper-layer protocol.
+ */
+static int mpls4_ttl_expired(struct sk_buff **skb)
+{
+	struct sk_buff *nskb;
+
+	if ((nskb = mpls4_build_icmp(*skb, ICMP_TIME_EXCEEDED, 0, 1)))
+		if (dst_output(nskb))
+			kfree_skb(nskb);
+
+	/* make sure the MPLS stack frees the original skb! */
+	return NET_RX_DROP;
+}
+
+static int mpls4_mtu_exceeded(struct sk_buff **skb, int mtu)
+{
+	struct sk_buff *nskb;
+
+	if ((nskb = mpls4_build_icmp(*skb, ICMP_DEST_UNREACH, htonl(mtu), 0)))
+		if (dst_output(nskb))
+			kfree_skb(nskb);
+
+	/* make sure the MPLS stack frees the original skb! */
+	return MPLS_RESULT_DROP;
+}
+
+static int mpls4_local_deliver(struct sk_buff *skb)
+{
+	skb->protocol = htons(ETH_P_IP);
+	memset(skb->cb, 0, sizeof(skb->cb));
+	dst_release(skb->dst);
+	skb->dst = NULL;
+	return ip_rcv(skb, skb->dev, NULL, skb->dev);
+}
+
+#if defined(CONFIG_ATM_CLIP) || defined(CONFIG_ATM_CLIP_MODULE)
+extern struct neigh_table *clip_tbl_hook;
+#endif
+
+static int mpls4_nexthop_resolve(struct neighbour **np, struct sockaddr *sock_addr, struct net_device *dev)
+{
+	struct sockaddr_in *addr = (struct sockaddr_in *) sock_addr;
+	struct neighbour *n;
+	u32 nexthop;
+
+	if (addr->sin_family == AF_INET) {
+		nexthop = addr->sin_addr.s_addr;
+	} else if (!addr->sin_family) {
+		nexthop = 0;
+	} else {
+	        return -EINVAL;
+	}
+
+	n = __neigh_lookup_errno(
+#if defined(CONFIG_ATM_CLIP) || defined(CONFIG_ATM_CLIP_MODULE)
+		dev->type == ARPHRD_ATM ? clip_tbl_hook :
+#endif
+		&arp_tbl, &nexthop, dev);
+
+	if (IS_ERR(n))
+	    return PTR_ERR(n);
+
+	*np = n;
+	return 0;
+}
+
+static struct mpls_prot_driver mpls4_driver = {
+	.name			=	"ipv4",
+	.family                 =       AF_INET,
+	.ethertype              =       __constant_htons(ETH_P_IP),
+	.cache_flush            =       mpls4_cache_flush,
+	.set_ttl                =       mpls4_set_ttl,
+	.get_ttl                =       mpls4_get_ttl,
+	.change_dsfield         =       mpls4_change_dsfield,
+	.get_dsfield            =       mpls4_get_dsfield,
+	.ttl_expired            =       mpls4_ttl_expired,
+	.mtu_exceeded		=	mpls4_mtu_exceeded,
+	.local_deliver		=	mpls4_local_deliver,
+	.nexthop_resolve        =       mpls4_nexthop_resolve,
+	.owner                  =       THIS_MODULE,
+};
+
+static int __init mpls4_init(void)
+{
+	struct mpls_instr_elem instr[2];
+	struct mpls_label ml;
+	struct mpls_ilm *ilm;
+	int result = mpls_proto_add(&mpls4_driver);
+
+	printk("MPLS: IPv4 over MPLS support\n");
+
+	if (result)
+		return result;
+
+	ml.ml_type = MPLS_LABEL_GEN;
+	ml.u.ml_gen = MPLS_IPV4_EXPLICIT_NULL;
+
+	instr[0].mir_direction = MPLS_IN;
+	instr[0].mir_opcode    = MPLS_OP_POP;
+	instr[1].mir_direction = MPLS_IN;
+	instr[1].mir_opcode    = MPLS_OP_DLV;
+
+	ilm = mpls_ilm_dst_alloc(0, &ml, AF_INET, instr, 2);
+	if (!ilm)
+		return -ENOMEM;
+
+	result = mpls_add_reserved_label(MPLS_IPV4_EXPLICIT_NULL, ilm);
+	if (result) {
+		ilm->u.dst.obsolete = 1;
+		dst_free(&ilm->u.dst);
+		return result;
+	}
+
+	return 0;
+}
+
+static void __exit mpls4_fini(void)
+{
+	struct mpls_ilm *ilm = mpls_del_reserved_label(MPLS_IPV4_EXPLICIT_NULL);
+	if (ilm) {
+		__mpls_del_in_label(ilm);
+	}
+	mpls_proto_remove(&mpls4_driver);
+}
+
+module_init(mpls4_init);
+module_exit(mpls4_fini);
diff -Naur linux-kernel-rpm-f8/net/ipv4/route.c mpls-kernel-rpm-f8_modified/net/ipv4/route.c
--- linux-kernel-rpm-f8/net/ipv4/route.c	2008-10-17 10:00:42.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/ipv4/route.c	2008-10-17 09:44:28.000000000 +0200
@@ -109,6 +109,7 @@
 #ifdef CONFIG_SYSCTL
 #include <linux/sysctl.h>
 #endif
+#include <net/shim.h>
 
 #define RT_FL_TOS(oldflp) \
     ((u32)(oldflp->fl4_tos & (IPTOS_RT_MASK | RTO_ONLINK)))
@@ -1604,6 +1605,7 @@
 static void rt_set_nexthop(struct rtable *rt, struct fib_result *res, u32 itag)
 {
 	struct fib_info *fi = res->fi;
+	struct shim_blk *sblk;
 
 	if (fi) {
 		if (FIB_RES_GW(*res) &&
@@ -1611,7 +1613,10 @@
 			rt->rt_gateway = FIB_RES_GW(*res);
 		memcpy(rt->u.dst.metrics, fi->fib_metrics,
 		       sizeof(rt->u.dst.metrics));
-		if (fi->fib_mtu == 0) {
+		if ((sblk = FIB_RES_SHIM(*res)))
+			sblk->shim->build(sblk, &rt->u.dst);
+
+		if (!rt->u.dst.metrics[RTAX_MTU-1]) {
 			rt->u.dst.metrics[RTAX_MTU-1] = rt->u.dst.dev->mtu;
 			if (dst_metric_locked(&rt->u.dst, RTAX_MTU) &&
 			    rt->rt_gateway != rt->rt_dst &&
@@ -3093,3 +3098,4 @@
 EXPORT_SYMBOL(__ip_select_ident);
 EXPORT_SYMBOL(ip_route_input);
 EXPORT_SYMBOL(ip_route_output_key);
+EXPORT_SYMBOL(rt_cache_flush);
diff -Naur linux-kernel-rpm-f8/net/ipv6/ip6_input.c mpls-kernel-rpm-f8_modified/net/ipv6/ip6_input.c
--- linux-kernel-rpm-f8/net/ipv6/ip6_input.c	2008-10-17 10:00:48.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/ipv6/ip6_input.c	2008-10-17 09:44:39.000000000 +0200
@@ -327,3 +327,5 @@
 
 	return 0;
 }
+
+EXPORT_SYMBOL(ipv6_rcv);
diff -Naur linux-kernel-rpm-f8/net/ipv6/ip6_output.c mpls-kernel-rpm-f8_modified/net/ipv6/ip6_output.c
--- linux-kernel-rpm-f8/net/ipv6/ip6_output.c	2008-10-17 10:00:48.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/ipv6/ip6_output.c	2008-10-17 09:44:40.000000000 +0200
@@ -100,6 +100,11 @@
 {
 	struct dst_entry *dst = skb->dst;
 
+	if (dst->child) {
+		skb->dst = dst_pop(skb->dst);
+		return dst_output(skb);
+	}
+
 	if (dst->hh)
 		return neigh_hh_output(dst->hh, skb);
 	else if (dst->neighbour)
diff -Naur linux-kernel-rpm-f8/net/ipv6/Kconfig mpls-kernel-rpm-f8_modified/net/ipv6/Kconfig
--- linux-kernel-rpm-f8/net/ipv6/Kconfig	2008-10-17 10:00:46.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/ipv6/Kconfig	2008-10-17 09:44:34.000000000 +0200
@@ -21,6 +21,15 @@
 
 if IPV6
 
+config INET6_MPLS
+	tristate "IPv6: MPLS support"
+	depends on IPV6 && MPLS
+	---help---
+	  If you say Y here, the kernel will support being an ingress
+	  and egress LER for IPv6 packets.
+
+	  If unsure, say N.
+
 config IPV6_PRIVACY
 	bool "IPv6: Privacy Extensions support"
 	---help---
diff -Naur linux-kernel-rpm-f8/net/ipv6/Makefile mpls-kernel-rpm-f8_modified/net/ipv6/Makefile
--- linux-kernel-rpm-f8/net/ipv6/Makefile	2008-10-17 10:00:46.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/ipv6/Makefile	2008-10-17 09:44:34.000000000 +0200
@@ -32,6 +32,7 @@
 obj-$(CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION) += xfrm6_mode_ro.o
 obj-$(CONFIG_INET6_XFRM_MODE_BEET) += xfrm6_mode_beet.o
 obj-$(CONFIG_IPV6_MIP6) += mip6.o
+obj-$(CONFIG_INET6_MPLS) += mpls6.o
 obj-$(CONFIG_NETFILTER)	+= netfilter/
 
 obj-$(CONFIG_IPV6_SIT) += sit.o
diff -Naur linux-kernel-rpm-f8/net/ipv6/mpls6.c mpls-kernel-rpm-f8_modified/net/ipv6/mpls6.c
--- linux-kernel-rpm-f8/net/ipv6/mpls6.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/ipv6/mpls6.c	2008-10-17 09:44:42.000000000 +0200
@@ -0,0 +1,185 @@
+/* mpls6.c: IPv6 MPLS protocol driver.
+ *
+ * Copyright (C) 2003 David S. Miller (davem@redhat.com)
+ *
+ * Changes:
+ *	JLEU:	Add ICMP handling stubs
+ *		Add nexthop printing
+ *		Change nexthop resolve signature
+ *	JLEU:	Added mpls6_cache_flush()
+ *	JLEU:	un/register reserved labels in fini/init
+ *	JLEU:	remove sysfs print routin
+ */
+
+#include <linux/module.h>
+#include <linux/socket.h>
+#include <linux/skbuff.h>
+#include <linux/in6.h>
+#include <linux/init.h>
+#include <linux/seq_file.h>
+#include <net/dsfield.h>
+#include <net/neighbour.h>
+#include <net/ipv6.h>
+#include <net/ip6_route.h>
+#include <net/dst.h>
+#include <net/mpls.h>
+
+MODULE_LICENSE("GPL");
+
+extern int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev);
+
+static void mpls6_cache_flush(void)
+{
+	/* is there a ipv6 equiv to ipv4's rt_cache_flush(0) ? */
+}
+
+static void mpls6_set_ttl(struct sk_buff *skb, int ttl)
+{
+	/*ipv6_hdr(skb)->hop_limit; RCAS*/
+	ipv6_hdr(skb)->hop_limit = ttl;
+}
+
+static int mpls6_get_ttl(struct sk_buff *skb)
+{
+	return ipv6_hdr(skb)->hop_limit;
+}
+
+static void mpls6_change_dsfield(struct sk_buff *skb, int ds)
+{
+	ipv6_change_dsfield(ipv6_hdr(skb), 0x3, ds);
+}
+
+static int mpls6_get_dsfield(struct sk_buff *skb)
+{
+	return ipv6_get_dsfield(ipv6_hdr(skb));
+}
+
+/* Policy decision, several options:
+ *
+ * 1) Silently discard
+ * 2) Pops all MPLS headers, use resulting upper-layer
+ *    protocol packet to generate ICMP.
+ * 3) Walk down MPLS headers to upper-layer header,
+ *    generate ICMP using that and then prepend
+ *    IDENTICAL MPLS header stack to ICMP packet.
+ *
+ * Problem with #2 is that there may be no route to
+ * upper-level packet source for us to use.  (f.e. we
+ * are switching VPN packets that we have no routes to).
+ *
+ * Option #3 should work even in those cases, because it
+ * is more likely that egress of this MPLS path knows how
+ * to route such packets back to source.  It should also
+ * not be susceptible to loops in MPLS fabric, since one
+ * never responds to ICMP with ICMP.  It is deliberate
+ * assumption made about upper-layer protocol.
+ */
+static int mpls6_ttl_expired(struct sk_buff **skb)
+{
+	return NET_RX_DROP;
+}
+
+static int mpls6_mtu_exceeded(struct sk_buff **skb, int mtu)
+{
+	return MPLS_RESULT_DROP;
+}
+
+static int mpls6_local_deliver(struct sk_buff *skb)
+{
+	skb->protocol = htons(ETH_P_IPV6);
+	memset(skb->cb, 0, sizeof(skb->cb));
+	dst_release(skb->dst);
+	skb->dst = NULL;
+	return ipv6_rcv(skb, skb->dev, NULL, skb->dev);
+}
+
+static int mpls6_nexthop_resolve(struct neighbour **np, struct sockaddr *sock_addr, struct net_device *dev)
+{
+	struct sockaddr_in6 *addr = (struct sockaddr_in6 *) sock_addr;
+	struct flowi fl = { .oif = dev->ifindex,
+	                    .nl_u = { .ip6_u = {.daddr = addr->sin6_addr } } };
+	struct dst_entry *dst;
+	int err;
+
+	if (addr->sin6_family != AF_INET6)
+	        return -EINVAL;
+
+	dst = ip6_route_output(&init_net, NULL, &fl);
+
+	err = 0;
+	if (dst->error)
+		err = -EINVAL;
+                                                                                
+	if (!err)
+		*np = neigh_clone(dst->neighbour);
+
+
+	dst_release(dst);
+
+	return err;
+}
+
+static struct mpls_prot_driver mpls6_driver = {
+	.name			=	"ipv6",
+	.family                 =       AF_INET6,
+	.ethertype              =       __constant_htons(ETH_P_IPV6),
+	.cache_flush            =       mpls6_cache_flush,
+	.set_ttl                =       mpls6_set_ttl,
+	.get_ttl                =       mpls6_get_ttl,
+	.change_dsfield         =       mpls6_change_dsfield,
+	.get_dsfield            =       mpls6_get_dsfield,
+	.ttl_expired            =       mpls6_ttl_expired,
+	.mtu_exceeded		=	mpls6_mtu_exceeded,
+	.local_deliver		=	mpls6_local_deliver,
+	.nexthop_resolve        =       mpls6_nexthop_resolve,
+	.owner                  =       THIS_MODULE,
+};
+
+static int __init mpls6_init(void)
+{
+	struct mpls_instr_elem instr[2];
+	struct mpls_label ml;
+	struct mpls_ilm *ilm;
+	int result = mpls_proto_add(&mpls6_driver);
+
+	printk("MPLS: IPv6 over MPLS support\n");
+
+	if (result)
+		return result;
+
+	ml.ml_type = MPLS_LABEL_GEN;
+	ml.u.ml_gen = MPLS_IPV6_EXPLICIT_NULL;
+
+	instr[0].mir_direction = MPLS_IN;
+	instr[0].mir_opcode    = MPLS_OP_POP;
+	instr[1].mir_direction = MPLS_IN;
+	instr[1].mir_opcode    = MPLS_OP_DLV;
+
+	ilm = mpls_ilm_dst_alloc(0, &ml, AF_INET6, instr, 2);
+	if (!ilm)
+		return -ENOMEM;
+
+	result = mpls_add_reserved_label(MPLS_IPV6_EXPLICIT_NULL, ilm);
+	if (result) {
+		ilm->u.dst.obsolete = 1;
+		dst_free(&ilm->u.dst);
+		return result;
+	}
+
+	return 0;
+}
+
+static void __exit mpls6_fini(void)
+{
+	struct mpls_ilm *ilm = mpls_del_reserved_label(MPLS_IPV6_EXPLICIT_NULL);
+	mpls_proto_remove(&mpls6_driver);
+
+	if (ilm) {
+		mpls_ilm_release(ilm);
+		ilm->u.dst.obsolete = 1;
+		call_rcu(&ilm->u.dst.rcu_head, dst_rcu_free);
+	}
+}
+
+module_init(mpls6_init);
+module_exit(mpls6_fini);
diff -Naur linux-kernel-rpm-f8/net/ipv6/route.c mpls-kernel-rpm-f8_modified/net/ipv6/route.c
--- linux-kernel-rpm-f8/net/ipv6/route.c	2008-10-17 10:00:52.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/ipv6/route.c	2008-10-17 09:44:46.000000000 +0200
@@ -39,6 +39,8 @@
 #include <linux/mroute6.h>
 #include <linux/init.h>
 #include <linux/if_arp.h>
+#include <net/shim.h>
+
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <linux/nsproxy.h>
@@ -197,6 +199,9 @@
 	struct rt6_info *rt = (struct rt6_info *)dst;
 	struct inet6_dev *idev = rt->rt6i_idev;
 
+	if (rt->rt6i_shim)
+		shim_destroy_blk(rt->rt6i_shim);
+
 	if (idev != NULL) {
 		rt->rt6i_idev = NULL;
 		in6_dev_put(idev);
@@ -1238,6 +1243,14 @@
 			}
 		}
 	}
+	if (cfg->fc_shim.datalen) {
+		rt->rt6i_shim = shim_build_blk(&cfg->fc_shim);
+		if (!rt->rt6i_shim) {
+			err = -EINVAL;
+			goto out;
+		}
+		rt->rt6i_shim->shim->build(rt->rt6i_shim, &rt->u.dst);
+	}
 
 	if (dst_metric(&rt->u.dst, RTAX_HOPLIMIT) == 0)
 		rt->u.dst.metrics[RTAX_HOPLIMIT-1] = -1;
@@ -1987,6 +2000,7 @@
 	[RTA_IIF]		= { .type = NLA_U32 },
 	[RTA_PRIORITY]          = { .type = NLA_U32 },
 	[RTA_METRICS]           = { .type = NLA_NESTED },
+	[RTA_SHIM]              = { .len = sizeof(struct rtshim) },
 };
 
 static int rtm_to_fib6_config(struct sk_buff *skb, struct nlmsghdr *nlh,
@@ -2054,6 +2068,10 @@
 	if (tb[RTA_TABLE])
 		cfg->fc_table = nla_get_u32(tb[RTA_TABLE]);
 
+	if (tb[RTA_SHIM])
+		memcpy(&cfg->fc_shim, nla_data(tb[RTA_SHIM]),
+			nla_len(tb[RTA_SHIM]));
+
 	err = 0;
 errout:
 	return err;
diff -Naur linux-kernel-rpm-f8/net/Kconfig mpls-kernel-rpm-f8_modified/net/Kconfig
--- linux-kernel-rpm-f8/net/Kconfig	2008-10-17 10:00:21.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/Kconfig	2008-10-17 09:43:53.000000000 +0200
@@ -62,6 +62,49 @@
 
 	  Short answer: say Y.
 
+config MPLS
+	tristate "Multiprotocol Label Switching"
+	depends on INET
+	---help---
+	  In conventional IP forwarding, a particular router will typically
+  	  consider two packets to be in the same FEC if there is some address
+  	  prefix X in that router's routing tables such that X is the "longest
+	  match" for each packet's destination address.  As the packet
+	  traverses the network, each hop in turn reexamines the packet and
+	  assigns it to a FEC.
+  
+	  In MPLS, the assignment of a particular packet to a particular FEC is
+	  done just once, as the packet enters the network.  The FEC to which
+	  the packet is assigned is encoded as a short fixed length value known
+	  as a "label".  When a packet is forwarded to its next hop, the label
+	  is sent along with it; that is, the packets are "labeled" before they
+	  are forwarded.
+  
+	  At subsequent hops, there is no further analysis of the packet's
+	  network layer header.  Rather, the label is used as an index into a
+	  table which specifies the next hop, and a new label.  The old label
+	  is replaced with the new label, and the packet is forwarded to its
+	  next hop.
+  
+	  In the MPLS forwarding paradigm, once a packet is assigned to a FEC,
+	  no further header analysis is done by subsequent routers; all
+	  forwarding is driven by the labels.
+
+	  If unsure, say N.
+
+config MPLS_TUNNEL
+	tristate "MPLS: Virtual tunnel interface"
+	depends on MPLS
+	---help---
+	  Allow Label Switched Paths to be represented by a virtual interface.
+	  Some find this a more comfortable paradym for mapping traffic to LSPs.
+
+	  If compiled as a module, each instantiation creates a new virtual
+	  interface.  If linked into the monolithic kernel, one and only
+	  one virtual interface is automagically created.
+
+	  If unsure, say N.
+
 if INET
 source "net/ipv4/Kconfig"
 source "net/ipv6/Kconfig"
diff -Naur linux-kernel-rpm-f8/net/Makefile mpls-kernel-rpm-f8_modified/net/Makefile
--- linux-kernel-rpm-f8/net/Makefile	2008-10-17 10:00:10.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/Makefile	2008-10-17 09:43:35.000000000 +0200
@@ -16,6 +16,7 @@
 obj-$(CONFIG_LLC)		+= llc/
 obj-$(CONFIG_NET)		+= ethernet/ 802/ sched/ netlink/
 obj-$(CONFIG_NETFILTER)		+= netfilter/
+obj-$(CONFIG_MPLS)		+= mpls/
 obj-$(CONFIG_INET)		+= ipv4/
 obj-$(CONFIG_XFRM)		+= xfrm/
 obj-$(CONFIG_UNIX)		+= unix/
diff -Naur linux-kernel-rpm-f8/net/mpls/af_mpls.c mpls-kernel-rpm-f8_modified/net/mpls/af_mpls.c
--- linux-kernel-rpm-f8/net/mpls/af_mpls.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/mpls/af_mpls.c	2008-10-17 09:45:01.000000000 +0200
@@ -0,0 +1,133 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching) Architecture for Linux.
+ *
+ * af_mpls.c
+ *	 * PF_MPLS 
+ *
+ * $Id: linux-kernel-mpls.diff,v 1.4 2008-10-20 15:44:05 max Exp $
+ *
+ * Authors:
+ *	  James Leu	<jleu@mindspring.com>
+ *
+ *   (c) 2003	James Leu	<jleu@mindspring.com>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * $ChangeLog$
+ *****************************************************************************
+ */
+
+#include <linux/autoconf.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <net/sock.h>
+#include <net/net_namespace.h>
+#include <linux/net.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/socket.h>
+
+static int mpls_release(struct socket *sock) {
+	return 0;
+}
+
+static struct proto mpls_proto = {
+	.name =		"MPLS",
+	.owner =	 THIS_MODULE,
+	.obj_size =	 sizeof(struct sock),
+};
+
+struct proto_ops mpls_sk_ops = {
+	.family =	PF_MPLS,
+	.owner =	THIS_MODULE,
+	.release =	mpls_release,
+	.bind =		sock_no_bind,
+	.connect =	sock_no_connect,
+	.socketpair =	sock_no_socketpair,
+	.accept =	sock_no_accept,
+	.getname =	sock_no_getname,
+	.poll =		sock_no_poll,
+	.ioctl =	sock_no_ioctl,
+	.listen =       sock_no_listen,
+	.shutdown =	sock_no_shutdown,
+	.setsockopt =	sock_no_setsockopt,
+	.getsockopt =	sock_no_getsockopt,
+	.sendmsg =	sock_no_sendmsg,
+	.recvmsg =	sock_no_recvmsg,
+	.mmap =		sock_no_mmap,
+	.sendpage =	sock_no_sendpage,
+};
+
+/* destruction routine */
+                                                                                
+static void mpls_sock_destruct(struct sock *sk)
+{
+        __skb_queue_purge(&sk->sk_receive_queue);
+        __skb_queue_purge(&sk->sk_error_queue);
+
+        BUG_TRAP(!atomic_read(&sk->sk_rmem_alloc));
+        BUG_TRAP(!atomic_read(&sk->sk_wmem_alloc));
+        BUG_TRAP(!sk->sk_wmem_queued);
+        BUG_TRAP(!sk->sk_forward_alloc);
+
+        dst_release(sk->sk_dst_cache);
+}
+
+/*
+ *      Create an mpls socket.
+ */
+                                                                                
+static int mpls_create(struct net *net, struct socket *sock, int protocol)
+{
+	struct sock *sk;
+
+        if (net != &init_net)
+		return -EAFNOSUPPORT;
+
+	sock->state = SS_UNCONNECTED;
+	sock->ops = &mpls_sk_ops;
+
+	sk = sk_alloc(net, PF_INET, GFP_KERNEL, &mpls_proto);
+        if (!sk)
+                return -1;
+
+	sock_init_data(sock, sk);
+
+	sk->sk_destruct    = mpls_sock_destruct;
+	sk->sk_family      = PF_MPLS;
+	sk->sk_protocol    = 0;
+	sk->sk_backlog_rcv = sk->sk_prot->backlog_rcv;
+
+	sock_reset_flag(sk, SOCK_ZAPPED);
+
+	return 0;
+}
+
+struct net_proto_family mpls_family_ops = {
+	.family = PF_MPLS,
+	.create = mpls_create,
+	.owner  = THIS_MODULE,
+};
+
+int __init mpls_sock_init(void)
+{
+	int rc;
+	if ((rc = proto_register(&mpls_proto, 0)))
+		return rc;
+
+        sock_register(&mpls_family_ops);
+
+	return 0;
+}
+
+void __exit mpls_sock_exit(void)
+{
+	sock_unregister(AF_MPLS);
+	proto_unregister(&mpls_proto);
+}
diff -Naur linux-kernel-rpm-f8/net/mpls/Makefile mpls-kernel-rpm-f8_modified/net/mpls/Makefile
--- linux-kernel-rpm-f8/net/mpls/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/mpls/Makefile	2008-10-17 09:45:01.000000000 +0200
@@ -0,0 +1,13 @@
+#
+# Makefile for the Linux MPLS layer.
+#
+
+mpls-y := af_mpls.o mpls_if.o mpls_ilm.o mpls_init.o mpls_input.o \
+	mpls_opcode.o mpls_nhlfe.o mpls_output.o \
+	mpls_utils.o mpls_dst.o mpls_netlink.o mpls_proto.o \
+	mpls_instr.o mpls_shim.o
+mpls-$(CONFIG_SYSCTL) += sysctl_net_mpls.o
+mpls-$(CONFIG_PROC_FS) += mpls_procfs.o
+
+obj-$(CONFIG_MPLS) += mpls.o
+obj-$(CONFIG_MPLS_TUNNEL) += mpls_tunnel.o
diff -Naur linux-kernel-rpm-f8/net/mpls/mpls_dst.c mpls-kernel-rpm-f8_modified/net/mpls/mpls_dst.c
--- linux-kernel-rpm-f8/net/mpls/mpls_dst.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/mpls/mpls_dst.c	2008-10-17 09:45:01.000000000 +0200
@@ -0,0 +1,270 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *	  James Leu	<jleu@mindspring.com>
+ *	  Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu        <jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *	      It implements:
+ *	      -the MPLS dst_entry life cycle.
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ *	IMPORTANT: We manage "mpls_dst" cache objects, which live in 
+ *	AF_MPLS, for either ETH_P_MPLS_UC/ETH_P_MPLS_MC. Nevertheless
+ *	these mpls_dst objects hold references to neighbours that live
+ *	in the AF_INET and/or AF_INET6 neighbour tables.
+ *
+ *	20040206 - RCAS: Note that the DST parent is the MOI object.
+ *
+ ****************************************************************************/
+
+#include <linux/autoconf.h>
+#include <linux/socket.h>
+#include <linux/in.h>
+#include <linux/in6.h>
+#include <net/mpls.h>
+
+/* forward declarations */
+static struct dst_entry *mpls_dst_check(struct dst_entry *dst, u32 cookie);
+static void		 mpls_dst_destroy(struct dst_entry *dst);
+static struct dst_entry *mpls_negative_advice(struct dst_entry *dst);
+static void		 mpls_link_failure(struct sk_buff *skb);
+static void		 mpls_dst_update_pmtu(struct dst_entry *dst, u32 mtu);
+static int		 mpls_dst_gc(struct dst_ops *ops);
+
+struct dst_ops mpls_dst_ops = {
+	.family          =  AF_MPLS,
+	.protocol        = __constant_htons(ETH_P_MPLS_UC),
+	.gc              = mpls_dst_gc,
+	.check           = mpls_dst_check,
+	.destroy         = mpls_dst_destroy,
+	.negative_advice = mpls_negative_advice,
+	.link_failure    = mpls_link_failure,
+	.update_pmtu     = mpls_dst_update_pmtu,
+	.entry_size      = sizeof(struct mpls_dst),
+};
+
+
+static struct dst_entry *
+mpls_dst_check (struct dst_entry *dst, u32 cookie)
+{
+	MPLS_ENTER;
+	dst_release(dst);
+	MPLS_EXIT;
+	return NULL;
+}
+
+
+
+/** 
+ *	mpls_dst_destroy - cleanup for a MPLS dst_entry
+ *	@dst: 'this', object that is being destroyed.
+ *
+ *	The object ends life here. Perform the necessary
+ *	clean up, but do not call dst_free(..) etc. 
+ **/
+ 
+static void 
+mpls_dst_destroy (struct dst_entry *dst)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+}
+
+
+
+static struct dst_entry *
+mpls_negative_advice (struct dst_entry *dst)
+{
+	struct mpls_dst *md = (struct mpls_dst*)dst;
+	struct dst_entry *ret = dst;
+										
+	MPLS_ENTER;
+	if (md) {
+		if (dst->obsolete || md->u.dst.expires) {
+			dst_release((struct dst_entry*)md);
+			ret = NULL;
+		}
+	}
+	MPLS_EXIT;
+	return ret;
+}
+
+static void 
+mpls_link_failure (struct sk_buff *skb)
+{
+	struct mpls_dst *md;
+
+	MPLS_ENTER;
+//	icmp_send(skb, ICMP_DEST_UNREACH, ICMP_HOST_UNREACH, 0);
+
+	if ((md = (struct mpls_dst *)skb->dst));
+		dst_set_expires(&md->u.dst, 0);
+	MPLS_EXIT;
+}
+
+int mpls_dst_mtu_expires	= 10 * 60 * HZ;
+int mpls_dst_min_pmtu		= 512 + 20 + 20 + 4;
+
+static void 
+mpls_dst_update_pmtu (struct dst_entry *dst, u32 mtu)
+{
+	MPLS_ENTER;
+	if (dst->metrics[RTAX_MTU-1] > mtu && mtu >= 68 &&
+	    !(dst_metric_locked (dst, RTAX_MTU)) ) {
+		if (mtu < mpls_dst_min_pmtu) {
+			mtu = mpls_dst_min_pmtu;
+			dst->metrics[RTAX_LOCK-1] |= (1 << RTAX_MTU);
+		}
+		dst->metrics[RTAX_MTU-1] = mtu;
+		dst_set_expires (dst, mpls_dst_mtu_expires);
+	}
+	MPLS_EXIT;
+}
+
+
+/**
+ *	mpls_dst_gc - MPLS destination cache GC policies.
+ *
+ *	Actually a NOOP. Return nonzero to veto allocation of a new DST entry.
+ **/
+static int 
+mpls_dst_gc (struct dst_ops *ops)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+	return 0;
+}
+
+
+
+
+/**
+ *	mpls_dst_alloc - construct a mpls_dst entry.
+ *	@dev: output device.
+ *	@nh: address of the next hop (IPv4 or IPv6)
+ *
+ *	Allocate a new mpls_dst cache object (which basically adds a next hop
+ *	attribute to base dst) using dst_alloc () and the dst_ops above. Lookup
+ *	(or set up) a neighbour in the AF_INET/AF_INET6 families and hold it.
+ *	The hh_type when building the neighbour will be set to ETH_P_MPLS_UC
+ *	Called when building the SET opcode, the returned object will be 
+ *	stored as the opcode data. Process context only.
+ **/
+ 
+struct mpls_dst* 
+mpls_dst_alloc ( struct net_device *dev, struct sockaddr *nh)
+{
+	struct mpls_dst		*md = NULL;
+	struct mpls_prot_driver *prot;
+
+	MPLS_ENTER;
+	BUG_ON(!nh);
+	BUG_ON(!dev);
+	MPLS_ASSERT(dev->mpls_ptr);
+
+	if (!nh->sa_family) {
+		memset(nh, 0, sizeof(struct sockaddr));
+		nh->sa_family = AF_INET;
+	}
+	prot = mpls_proto_find_by_family(nh->sa_family);
+	if (unlikely(!prot))
+		goto mpls_dst_alloc_2;
+
+	/* Allocate a MPLS dst entry */
+	md = dst_alloc (&mpls_dst_ops);
+	if (unlikely(!md)) 
+		goto mpls_dst_alloc_1;
+
+	/* Hold it */
+	dst_hold(&md->u.dst);
+
+	dev_hold(dev);
+	md->u.dst.dev   = dev;
+	md->u.dst.flags = DST_HOST;
+	md->u.dst.hh    = NULL;
+
+	/* Set next hop MPLS attr */
+	memcpy(&md->md_nh,nh,sizeof(struct sockaddr));
+
+	/* use the protocol driver to resolve the neighbour */
+	if (prot->nexthop_resolve(&md->u.dst.neighbour, nh, dev))
+		goto mpls_dst_alloc_0;
+
+	mpls_proto_release(prot);
+
+	MPLS_DEBUG("exit(%p)\n",md);
+	return md;
+
+mpls_dst_alloc_0:
+	/* dst_release releases dev and neighbour */
+	dst_release(&md->u.dst);
+	dst_free(&md->u.dst);
+
+mpls_dst_alloc_1:
+	mpls_proto_release(prot);
+
+mpls_dst_alloc_2:
+	MPLS_DEBUG("exit(%p)\n",md);
+	return NULL;
+}
+
+
+
+/**
+ *	mpls_dst_release - cleanup and release the DST. 
+ *
+ *	Call base dst_release and call_rcu.
+ *
+ *	RCAS: _NOTE_ do not release the neighbour
+ *	mdst->u.dst.neighbour. when the dst frmwk calls dst_destroy
+ *	it will be released.
+ **/
+
+void
+mpls_dst_release (struct mpls_dst* mdst)
+{
+	dst_release (&mdst->u.dst);
+	call_rcu (&mdst->u.dst.rcu_head, dst_rcu_free);
+}
+
+
+
+/** 
+ * mpls_dst_init - Create mpls DST entries slab allocator
+ *
+ **/
+ 
+int __init mpls_dst_init(void)
+{
+	mpls_dst_ops.kmem_cachep = kmem_cache_create("mpls_dst_cache",
+		sizeof(struct mpls_dst), 0, SLAB_HWCACHE_ALIGN, NULL);
+
+	if (!mpls_dst_ops.kmem_cachep) {
+		printk(MPLS_ERR "MPLS: failed to alloc mpls_dst_cache\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+
+/** 
+ * mpls_dst_exit - Destroy mpls DST entries slab allocator
+ *
+ **/ 
+
+void __exit mpls_dst_exit(void)
+{
+	if (mpls_dst_ops.kmem_cachep)
+		kmem_cache_destroy(mpls_dst_ops.kmem_cachep);
+}
diff -Naur linux-kernel-rpm-f8/net/mpls/mpls_if.c mpls-kernel-rpm-f8_modified/net/mpls/mpls_if.c
--- linux-kernel-rpm-f8/net/mpls/mpls_if.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/mpls/mpls_if.c	2008-10-17 09:45:01.000000000 +0200
@@ -0,0 +1,284 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching) Architecture for Linux.
+ *
+ * mpls_if.c
+ *         * Allocation/Deallocation of per netdevice MPLS private data
+ *           (labelspace)
+ *         * Query/Update netdevice label space functions.
+ *
+ *         Network devices (e.g. "eth0") are extended with a mpls_ptr
+ *         that contain mpls related info, most notably, the per interface
+ *         label space.
+ *
+ * Authors:
+ *          James Leu        <jleu@mindspring.com>
+ *          Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu        <jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ *****************************************************************************
+ */
+
+#include <linux/autoconf.h>
+#include <asm/uaccess.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <net/mpls.h>
+#include <linux/genetlink.h>
+#include <net/net_namespace.h>
+
+/**
+ *	mpls_create_if_info - allocate memory for the MPLS net_device extension
+ *
+ *	See struct net_device and  "void *mpls_ptr; // MPLS specific data"
+ *	Returns a pointer to the allocated struct.
+ *	RCAS: From process context only. May sleep.
+ **/
+
+struct mpls_interface *
+mpls_create_if_info (void)
+{
+	struct mpls_interface *mpls_if = NULL;
+
+	mpls_if = kmalloc ( sizeof(struct mpls_interface), GFP_KERNEL);
+	if ( unlikely(!mpls_if) ) 
+		return NULL;
+
+	memset (mpls_if, 0, sizeof(struct mpls_interface));
+	mpls_if->labelspace = -1;
+	INIT_LIST_HEAD(&mpls_if->list_out);
+	INIT_LIST_HEAD(&mpls_if->list_in);
+	return mpls_if;
+}
+
+
+
+/**
+ *	mpls_delete_if_info - free memory for the MPLS net_device extension
+ *	@mpls_if: netdevice extension.
+ *	
+ *	Deallocation of MPLS netdev extensions.
+ **/
+
+inline void 
+mpls_delete_if_info (struct mpls_interface *mpls_if)
+{
+	kfree (mpls_if);
+}
+
+
+
+
+/**
+ *	__mpls_get_labelspace - Get the interface  label space
+ *	@dev: device 
+ *
+ *	See mpls_get_labelspace for comments.
+ *	Returns the labelspace
+ **/
+
+static inline int 
+__mpls_get_labelspace (struct net_device *dev)
+{
+	return (dev->mpls_ptr) ? _mpls_as_if(dev->mpls_ptr)->labelspace : -1;
+}
+
+
+
+
+/**
+ *	mpls_get_labelspace_by_name - Get the interface  label space
+ *	@name: name of the interface
+ *
+ *	See mpls_get_labelspace for comments.
+ *	Returns the labelspace
+ **/
+
+int 
+mpls_get_labelspace_by_name (const char* name)
+{
+	int result = -1;
+	struct net_device *dev = dev_get_by_name (&init_net, name);
+	if (dev) {
+		result = __mpls_get_labelspace (dev);
+		dev_put (dev);
+	}
+	return result;
+}
+
+
+
+
+/**
+ *	mpls_set_labelspace_by_index - Get the interface  label space
+ *	@ifindex:  interface index 
+ *
+ *	See mpls_get_labelspace for comments.
+ *	Returns the labelspace
+ **/
+
+int 
+mpls_get_labelspace_by_index (int ifindex)
+{
+	int result = -1 ;
+	struct net_device *dev = dev_get_by_index (&init_net, ifindex);
+	if (dev) {
+		result = __mpls_get_labelspace (dev);
+		dev_put (dev);
+	}
+	return result;
+}
+
+
+
+
+/**
+ *	mpls_get_labelspace - Get the label space for the interface
+ *	@req: mpls_labelspace_req struct with the query data. In particular,
+ *	     contains the interface index in req->mls_ifindex.
+ *
+ *	Returns 0 on sucess and sets the label space for the netdevice in
+ *	req->mls_ifindex. The labelspace in req->mls_ifindex may be -1 if MPLS
+ *	was not active on the interface.
+ **/
+
+inline int 
+mpls_get_labelspace(struct mpls_labelspace_req *req)
+{
+	return mpls_get_labelspace_by_index (req->mls_ifindex);
+}
+
+
+
+/**
+ *	__mpls_set_labelspace - Set a label space for the interface.
+ *	@dev: device 
+ *	@labelspace: new labelspace
+ *
+ *	See mpls_set_labelspace for comments.
+ *	Returns 0 on success.
+ **/
+
+
+static int 
+__mpls_set_labelspace (struct net_device *dev, int labelspace)
+{
+	struct mpls_interface *mpls_ptr = dev->mpls_ptr;
+
+	MPLS_ENTER;
+	if (!mpls_ptr) {
+		if (labelspace != -1) {
+			mpls_ptr = mpls_create_if_info ();
+			if (unlikely(!mpls_ptr)) {
+				MPLS_DEBUG("Err: Set labelspace for %s to %d\n",
+					dev->name, labelspace);
+				MPLS_EXIT;
+				return -ENOMEM;
+			}
+			/* Actual assignment happens here */
+			mpls_ptr->labelspace = labelspace;
+			dev->mpls_ptr = (void*)mpls_ptr;
+			MPLS_DEBUG("Set labelspace for %s to %d\n",
+				dev->name, labelspace);
+		}
+	} else {
+		if (labelspace == -1) {
+			MPLS_DEBUG("Resetting labelspace for %s to %d\n",
+				dev->name,-1);
+			mpls_delete_if_info (dev->mpls_ptr);
+			dev->mpls_ptr = NULL;
+		} else {
+			mpls_ptr->labelspace = labelspace;
+		}
+			
+	}
+	mpls_labelspace_event(MPLS_CMD_SETLABELSPACE, dev);
+	MPLS_EXIT;
+	return 0;
+}
+
+
+
+
+/**
+ *	mpls_set_labelspace_by_name - Set a label space for the interface.
+ *	@name: name of the interface
+ *	@labelspace: new labelspace
+ *
+ *	See mpls_set_labelspace for comments.
+ *	Returns 0 on success.
+ **/
+
+int 
+mpls_set_labelspace_by_name (const char* name, int labelspace)
+{
+	int result = -1;
+	struct net_device *dev = dev_get_by_name (&init_net, name);
+	if (dev) {
+		result = __mpls_set_labelspace (dev, labelspace);
+		dev_put (dev);
+	}
+	return result;
+}
+
+
+
+
+/**
+ *	mpls_set_labelspace_by_index - Set a label space for the interface.
+ *	@ifindex:  interface index 
+ *	@labelspace: new labelspace
+ *
+ *	See mpls_set_labelspace for comments.
+ *	Returns 0 on success.
+ **/
+
+int 
+mpls_set_labelspace_by_index (int ifindex, int labelspace)
+{
+	int result = -1;
+	struct net_device *dev = dev_get_by_index (&init_net, ifindex);
+	if (dev) {
+		result = __mpls_set_labelspace (dev, labelspace);
+		dev_put (dev);
+	}
+	return result;
+}
+
+
+
+
+/**
+ *	mpls_set_labelspace - Set a label space for the interface.
+ *	@req: mpls_labelspace_req struct with the update data. In particular,
+ *	     contains the interface index in req->mls_ifindex, and the new
+ *	     labelspace in req->mls_labelspace.
+ *
+ *	This function assigns a label space to a particular net device. In
+ *	the current implementation, the netdev struct is extended with a
+ *	mpls_ptr to hold mpls data, which is dynamically allocated here,
+ *	using mpls_create_if_info().
+ *	Returns 0 on success.
+ **/
+
+int 
+mpls_set_labelspace (struct mpls_labelspace_req *req)
+{
+	int result = -1; 
+	struct net_device *dev = dev_get_by_index (&init_net, req->mls_ifindex);
+	if (dev) {
+		result = __mpls_set_labelspace (dev, req->mls_labelspace);
+		dev_put (dev);
+	}
+	return result;
+
+	
+}
diff -Naur linux-kernel-rpm-f8/net/mpls/mpls_ilm.c mpls-kernel-rpm-f8_modified/net/mpls/mpls_ilm.c
--- linux-kernel-rpm-f8/net/mpls/mpls_ilm.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/mpls/mpls_ilm.c	2008-10-17 09:45:01.000000000 +0200
@@ -0,0 +1,929 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *          James Leu        <jleu@mindspring.com>
+ *          Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu        <jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * Changes
+ * 20040117 RCAS
+ *      - Changed RADIX_TREE(mpls_ilm_tree, GFP_ATOMIC) (since it's locked).
+ * 20040115 RCAS
+ *	- Removed old legacy ioctl code.
+ * 20040127 RCAS
+ *	- Dynamic allocation of instructions.
+ ****************************************************************************/
+
+#include <linux/autoconf.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <linux/netdevice.h>	
+#include <linux/in.h>		/* must be before route.h */
+#include <linux/ip.h>		/* must be before route.h */
+#include <linux/inetdevice.h>	/* must be before route.h */
+#include <net/route.h>
+#include <net/mpls.h>
+#include <linux/genetlink.h>
+#include <net/net_namespace.h>
+
+LIST_HEAD(mpls_ilm_list);
+
+/* forward declarations */
+static struct dst_entry *ilm_dst_check(struct dst_entry *dst, u32 cookie);
+static void              ilm_dst_destroy(struct dst_entry *dst);
+static struct dst_entry *ilm_dst_negative_advice(struct dst_entry *dst);
+static void              ilm_dst_link_failure(struct sk_buff *skb);
+static void              ilm_dst_update_pmtu(struct dst_entry *dst, u32 mtu);
+static int               ilm_dst_gc(struct dst_ops *ops);
+
+struct dst_ops ilm_dst_ops = {
+	.family		 =  AF_MPLS,
+	.protocol	 = __constant_htons(ETH_P_MPLS_UC),
+	.gc		 = ilm_dst_gc,
+	.check		 = ilm_dst_check,
+	.destroy	 = ilm_dst_destroy,
+	.negative_advice = ilm_dst_negative_advice,
+	.link_failure	 = ilm_dst_link_failure,
+	.update_pmtu	 = ilm_dst_update_pmtu,
+	.entry_size	 = sizeof(struct mpls_ilm),
+};
+
+static struct dst_entry *
+ilm_dst_check (struct dst_entry *dst, u32 cookie)
+{
+	MPLS_ENTER;
+	dst_release(dst);
+	MPLS_EXIT;
+	return NULL;
+}
+
+/**
+ *      ilm_dst_destroy - cleanup for a MPLS dst_entry
+ *      @dst: 'this', object that is being destroyed.
+ *
+ *      The object ends life here. Perform the necessary
+ *      clean up, but do not call dst_free(..) etc.
+ **/
+
+static void
+ilm_dst_destroy (struct dst_entry *dst)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+}
+
+static struct dst_entry *
+ilm_dst_negative_advice (struct dst_entry *dst)
+{
+	MPLS_ENTER;
+	dst_release(dst);
+	MPLS_EXIT;
+	return NULL;
+}
+
+static void
+ilm_dst_link_failure (struct sk_buff *skb)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+}
+
+static void
+ilm_dst_update_pmtu (struct dst_entry *dst, u32 mtu)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+}
+
+static int
+ilm_dst_gc (struct dst_ops *ops)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+	return 0;
+}
+
+/**
+ *      mpls_ilm_dst_alloc - construct a mpls_ilm entry.
+ *
+ **/
+
+struct mpls_ilm*
+mpls_ilm_dst_alloc(unsigned int key, struct mpls_label *ml,
+	unsigned short family, struct mpls_instr_elem *instr, int instr_len)
+{
+	struct mpls_ilm *ilm;
+	int result;
+
+	MPLS_ENTER;
+
+	ilm = dst_alloc (&ilm_dst_ops);
+	if (unlikely(!ilm))
+		goto ilm_dst_alloc_0;
+
+	memcpy(&(ilm->ilm_label),ml,sizeof(struct mpls_label));
+	INIT_LIST_HEAD(&ilm->dev_entry);
+	INIT_LIST_HEAD(&ilm->nhlfe_entry);
+	INIT_LIST_HEAD(&ilm->global);
+
+	ilm->ilm_instr      = NULL;
+	ilm->ilm_key        = key;
+	ilm->ilm_labelspace = ml->ml_index;
+	ilm->ilm_age        = jiffies;
+	ilm->ilm_proto      = mpls_proto_find_by_family(family);
+	if (unlikely(!ilm->ilm_proto)) {
+		MPLS_DEBUG("Unable to find protocol driver for '0x%04x'\n",
+			family);
+		goto ilm_dst_alloc_1;
+	} else {
+		ilm->u.dst.input = ilm->ilm_proto->local_deliver;
+	}
+	ilm->u.dst.dev	    = init_net.loopback_dev;
+
+	result = mpls_set_in_instrs(instr, instr_len, ilm);
+
+	if (result)
+		goto ilm_dst_alloc_2;
+
+	MPLS_EXIT;
+	return ilm;
+
+/* Error Path */
+ilm_dst_alloc_2:
+	mpls_proto_release(ilm->ilm_proto);
+ilm_dst_alloc_1:
+	ilm->u.dst.obsolete = 1;
+	dst_free(&ilm->u.dst);
+
+ilm_dst_alloc_0:
+	MPLS_EXIT;
+	return NULL;
+}
+
+
+/*
+ * MPLS info radix tree and corresponding lock
+ */
+RADIX_TREE(mpls_ilm_tree, GFP_ATOMIC);
+
+DEFINE_SPINLOCK(mpls_ilm_lock);
+
+/*
+ * Some label values are reserved. 
+ * For incoming label values of "IPv4 EXPLICIT NULL" and "IPv6 EXPLICIT NULL",
+ * the instructions to execute are well defined. 
+ */
+
+/** 
+ * ILM objects associated to reserved labels
+ * RCAS: _IMPORTANT_ reserved labels *ARE NOT* in tree!
+ **/
+
+static struct mpls_reserved_labels {
+	struct mpls_ilm *ilm;  /* Pointer to the ILM object              */ 
+	char *msg;		   /* Description of the Label               */
+	int bos;		   /* 1 -> it MUST be at the bottom of stack */
+} mpls_reserved[16] = {
+	{ NULL,                "IPv4 EXPLICIT NULL", 1 },
+	{ NULL,                "ROUTER ALERT",       0 },
+	{ NULL,                "IPv6 EXPLICIT NULL", 1 },
+	{ NULL,                "IMPLICIT NULL",      1 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 }
+};
+
+/**
+ *	mpls_insert_ilm - Inserts the given ILM object in the MPLS Input 
+ *	Information Radix Tree using the given key.
+ *	@key: key to use 
+ *	@ilm: ilm object. 
+ *	
+ *	Returns 0 on success, or:
+ *		-ENOMEM : unable to allocate node in the radix tree.
+ **/
+
+int 
+mpls_insert_ilm (unsigned int key, struct mpls_ilm *ilm) 
+{
+	int retval = 0;
+
+	mpls_ilm_hold (ilm);
+	retval = radix_tree_insert (&mpls_ilm_tree, key, ilm);
+	if (unlikely(retval)) {
+		MPLS_DEBUG("Error create node with key %u in radix tree\n",key);
+		retval = -ENOMEM;
+	}
+	list_add_rcu(&ilm->global, &mpls_ilm_list);
+	return retval;
+}
+
+/**
+ *	mpls_remove_ilm - Remove the node given the key from the MPLS Input 
+ *	Information Radix Tree.
+ *	@key : key to use 
+ *
+ *	This function deletes the ILM object from the Radix Tree, but please
+ *	also note that the object is not freed, and that the caller is
+ *	responsible for	decreasing the refcount if necessary.
+ *
+ *	Returns the node removed from the tree (which still needs to be
+ *	released) or NULL if no such key/element exists in the tree.
+ *	Caller must hold write lock
+ *
+ **/
+
+struct mpls_ilm* 
+mpls_remove_ilm (unsigned int key)
+{
+	struct mpls_ilm *ilm = NULL;
+
+	MPLS_ENTER;
+	ilm = radix_tree_delete (&mpls_ilm_tree, key);
+	if (!ilm) {
+		MPLS_DEBUG("node key %u not found.\n",key);
+		return NULL;
+	}
+
+	list_del_rcu(&ilm->global);
+	mpls_ilm_release (ilm);
+
+	MPLS_EXIT;
+	return ilm;
+}
+
+/**
+ *	mpls_get_ilm - Get a reference to a ILM object. 
+ *	@key : key to look for in the ILM Radix Tree. 
+ *
+ *	This function can be used to get a reference to a ILM object given a
+ *	key.  *	Returns a pointer to the ILM object, NULL on error. 
+ *
+ *	Remark: this function increases the refcount of the ILM object,
+ *	since it calls to mpls_ilm_hold. Caller is responsible to
+ *	release the object when it is no longer needed (by using
+ *	"mpls_ilm_release").
+ **/
+
+struct mpls_ilm* 
+mpls_get_ilm (unsigned int key) 
+{
+	struct mpls_ilm *ilm = NULL;
+
+	rcu_read_lock();
+	ilm = radix_tree_lookup (&mpls_ilm_tree,key);
+	smp_read_barrier_depends();
+	if (likely(ilm))
+		mpls_ilm_hold(ilm);
+
+	rcu_read_unlock();
+	return ilm;
+}
+
+/**
+ *	mpls_get_ilm_by_label - Get a reference to a ILM given an incoming
+ *	   label/labelspace.
+ *	@label:      Incoming label from network core.
+ *	@labelspace: Labelspace of the incoming interface.
+ *	@bos:        Status of BOS for the current label being processed
+ *
+ *	Allows the caller to get a reference to the ILM object given the
+ *	label value, and incoming interface/labelspace.
+ *	Returns a pointer to the ILM object, NULL on error. 
+ *	Remark1: This function increases the refcount of the ILM object, since 
+ *		it calls "mpls_ilm_hold". Caller must release the object
+ *		when it is no longer needed.
+ *	Remark2: uses the function above.
+ **/
+
+struct mpls_ilm* 
+mpls_get_ilm_by_label (struct mpls_label *label, int labelspace, char bos) 
+{
+	struct mpls_ilm *ilm = NULL;
+
+	/* handle the reserved label range */
+	if (label->ml_type == MPLS_LABEL_GEN && label->u.ml_gen < 16) {
+		int want_bos = mpls_reserved[label->u.ml_gen].bos;
+		MPLS_DEBUG("%s\n",mpls_reserved[label->u.ml_gen].msg);
+		ilm = mpls_reserved[label->u.ml_gen].ilm;
+		if (unlikely(!ilm)) {
+			MPLS_DEBUG("invalid incoming label, dropping\n");
+			return NULL;
+		}
+		mpls_ilm_hold(ilm);
+		if ((want_bos && !bos) || (!want_bos && bos)) {
+			mpls_ilm_release (ilm);
+			MPLS_DEBUG("invalid incoming labelstack, dropping\n");
+			return NULL;
+		}
+	} else {
+		/* not reserved label */
+		ilm = mpls_get_ilm (mpls_label2key(labelspace,label));
+		if (unlikely(!ilm)) {
+			MPLS_DEBUG("unknown incoming label, dropping\n");
+			return NULL;
+		}
+	}
+	return ilm;
+}
+
+/**
+ *	mpls_destroy_in_instrs - Destroy ILM opcodes. 
+ *	@ilm:	ILM object
+ *
+ *	This function completely destroys the instruction list for this 
+ *	ILM object: it unregisters the opcodes from sysfs. When the 
+ *      refcnt of the instr reaches zero (a file may be opened) they 
+ *      will be freed.
+ *
+ *	ilm_instr is set to NULL.
+ **/
+
+void
+mpls_destroy_in_instrs (struct mpls_ilm *ilm) 
+{
+	MPLS_ENTER;
+	mpls_instrs_free (ilm->ilm_instr);
+	ilm->ilm_instr = NULL;
+	MPLS_EXIT;
+}
+
+/**
+ * 	mpls_set_in_instrs - Set Instruction list for this ILM. 
+ *	@mie:   Array of instruction elements set by user 
+ *	@lenth: Array lenght. Number of valid entries
+ *	@ilm:	The ILM object ('this')
+ *
+ *	Return 0 on success. Called in process context only and m
+ *	ay sleep
+ **/
+int
+mpls_set_in_instrs ( struct mpls_instr_elem *mie, int length,
+	struct mpls_ilm *ilm) 
+{
+	/* To store (tmp) the linked list of instr. */
+	struct mpls_instr *instr_list = NULL;
+	
+	/* Build temporary opcode set from mie */
+	if (!mpls_instrs_build(mie, &instr_list, length, MPLS_IN, ilm))
+		return -1;
+
+	/* Commit the new ones */
+	if (ilm->ilm_instr)
+		mpls_instrs_free(ilm->ilm_instr);
+	ilm->ilm_instr = instr_list;
+
+	return 0;
+}
+
+
+
+
+/**
+ *	mpls_set_in_label_instrs - define the incoming opcode set. 
+ *	@mir: request.
+ *
+ *	Updates the ILM object corresponding to the label/labelspace
+ *	in the request, by changing the instrs as given.
+ *
+ *	Returns 0 on success, or
+ *	   -ENXIO
+ *	   -ESRCH
+ *	   -EEXIST
+ *	   -1
+ **/
+
+int 
+mpls_set_in_label_instrs (struct mpls_instr_req *mir) 
+{
+	int labelspace           =  mir->mir_index;
+	struct mpls_label *ml    = &mir->mir_label;
+	unsigned int key         = mpls_label2key (labelspace,ml);
+	struct mpls_ilm *ilm = mpls_get_ilm(key);
+	int ret;
+
+	if (unlikely(!ilm))
+		return -ESRCH;
+
+	ret = mpls_set_in_instrs (mir->mir_instr,mir->mir_instr_length, ilm); 
+	mpls_ilm_release(ilm);
+	return ret;
+}
+
+/**
+ *	mpls_set_in_label_proto - change the proto driver on a ilm
+ *	@mil: request.
+ *
+ *	Updates the ILM object corresponding to the label/labelspace
+ *	in the request, by changing the proto driver as given.
+ *
+ *	Returns 0 on success or no change, or
+ *	   -ESRCH
+ *	   -EINVAL
+ */
+int 
+mpls_set_in_label_proto (struct mpls_in_label_req *mil)
+{
+	unsigned int key = mpls_label2key(mil->mil_label.ml_index,
+		&mil->mil_label);
+	struct mpls_ilm *ilm = mpls_get_ilm(key);
+	int retval = 0;
+	if (!ilm) {
+		retval = -ESRCH;
+		goto err_no_ilm;
+	}
+
+	if (ilm->ilm_proto->family != mil->mil_proto) {
+		struct mpls_prot_driver *prot =
+			mpls_proto_find_by_family(mil->mil_proto);
+		if (!prot) {
+			retval = -EINVAL;
+			goto err_no_prot;
+		}
+		if (ilm->ilm_proto)
+			mpls_proto_release(ilm->ilm_proto);
+		ilm->ilm_proto = prot;
+		ilm->u.dst.input = prot->local_deliver;
+	}
+
+err_no_prot:
+	mpls_ilm_release (ilm);
+err_no_ilm:
+	return retval;
+}
+
+/**
+ *	mpls_is_reserved_label - return 1 if label is reserved.
+ *	@label - label to check.
+ **/
+
+static inline int 
+mpls_is_reserved_label (const struct mpls_label *label)
+{
+	BUG_ON(!label);
+	if (unlikely((label->ml_type == MPLS_LABEL_GEN) &&
+		     (label->u.ml_gen > MPLS_IPV6_EXPLICIT_NULL) &&
+		     (label->u.ml_gen < 16))) {
+		return 1;
+	}
+	return 0;
+}
+
+
+
+
+/**
+ *	mpls_add_in_label - Add a label to the incoming tree.
+ *	@in : mpls_in_label_req
+ *
+ *	Process context entry point to add an entry (ILM) in the incoming label 
+ *	map database. It adds new corresponding node to the Incoming Radix Tree.
+ *	It sets the ILM object reference count to 1, the ilm age to jiffies, the
+ *	protocol to IPv4, the default instruction set (POP,PEEK) and initializes
+ *	both the dev_entry and nhlfe_entry lists. The node's key is set to the 
+ *	mapped	key from the label/labelspace in the request.
+ *
+ *	Returns 0 on success, or else.
+ *
+ *	Changes 
+ *	20031125 : RCAS 
+ *		o Verify that no node exists for the tree before alloc'ing 
+ *		  the ILM, so we can get out earlier in case we fail.
+ *	20041020 : JLEU
+ *		o Removed mpls_set_default_in_instrs()
+ **/
+
+int 
+mpls_add_in_label (const struct mpls_in_label_req *in) 
+{
+	struct mpls_ilm *ilm     = NULL; /* New ILM to insert */
+	struct mpls_label *ml    = NULL; /* Requested Label */
+	unsigned int key         = 0;    /* Key to use */
+	int retval               = 0;
+	struct mpls_instr_elem instr[2];
+
+	MPLS_ENTER;
+
+	BUG_ON(!in);
+	ml = (struct mpls_label *)&in->mil_label;
+
+	if (mpls_is_reserved_label(ml)) {
+		MPLS_DEBUG("Unable to add reserved label to ILM\n");
+		retval = -EINVAL;
+		goto error;
+	}
+
+	/* Obtain key */
+	key = mpls_label2key(/* labelspace*/ ml->ml_index, ml);
+
+	/* Check if the node already exists */ 
+	ilm = mpls_get_ilm(key);
+	if (unlikely(ilm)) {
+		printk (MPLS_ERR "MPLS: node %u already exists\n",key);
+		mpls_ilm_release(ilm);  
+		retval = -EEXIST;
+		goto error;
+	} 
+
+	/*
+	 * Allocate a new input Information/Label,
+	 */
+
+	instr[0].mir_direction = MPLS_IN;
+	instr[0].mir_opcode    = MPLS_OP_POP;
+	instr[1].mir_direction = MPLS_IN;
+	instr[1].mir_opcode    = MPLS_OP_PEEK;
+
+	ilm = mpls_ilm_dst_alloc (key, ml, in->mil_proto, instr, 2);
+	if (unlikely(!ilm)) {
+		retval = -ENOMEM;
+		goto error;
+	}
+
+	/* Insert into ILM tree */
+	spin_lock_bh (&mpls_ilm_lock);
+	if (unlikely(mpls_insert_ilm(key,ilm))) {
+		mpls_ilm_release (ilm);
+		spin_unlock_bh (&mpls_ilm_lock);
+
+		ilm->u.dst.obsolete = 1;
+		dst_free (&ilm->u.dst);
+		retval = -ENOMEM;
+		goto error;
+	}
+
+	mpls_ilm_hold(ilm);
+	spin_unlock_bh (&mpls_ilm_lock);
+
+	/* we have hold a refcnt to the ilm across mpls_ilm_event()
+	 * to make sure it can't disappear
+	 */
+	mpls_ilm_event(MPLS_CMD_NEWILM, ilm);
+	mpls_ilm_release(ilm);
+
+error:
+	MPLS_EXIT;
+	return retval;
+}
+
+/**
+ *	__mpls_del_in_label - send delete event and schedule ILM for freeing
+ *	@in : mpls_ilm
+ *
+ *	This function does the work of actually 'free'ing a ILM datastructure.
+ *	It first send a event notifing userland that the ILM is going a way,
+ *	then delete the instructions removed reference to the proto driver,
+ *	then finally schedules the ILM for freeing.
+ *
+ *	This functions much be called holding a reference to the ILM,
+ *	At this point it is the ONLY reference to the ILM (it should have
+ *	been removed from the tree or the array) When this functions exits
+ *	ilm is nolonger valid ...
+ **/
+void __mpls_del_in_label(struct mpls_ilm *ilm) {
+	/* we're still holding a ref to the ilm, so it is safe to
+	 * call mpls_ilm_event
+	 */
+	mpls_ilm_event(MPLS_CMD_DELILM, ilm);
+
+	/* remove the instructions from the ILM, so ass to release
+	 * our references to NHLFEs
+	 */
+	mpls_destroy_in_instrs (ilm);
+        mpls_proto_release(ilm->ilm_proto);
+	ilm->ilm_proto = NULL;
+
+	/* release the refcnt we aquired in mpls_get_ilm() */
+	mpls_ilm_release (ilm);
+
+	/* tell the dst system this one is ready for removal */
+	ilm->u.dst.obsolete = 1;
+	call_rcu(&ilm->u.dst.rcu_head, dst_rcu_free);
+}
+
+/**
+ *	mpls_del_in_label - Del a label from the incoming tree (ILM)
+ *	@in : mpls_in_label_req
+ *
+ *	User context entry point, this function removes an incoming label
+ *	from the incoming radix tree (that is, from the ILM). It constructs
+ *	the associated key from the label/labelspace in the request, and 
+ *	updates the passed struct with the ILM information. 
+ **/
+
+int 
+mpls_del_in_label(struct mpls_in_label_req *in) 
+{
+	struct mpls_ilm *ilm = NULL;
+	struct mpls_label   *ml  = NULL; 
+	unsigned int key         = 0;
+
+	MPLS_ENTER;
+	BUG_ON(!in);
+	ml  = &in->mil_label;
+	key = mpls_label2key(/* labelspace*/ ml->ml_index, ml);
+
+	ilm = mpls_get_ilm(key);
+	if (unlikely(!ilm)) {
+		MPLS_DEBUG("Node %u was not in tree\n",key);
+		MPLS_EXIT;
+		return  -ESRCH;
+	}
+
+	spin_lock_bh (&mpls_ilm_lock);
+
+	if (atomic_read(&ilm->u.dst.__refcnt) != 2) {
+		/* someone else is hold a refcnt, we can't delete */
+
+		/* release the refcnt we aquired in mpls_get_ilm() */
+		mpls_ilm_release (ilm);
+		spin_unlock_bh (&mpls_ilm_lock);
+
+		MPLS_DEBUG("Node %u is being used\n",key);
+		MPLS_EXIT;
+		return -EBUSY;
+        }
+
+	/*
+	 * Remove a ILM from the tree
+	 */
+	ilm = mpls_remove_ilm(key);
+
+	spin_unlock_bh (&mpls_ilm_lock);
+
+	if (unlikely(!ilm)) {
+		MPLS_DEBUG("Node %u was not in tree\n",key);
+		MPLS_EXIT;
+		return  -ESRCH;
+	}
+
+	__mpls_del_in_label(ilm);
+
+	MPLS_EXIT;
+	return 0; 
+}
+
+/**
+ *	mpls_attach_in2out - Establish a xconnect between a ILM and a NHLFE.
+ *	@req : crossconnect request. 
+ *
+ *	Establishes a "cross-connect", a forwarding entry. The incoming label
+ *	is swapped to the outgoing one. Given the incoming label and label
+ *	space 
+ *
+ *	(req), this function updates the ILM object so we change the last instr 
+ *	from DLV/PEEK to FWD, whose opcode data is a held ref. to the new NHLFE 
+ *	(as given by the key in req).
+ *	Returns 0 on success. Process context only.
+ *
+ *	Remarks:
+ *	    o Be careful when  detroying the NHLFE  object (you should dettach
+ *	      the xconnect in order to release the NHLFE)
+ *
+ *	Changes:
+ *	o 20040120 RCAS: Removed kfree((unsigned short*)mi->mi_data);
+ *	               for DLV (data in DLV opcode is NULL).
+ *	o 20040127 RCAS: Instruction Linked list.	
+ **/
+
+int 
+mpls_attach_in2out(struct mpls_xconnect_req *req) 
+{
+	struct mpls_instr       *mi  = NULL; 
+	struct mpls_nhlfe    *nhlfe = NULL;
+	struct mpls_ilm     *ilm = NULL;
+	unsigned short op = 0;
+	int  labelspace, key;
+
+	MPLS_ENTER;
+	labelspace = req->mx_in.ml_index;
+
+	/* Hold a ref to the ILM */
+	key = mpls_label2key(labelspace,&(req->mx_in));
+	ilm = mpls_get_ilm(key);
+	if (unlikely(!ilm))  {
+		MPLS_DEBUG("Node %u does not exist in radix tree\n",key);
+		MPLS_EXIT;
+		return -ESRCH;
+	}
+
+	/* Hold a ref to the NHLFE */
+	key = mpls_label2key(0,&(req->mx_out));
+	nhlfe = mpls_get_nhlfe(key);
+	if (unlikely(!nhlfe)) {
+		MPLS_DEBUG("Node %u does not exist in radix tree\n",key);
+		mpls_ilm_release(ilm);
+		MPLS_EXIT;
+		return -ESRCH;
+	}
+
+	if (unlikely(!ilm->ilm_instr)) {
+		MPLS_DEBUG("No instruction Set!")
+		mpls_ilm_release(ilm);
+		mpls_nhlfe_release(nhlfe);
+		MPLS_EXIT;
+		return -ESRCH;
+	}
+
+
+
+	/*
+	 * Update the instructions: now, instead of "DLV"/"PEEK", now
+	 * we "FWD". The NHLFE is not released (is held by the opcode). 
+	 */
+
+	/* Lookup the last instr */
+	for (mi = ilm->ilm_instr; mi->mi_next;mi = mi->mi_next); /* nop*/
+
+	op = mi->mi_opcode;
+
+	switch (op) {
+		case MPLS_OP_DLV:
+			mi->mi_opcode = MPLS_OP_FWD;
+			mi->mi_data   = (void*)nhlfe;
+			break;
+		case MPLS_OP_FWD:
+			mpls_xc_event(MPLS_CMD_DELXC, ilm,
+				_mpls_as_nhlfe(mi->mi_data));
+			mpls_nhlfe_release(_mpls_as_nhlfe(mi->mi_data));
+			mi->mi_data   = (void*)nhlfe;
+			break;
+		case MPLS_OP_PEEK:
+			mi->mi_opcode = MPLS_OP_FWD;
+			mi->mi_data   = (void*)nhlfe;
+			break;
+	}
+	mpls_xc_event(MPLS_CMD_NEWXC, ilm, nhlfe);
+	mpls_ilm_release(ilm);
+	return 0; 
+}
+
+
+
+
+/**
+ *	mpls_dettach_in2out - Dettach a xconnect between a ILM and a NHLFE.
+ *	@req : crossconnect request. 
+ *
+ *	Dettaches a "cross-connect", a forwarding entry. Checks if the latest 
+ *	instruction is a FWD and updates it to a PEEK. Releases the
+ *	corresponding NHLFE (cf. mpls_attach_in2out).
+ *
+ *	Returns 0 on success. Process context only.
+ **/
+
+int 
+mpls_detach_in2out(struct mpls_xconnect_req *req) 
+{
+	struct mpls_instr       *mi  = NULL;
+	struct mpls_nhlfe    *nhlfe = NULL;
+	struct mpls_ilm     *ilm = NULL;
+	unsigned int     key = 0;
+	int labelspace;
+	int ret = 0;
+
+	MPLS_ENTER;
+	BUG_ON(!req);
+
+	/* Hold a ref to the ILM, The 'in' segment */ 
+	labelspace = req->mx_in.ml_index;
+	key        = mpls_label2key(labelspace,&(req->mx_in));
+	ilm = mpls_get_ilm(key);
+	if (unlikely(!ilm)) {
+		MPLS_DEBUG("Node %u does not exist in radix tree\n",key);
+		ret = -ESRCH;
+		goto err_no_ilm;
+	}
+
+	/* Check that there is an instruction set! */
+	if (unlikely(!ilm->ilm_instr)) {
+		MPLS_DEBUG("No instruction Set!")
+		ret = -ESRCH;
+		goto err_no_ilm_instr;
+	}
+
+
+	/* Fetch the last instr, make sure it is FWD*/
+	for (mi = ilm->ilm_instr; mi->mi_next;mi = mi->mi_next); /* nop*/
+
+	if (!mi   ||   mi->mi_opcode != MPLS_OP_FWD) {
+		MPLS_DEBUG("opcode not found!\n");
+		ret = -ENXIO;
+		goto err_no_fwd;
+	}
+
+	/* Get the current held nhlfe for the last in instr */
+	nhlfe = mi->mi_data;
+	key = mpls_label2key(0,&(req->mx_out));
+
+	/* Make sure it is the good nhlfe */
+	if (!nhlfe ||  key != nhlfe->nhlfe_key) {
+		/* Do not release the NHLFE, it was invalid */ 
+		MPLS_DEBUG("Invalid NHLFE  %u\n",key);
+		ret = -ENXIO;
+		goto err_no_nhlfe;
+	}
+
+	/* The new last opcode for this ILM is now peek */
+	mi->mi_opcode = MPLS_OP_PEEK;
+	/* With no data */
+	mi->mi_data   = NULL; 
+
+	/* Release the NHLFE held by the Opcode (cf. mpls_attach_in2out) */
+
+	mpls_xc_event(MPLS_CMD_DELXC, ilm, nhlfe);
+	mpls_nhlfe_release(nhlfe); 
+	ret = 0;
+err_no_nhlfe:
+err_no_fwd:
+	/* Release the ILM after use */
+	mpls_ilm_release(ilm);
+err_no_ilm_instr:
+err_no_ilm:
+	MPLS_EXIT;
+	return ret;
+}
+
+/**
+ * 	mpls_init_reserved_label - Add an ILM object for a reserved label
+ *	@label - reserved generic label value
+ *	@ilm - ILM object to used for reserved label
+ *
+ *	Returns 0 on success
+ **/
+
+int 
+mpls_add_reserved_label (int label, struct mpls_ilm* ilm)
+{
+	BUG_ON(label < 0 || label > 15);
+
+	if (mpls_reserved[label].ilm)
+		return -EEXIST;
+
+	mpls_ilm_hold(ilm);
+	mpls_reserved[label].ilm = ilm;
+
+	return 0;
+}
+
+/**
+ * 	mpls_del_reserved_label - remove the ILM object for a reserved label
+ *	@label - reserved generic label value
+ *
+ *	Return the ILM object for the user to release
+ *
+ **/
+
+struct mpls_ilm*
+mpls_del_reserved_label (int label)
+{
+	struct mpls_ilm* ilm;
+	BUG_ON(label < 0 || label > 15);
+
+	ilm = mpls_reserved[label].ilm;
+	mpls_reserved[label].ilm = NULL;
+	return ilm;
+}
+
+int __init mpls_ilm_init(void)
+{
+	ilm_dst_ops.kmem_cachep = kmem_cache_create("ilm_dst_cache",
+		sizeof(struct mpls_ilm), 0, SLAB_HWCACHE_ALIGN, NULL);
+                                                                                
+	if (!ilm_dst_ops.kmem_cachep) {
+		printk(MPLS_ERR "MPLS: failed to alloc ilm_dst_cache\n");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+void __exit mpls_ilm_exit(void)
+{
+	if (ilm_dst_ops.kmem_cachep)
+	    kmem_cache_destroy(ilm_dst_ops.kmem_cachep);
+	return;
+}
+
+EXPORT_SYMBOL(__mpls_del_in_label);
+EXPORT_SYMBOL(mpls_ilm_dst_alloc);
+EXPORT_SYMBOL(mpls_add_reserved_label);
+EXPORT_SYMBOL(mpls_del_reserved_label);
diff -Naur linux-kernel-rpm-f8/net/mpls/mpls_init.c mpls-kernel-rpm-f8_modified/net/mpls/mpls_init.c
--- linux-kernel-rpm-f8/net/mpls/mpls_init.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/mpls/mpls_init.c	2008-10-17 09:45:01.000000000 +0200
@@ -0,0 +1,287 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *          James Leu        <jleu@mindspring.com>
+ *          Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu        <jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * Changes:
+ * 20031126 RCAS 
+ *      - Split netdev_event callback. 
+ * 20040116 RCAS 
+ *      - Error Checking in init function 
+ * 20040127 RCAS 
+ *      - If a down interface was referenced by a ILM/NHLFE, destroy ILM/NHLFE
+ *	instructions if interface goes down/unregged.
+ * 20050829 JLEU
+ *	- move to shim interface
+ * 20051206 JLEU
+ *	- move shim code to seperate file
+ ****************************************************************************/
+
+#include <linux/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <net/dst.h>
+#include <net/mpls.h>
+
+/**
+ * MODULE Information and attributes
+ *
+ **/
+
+MODULE_AUTHOR("James R. Leu <jleu@mindspring.com>, Ramon Casellas <casellas@infres.enst.fr>");
+MODULE_DESCRIPTION("MultiProtocol Label Switching protocol");
+MODULE_LICENSE("GPL");
+#if 0
+MODULE_ALIAS_NETPROTO(PF_MPLS);
+#endif
+
+/*****
+ * Packet Type for MPLS Unicast Traffic register info.
+ *
+ **/
+
+static struct packet_type mpls_uc_packet_type = {
+	.type = __constant_htons(ETH_P_MPLS_UC), /* MPLS Unicast PID */
+	.dev  = NULL,                            /* All devices */
+	.func = mpls_skb_recv,
+};
+
+/*****
+ * Packet Type for MPLS Multicast Traffic register info.
+ *
+ **/
+
+static struct packet_type mpls_mc_packet_type = {
+	.type = __constant_htons(ETH_P_MPLS_MC),
+	.dev  = NULL,
+	.func = mpls_skb_recv_mc, /* MPLS multicast receive method */
+};
+
+/**
+ *	mpls_release_netdev_in_nhlfe - Release the held device if it goes down.
+ *	@dev: network device (for which the notification is sent).
+ *
+ *	NHLFE objects hold a reference to the used outgoing device in the SET op
+ *	data. When the MPLS subsystem is notified that a device is going down
+ *	or unregistered, this function destroys the instructions for those NHLFE
+ **/
+
+static int 
+mpls_release_netdev_in_nhlfe (struct net_device *dev)
+{
+	struct mpls_interface   *mif    = NULL;
+	struct mpls_nhlfe    *holder = NULL;
+	struct list_head        *pos    = NULL;
+	struct list_head        *tmp    = NULL;
+
+	mif = dev->mpls_ptr;
+	
+	/* Iterate all NHLFE objects present in the list_out of the interface.*/
+	list_for_each_safe(pos,tmp,&mif->list_out) {
+
+		/* Get the holder / owner NHLFE */ 
+		holder = list_entry(pos,struct mpls_nhlfe ,dev_entry);
+
+		/* Destroy the instruction list */
+		mpls_destroy_out_instrs(holder);
+
+	}
+	return NOTIFY_DONE;
+}
+
+
+
+/**
+ *	mpls_release_netdev_in_ilm - Release the held device if it goes down.
+ *	@dev: network device (for which the notification is sent).
+ *
+ *	ILM objects hold a reference to the 'faked' incoming device (SET_RX op)
+ *	data. When the MPLS subsystem is notified that a device is going down
+ *	or unregistered, this function destroys the instructions for those ILM 
+ **/
+
+static int 
+mpls_release_netdev_in_ilm (struct net_device *dev)
+{
+	struct mpls_interface   *mif    = NULL;
+	struct mpls_ilm         *holder = NULL;
+	struct list_head        *pos    = NULL;
+	struct list_head        *tmp    = NULL;
+
+	mif = dev->mpls_ptr;
+
+	/* Iterate all NHLFE objects present in the list_out of the interface.*/
+	list_for_each_safe(pos,tmp,&mif->list_in) {
+		holder = list_entry(pos, struct mpls_ilm,dev_entry);
+
+		/* Destroy the instruction list */
+		mpls_destroy_in_instrs(holder);
+
+	}
+	return NOTIFY_DONE;
+}
+
+
+
+/**
+ *	mpls_netdev_event - Netdevice notifier callback.
+ *	@this: block notifier used.
+ *	@event:  UP/DOWN, REGISTER/UNREGISTER... 
+ *	@ptr: (struct net_device*)
+ *	Receives events for the interfaces
+ *
+ *	RCAS 20031126: 
+ *		o Split
+ **/
+
+static int 
+mpls_netdev_event (struct notifier_block *this, unsigned long event, void *ptr)
+{
+	struct net_device *dev = ptr;
+	struct mpls_interface *mif = dev->mpls_ptr;
+
+	/*
+	 * Only continue for MPLS enabled interfaces 
+	 */
+	if (!mif) 
+		return NOTIFY_DONE;
+
+	switch (event) {
+		case NETDEV_UNREGISTER:
+			mpls_release_netdev_in_nhlfe(dev);
+			mpls_release_netdev_in_ilm(dev);
+			break;
+		case NETDEV_DOWN:
+		case NETDEV_CHANGEMTU:
+		case NETDEV_UP:
+		case NETDEV_CHANGE:
+			break;
+	}
+	return NOTIFY_DONE;
+}
+
+/** 
+ * Netdevice notifier callback register info
+ *
+ **/
+static struct notifier_block mpls_netdev_notifier = {
+	.notifier_call =  mpls_netdev_event,
+};
+
+
+
+/**
+ * MPLS Module entry point.
+ *
+ *
+ **/
+
+static int __init 
+mpls_init_module (void) 
+{
+	int err;
+	printk(MPLS_INF "MPLS: version %d.%d%d%d\n",
+			(MPLS_LINUX_VERSION >> 24) & 0xFF,
+			(MPLS_LINUX_VERSION >> 16) & 0xFF,
+			(MPLS_LINUX_VERSION >> 8) & 0xFF,
+			(MPLS_LINUX_VERSION) & 0xFF);
+
+	/* Init Input Radix Tree */
+	if ((err = mpls_ilm_init()))
+		return err;
+	/* Init Output Radix Tree */
+	if ((err = mpls_nhlfe_init()))
+		return err;
+	/* Init MPLS Destination Cache Management */
+	if ((err = mpls_dst_init()))
+		return err;
+#ifdef CONFIG_PROC_FS
+	/* MPLS ProcFS Subsystem */
+	if ((err = mpls_procfs_init()))
+		return err;
+#endif
+#ifdef CONFIG_SYSCTL
+	if ((err = mpls_sysctl_init()))
+		return err;
+#endif
+	/* Netlink configuration interface */
+	if ((err = mpls_netlink_init()))
+		return err;
+
+	/* register shim protocol */
+	mpls_shim_init();
+
+	/* Layer 3 protocol driver initialization */
+	mpls_proto_init();
+
+	/* packet handlers, and netdev notifier */
+	dev_add_pack(&mpls_uc_packet_type);
+	dev_add_pack(&mpls_mc_packet_type);
+	register_netdevice_notifier(&mpls_netdev_notifier);
+
+	return 0;
+}
+
+/**
+ *	mpls_exit_module - Module Exit Cleanup Routine
+ *
+ *	mpls_exit_module is called just before the module is removed
+ *	from memory.
+ **/
+
+static void __exit 
+mpls_exit_module (void)
+{
+	unregister_netdevice_notifier(&mpls_netdev_notifier);
+	dev_remove_pack(&mpls_mc_packet_type);
+	dev_remove_pack(&mpls_uc_packet_type);
+	mpls_shim_exit();
+	mpls_proto_exit();
+	mpls_netlink_exit();
+#ifdef CONFIG_SYSCTL
+	mpls_sysctl_exit();
+#endif
+#ifdef CONFIG_PROC_FS
+	mpls_procfs_exit();
+#endif
+	mpls_dst_exit();
+	mpls_nhlfe_exit();
+	mpls_ilm_exit();
+
+	synchronize_net();
+
+	printk("MPLS: version %d.%d%d%d exiting\n",
+		(MPLS_LINUX_VERSION >> 24) & 0xFF,
+		(MPLS_LINUX_VERSION >> 16) & 0xFF,
+		(MPLS_LINUX_VERSION >> 8) & 0xFF,
+		(MPLS_LINUX_VERSION & 0xFF));
+}
+
+/**
+ *
+ * variables controled via sysctl
+ *
+ **/
+int sysctl_mpls_debug = 0;
+int sysctl_mpls_default_ttl = 255;
+
+module_init(mpls_init_module);
+module_exit(mpls_exit_module);
+
+EXPORT_SYMBOL(sysctl_mpls_debug);
+EXPORT_SYMBOL(sysctl_mpls_default_ttl);
diff -Naur linux-kernel-rpm-f8/net/mpls/mpls_input.c mpls-kernel-rpm-f8_modified/net/mpls/mpls_input.c
--- linux-kernel-rpm-f8/net/mpls/mpls_input.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/mpls/mpls_input.c	2008-10-17 09:45:01.000000000 +0200
@@ -0,0 +1,307 @@
+/*****************************************************************************
+ *	MPLS
+ *	     An implementation of the MPLS (MultiProtocol Label
+ *	     Switching Architecture) for Linux.
+ *
+ *	Authors:
+ *	         James Leu        <jleu@mindspring.com>
+ *	         Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *	  (c) 1999-2004   James Leu        <jleu@mindspring.com>
+ *	  (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *	     This program is free software; you can redistribute it and/or
+ *	     modify it under the terms of the GNU General Public License
+ *	     as published by the Free Software Foundation; either version
+ *	     2 of the License, or (at your option) any later version.
+ ****************************************************************************/
+
+#include <linux/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/if_ether.h>
+#include <linux/if_vlan.h>
+#include <linux/if_arp.h>
+#include <linux/kobject.h>
+#include <net/ip.h>
+#include <net/icmp.h>
+#ifdef CONFIG_IPV6
+#include <net/ipv6.h>
+#endif
+#include <net/mpls.h>
+
+
+/**
+ *	mpls_input - Begin labelled packet processing.
+ *	@skb:        socket buffer, containing the good stuff.
+ *	@dev:        device that receives the packet.
+ *	@pt:         packet type (handler) structure.
+ *	@label:      label value + metadata (type)
+ *	@labelspace: incoming labelspace.
+ **/
+
+static int 
+mpls_input (struct sk_buff        *skb, struct net_device *dev,
+            struct packet_type    *pt, struct mpls_label *label,
+	    int labelspace) 
+{
+	MPLS_IN_OPCODE_PROTOTYPE(*func);   /* Function Pointer for Opcodes */
+	struct mpls_prot_driver *prot = NULL;
+	struct mpls_nhlfe *nhlfe = NULL;  /* Current NHLFE                  */
+	struct mpls_ilm  *ilm = NULL;  /* Current ILM                  */
+	struct mpls_instr    *mi  = NULL;
+	void *data = NULL;                 /* current data for opcode      */
+	int  opcode = 0;                   /* Current opcode to execute    */
+	char *msg = NULL;                  /* Human readable desc. opcode  */
+	int retval;
+
+	MPLS_ENTER;
+
+mpls_input_start:
+
+	if (ilm) {
+		/* we only hit this case when we have a recursive label
+		 * lookup.  drop the previous protocol driver, and ilm
+		 */
+		mpls_proto_release(MPLSCB(skb)->prot);
+		mpls_ilm_release(ilm);
+	}
+
+	MPLS_DEBUG("labelspace=%d,label=%d,exp=%01x,B.O.S=%d,TTL=%d\n",
+		labelspace, MPLSCB(skb)->label, MPLSCB(skb)->exp,
+		MPLSCB(skb)->bos, MPLSCB(skb)->ttl);
+
+	/* GET a reference to the ilm given this label value/labelspace*/
+	ilm = mpls_get_ilm_by_label (label, labelspace, MPLSCB(skb)->bos);
+	if (unlikely(!ilm)) {
+		MPLS_DEBUG("unknown incoming label, dropping\n");
+		goto mpls_input_drop;
+	}
+
+	mpls_proto_hold(ilm->ilm_proto);
+	MPLSCB(skb)->prot = ilm->ilm_proto;
+
+	ilm->ilm_stats.packets++;
+	ilm->ilm_stats.bytes += skb->len;
+
+	/* Iterate all the opcodes for this ILM */
+	for (mi = ilm->ilm_instr; mi; mi = mi->mi_next) {
+		data   = mi->mi_data;
+		opcode = mi->mi_opcode;
+		msg    = mpls_ops[opcode].msg;
+		func   = mpls_ops[opcode].in;
+
+		MPLS_DEBUG("opcode %s\n",msg);
+		if (!func) {
+			MPLS_DEBUG("invalid opcode for input: %s\n",msg);
+			goto mpls_input_drop;
+		}
+
+		switch (func(&skb,ilm,&nhlfe,data)) {
+			case MPLS_RESULT_RECURSE:
+				label->ml_type = MPLS_LABEL_GEN;
+				label->u.ml_gen = MPLSCB(skb)->label;
+				goto mpls_input_start;
+			case MPLS_RESULT_DLV:
+				goto mpls_input_dlv;
+			case MPLS_RESULT_FWD:
+				goto mpls_input_fwd;
+			case MPLS_RESULT_DROP:
+				mpls_proto_release(MPLSCB(skb)->prot);
+				goto mpls_input_drop;
+			case MPLS_RESULT_SUCCESS:
+				break;
+		}
+	}
+	MPLS_DEBUG("finished executing in label program without DLV or FWD\n");
+	mpls_proto_release(MPLSCB(skb)->prot);
+
+	/* fall through to drop */
+
+mpls_input_drop:
+
+	/* proto driver isn't held yet, no need to release it */
+	if (ilm) {
+		ilm->ilm_drops++;
+		mpls_ilm_release(ilm);
+	}
+	MPLS_DEBUG("dropped\n");
+	return NET_RX_DROP;
+
+mpls_input_dlv:
+
+	dst_hold(&ilm->u.dst);
+	skb->dst = &ilm->u.dst;
+
+	mpls_ilm_release(ilm);
+
+	/* about to mangle the skb copy it */
+	if (skb_cow(skb, skb_headroom(skb))) {
+		MPLS_DEBUG("unable to copy skb\n");
+		return NET_RX_DROP;
+	}
+
+#ifdef WE_NEED_TO_PRESENT_HH_HEADER_TO_LAYER_3
+	mpls_finish(skb);
+#endif
+
+	/* ala Cisco, take the lesser of the TTLs
+	 * -if propogate TTL was done at the ingress LER, then the
+	 *  shim TTL will be less the the header TTL
+	 * -if no propogate TTL was done as the ingress LER, a
+	 *  default TTL was placed in the shim, which makes the
+	 *  entire length of the LSP look like one hop to traceroute.
+	 *  As long as the default value placed in the shim is
+	 *  significantly larger then the TTL in the header, then
+	 *  traceroute will work fine.  If not, then traceroute
+	 *  will continualy show the egress of the LSP as the
+	 *  next hop in the path.
+	 */
+	
+	if (MPLSCB(skb)->ttl < MPLSCB(skb)->prot->get_ttl(skb)) {
+		MPLSCB(skb)->prot->set_ttl(skb, MPLSCB(skb)->ttl);
+	}
+
+	/* we're done with the PDU, it now goes to another layer for handling
+	 * it is safe to release the protocol driver now
+	 */
+	mpls_proto_release(MPLSCB(skb)->prot);
+
+	MPLS_DEBUG("delivering\n");
+
+	return 0;
+
+mpls_input_fwd:
+
+	mpls_ilm_release (ilm);
+
+	if (MPLSCB(skb)->ttl <= 1) {
+		printk("TTL exceeded\n");
+
+		prot = MPLSCB(skb)->prot;
+		retval = prot->ttl_expired(&skb);
+		mpls_proto_release(prot);
+
+		if (retval)
+			return retval;
+
+		/* otherwise prot->ttl_expired() must have modified the
+		 * skb and want it to be forwarded down the LSP
+		 */
+	}
+	
+	(MPLSCB(skb)->ttl)--;
+
+	dst_hold(&nhlfe->u.dst);
+	skb->dst = &nhlfe->u.dst;
+
+	/* mpls_switch() does a mpls_proto_release() */
+
+	MPLS_DEBUG("switching\n");
+
+	return 0;
+}
+
+
+
+
+/**
+ *	mpls_skb_recv - Main MPLS packet receive function.
+ *	@skb : socket buffer, containing the good stuff.
+ *	@dev : device that receives the packet.
+ *	@pt  : packet type handler.
+ **/
+
+int 
+mpls_skb_recv (
+	struct sk_buff     *skb, 
+	struct net_device  *dev,
+	struct packet_type *pt,
+	struct net_device  *orig)
+{
+	int labelspace;
+	int result = NET_RX_DROP;
+	struct mpls_label label;
+	struct mpls_interface *mip = dev->mpls_ptr;
+
+	MPLS_ENTER;
+	MPLS_DEBUG_CALL(mpls_skb_dump(skb));
+
+	if (skb->pkt_type == PACKET_OTHERHOST)
+		goto mpls_rcv_drop;
+
+	if (!(skb = skb_share_check (skb, GFP_ATOMIC)))
+		goto mpls_rcv_out;
+
+	if (!pskb_may_pull (skb, sizeof(u32)))
+		goto mpls_rcv_err;
+
+	labelspace = mip ? mip->labelspace : -1;
+	if (unlikely(labelspace < 0)) {
+		MPLS_DEBUG("unicast packet recv on if. w/o labelspace (%s) - packet dropped\n",dev->name);
+		goto mpls_rcv_drop;
+	}
+
+	memset(MPLSCB(skb), 0, sizeof(*MPLSCB(skb)));
+	memset(&label, 0, sizeof(label));
+	MPLSCB(skb)->top_of_stack = skb->data;
+
+	mpls_opcode_peek (skb);
+
+	/* we need the label struct for when we support ATM and FR */
+	switch(dev->type) {
+		case ARPHRD_ETHER:
+		case ARPHRD_FDDI:
+		case ARPHRD_IEEE802:
+		case ARPHRD_PPP:
+		case ARPHRD_LOOPBACK:
+		case ARPHRD_HDLC:
+		case ARPHRD_IPGRE:
+			label.ml_type  = MPLS_LABEL_GEN;
+			label.u.ml_gen = MPLSCB(skb)->label;
+			break;
+		default:
+			printk("Unknown IfType(%08x) for MPLS\n",dev->type);
+			goto mpls_rcv_err;
+	}
+
+	if (mpls_input (skb,dev,pt,&label,labelspace))
+		goto mpls_rcv_drop;
+
+	result = dst_input(skb);
+
+	MPLS_DEBUG("exit(%d)\n",result);
+	return result;
+
+mpls_rcv_err:
+	/* increment some err counter */
+mpls_rcv_drop:
+	kfree_skb (skb);
+mpls_rcv_out:
+	MPLS_DEBUG("exit(DROP)\n");
+	return NET_RX_DROP;
+}
+
+
+
+
+
+/**
+ *	mpls_skb_recv_mc - Main Multicast MPLS packet receive function.
+ *	@skb : socket buffer, containing the good stuff.
+ *	@dev : device that receives the packet.
+ *	@pt  : packet handler. (MPLS UC)
+ **/
+
+int mpls_skb_recv_mc (
+	struct sk_buff     *skb,
+	struct net_device  *dev,
+	struct packet_type *pt,
+	struct net_device  *orig)
+{
+	kfree_skb(skb);
+	MPLS_DEBUG("Not implemented\n");
+	return NET_RX_DROP;
+}
diff -Naur linux-kernel-rpm-f8/net/mpls/mpls_instr.c mpls-kernel-rpm-f8_modified/net/mpls/mpls_instr.c
--- linux-kernel-rpm-f8/net/mpls/mpls_instr.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/mpls/mpls_instr.c	2008-10-17 09:45:01.000000000 +0200
@@ -0,0 +1,207 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *	  James Leu	<jleu@mindspring.com>
+ *	  Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu	<jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *	      It implements:
+ *	      -instruction maintainace
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * Changes
+ *	JLEU: convert rt_cache_flush() to mpls_proto_cache_flush_all()
+ *
+ ****************************************************************************/
+
+#include <linux/autoconf.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <net/neighbour.h>
+#include <net/route.h>
+#include <net/mpls.h>
+
+
+/**
+ *	mpls_instr_alloc - Allocate a mpls_instruction object
+ *	@opcode: opcode num.
+ **/
+
+struct mpls_instr*
+mpls_instr_alloc (unsigned short opcode)
+{
+	struct mpls_instr  *mi;
+
+	mi = kmalloc(sizeof(struct mpls_instr), GFP_ATOMIC);
+	if (likely(mi)) {
+		memset (mi, 0, sizeof(struct mpls_instr));
+		mi->mi_opcode = opcode;
+	}
+	return mi;
+}
+
+/**
+ *	mpls_instr_release - destructor for mpls instruction.
+ *	@mi: this instruction
+ *
+ **/
+
+void 
+mpls_instr_release (struct mpls_instr *mi)
+{
+	unsigned short op	= mi->mi_opcode;
+	void *data		= mi->mi_data;
+	void *parent		= mi->mi_parent;
+	enum mpls_dir dir	= mi->mi_dir;
+
+	MPLS_ENTER;
+
+	if ((mpls_ops[op].cleanup) && data) 
+		mpls_ops[op].cleanup (data, parent, dir);
+
+	/* Poisson */
+	memset(mi,0xae,sizeof(struct mpls_instr));
+	kfree (mi);
+	MPLS_EXIT;
+}
+
+
+/**
+ *	mpls_instrs_free - free an instruction set. 
+ *	@instr:       Instruction list 
+ *
+ **/
+ 
+void
+mpls_instrs_free (struct mpls_instr *list)
+{
+	struct mpls_instr* mi  = list;
+	struct mpls_instr *tmp = NULL;
+
+	MPLS_ENTER;
+	while (mi) {
+		tmp = mi->mi_next;
+		mpls_instr_release (mi);
+		mi = tmp;
+	}
+	MPLS_EXIT;
+}
+
+/**
+ *	mpls_instrs_build - build up an instruction set. 
+ *	@mie:	 Instruction Element array 
+ *	@instr:       Instruction list [OUT]
+ *	@length:      Number of valid entries in the array
+ *	@dir:	 MPLS_IN for ILMs (ILM) or MPLS_OUT for NHLFEs (NHLFE).
+ *	@parent:      ILM/NHLFE "parent object".
+ *
+ *	This function constructs a "instr/operation set", the set of 
+ *	opcodes to execute with the corresponding data for a given ILM/NHLFE
+ *	object.
+ *
+ *	Returns the number of valid entries.
+ **/
+ 
+int 
+mpls_instrs_build (struct mpls_instr_elem *mie, struct mpls_instr **instr, 
+	int length, enum mpls_dir  dir,   void *parent) 
+{
+	
+	struct mpls_instr **pmi = instr;  /* Instruction List */
+	unsigned short opcode = 0;	  /* Opcode interator */
+	unsigned short i = 0;		  /* Element iterator */
+	int num_push  = 0;		  /* Total # of pushes */
+	int last_able = 0;		  /* This must be true at end */
+	MPLS_BUILD_OPCODE_PROTOTYPE(*f);  /* Build Operation */
+	struct mpls_instr  *mi;		  /* MPLS Instruction Iterator */
+	void *data;
+	int ret       = -ENXIO;
+
+	MPLS_ASSERT(*instr == NULL);
+
+	/* Iterate the instr set */
+	for (i = 0; i < length; i++) {
+		opcode  = mie[i].mir_opcode;
+		f       = mpls_ops[opcode].build;
+		if (unlikely(!f))
+			goto rollback; 
+
+		mi      = mpls_instr_alloc(opcode); 
+		if (unlikely(!mi))
+			goto rollback;	
+
+		data    = NULL;
+		*pmi = mi;
+
+		/* Build the opcode.
+		 * Input : parent ILM/NHLFE, elem & direcion.
+		 * Output: cumul pushes for this ILM/NHLFE,last?, data */
+		ret = f(&mie[i],dir,parent,&data,&last_able,&num_push);
+		if (ret)
+			goto rollback; 
+
+		mi->mi_data   = data;
+		mi->mi_parent = parent;
+		mi->mi_dir    = dir;
+		pmi = &mi->mi_next;
+	}
+
+	/* Make sure the last one was valid */
+	if (!last_able) {
+		printk (KERN_ERR "MPLS: invalid last op %s, len = %d(%d)\n",
+			mpls_ops[opcode].msg, i, length);
+		goto rollback;
+	}
+
+	MPLS_ASSERT(*instr);
+
+	/*
+	 * it is possible that the MTU of a NHLFE may have changed.
+	 * to be paranoid, flush the layer 3 caches
+	 */
+	mpls_proto_cache_flush_all();
+
+	return i;
+
+rollback:
+	mi  = *instr;
+	mpls_instrs_free(mi);
+	*instr = NULL;
+	return 0;
+}
+
+void
+mpls_instrs_unbuild(struct mpls_instr *instr, struct mpls_instr_req *req)
+{
+        MPLS_UNBUILD_OPCODE_PROTOTYPE(*func);
+        struct mpls_instr *mi;
+        int c = 0;
+
+        MPLS_ENTER;
+
+        for (mi = instr;mi;mi = mi->mi_next) {
+                req->mir_instr[c].mir_opcode = mi->mi_opcode;
+                func = mpls_ops[mi->mi_opcode].unbuild;
+
+                if (func)
+                        func(&req->mir_instr[c],mi->mi_data);
+                c++;
+        }
+
+        req->mir_instr_length = c;
+
+        MPLS_EXIT;
+}
+
+EXPORT_SYMBOL(mpls_instrs_build);
+EXPORT_SYMBOL(mpls_instrs_unbuild);
+EXPORT_SYMBOL(mpls_instrs_free);
diff -Naur linux-kernel-rpm-f8/net/mpls/mpls_netlink.c mpls-kernel-rpm-f8_modified/net/mpls/mpls_netlink.c
--- linux-kernel-rpm-f8/net/mpls/mpls_netlink.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/mpls/mpls_netlink.c	2008-10-17 09:45:05.000000000 +0200
@@ -0,0 +1,820 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching) Architecture for Linux.
+ *
+ *      NetLink Interface for MPLS subsystem
+ *
+ * Authors:
+ *	  Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2005   James Leu	<jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *	20051116 - jleu - convert to genetlink
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ *****************************************************************************/
+
+#include <linux/autoconf.h>
+#include <linux/netdevice.h>
+#include <net/arp.h>
+#include <net/sock.h>
+#include <net/mpls.h>
+#include <linux/netlink.h>
+#include <net/genetlink.h>
+#include <linux/gen_stats.h>
+#include <net/net_namespace.h>
+
+extern struct list_head mpls_ilm_list;
+extern struct list_head mpls_nhlfe_list;
+
+static struct genl_family genl_mpls = {
+	.id = PF_MPLS,
+	.name = "nlmpls",
+	.version = 0x1,
+	.maxattr = MPLS_ATTR_MAX,
+};
+
+/* ILM netlink support */
+
+static int mpls_fill_ilm(struct sk_buff *skb, struct mpls_ilm *ilm,
+	 u32 pid, u32 seq, int flag, int event)
+{
+	struct mpls_in_label_req mil;
+	struct gnet_stats_basic stats;
+	struct mpls_instr_req *instr;
+	void *hdr;
+
+	MPLS_ENTER;
+
+	hdr = genlmsg_put(skb, pid, seq, &genl_mpls, flag, event);
+
+	instr = kmalloc(sizeof(*instr), GFP_KERNEL);
+	if (unlikely(!instr))
+		goto nla_put_failure;
+
+	mil.mil_proto = ilm->ilm_proto->family;
+	memcpy(&mil.mil_label, &ilm->ilm_label, sizeof (struct mpls_label));
+	mpls_instrs_unbuild(ilm->ilm_instr, instr);
+	instr->mir_direction = MPLS_IN;
+	memcpy(&stats, &ilm->ilm_stats, sizeof(stats));
+	/* need to add drops here some how */
+
+	NLA_PUT(skb, MPLS_ATTR_ILM, sizeof(mil), &mil);
+	NLA_PUT(skb, MPLS_ATTR_INSTR, sizeof(*instr), instr);
+	NLA_PUT(skb, MPLS_ATTR_STATS, sizeof(stats), &stats);
+
+	kfree(instr);
+
+	MPLS_EXIT;
+	return genlmsg_end(skb, hdr);
+
+nla_put_failure:
+	if (instr)
+		kfree(instr);
+	genlmsg_cancel(skb, hdr);
+	MPLS_DEBUG("Exit: -1\n");
+	return -ENOMEM;
+}
+
+void mpls_ilm_event(int event, struct mpls_ilm *ilm)
+{
+	struct sk_buff *skb;
+	int err;
+
+	MPLS_ENTER;
+
+	skb = nlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
+	if (skb == NULL) {
+		MPLS_DEBUG("Exit: EINVAL\n");
+		return;
+	}
+
+	err = mpls_fill_ilm(skb, ilm, 0, 0, 0, event);
+	if (err < 0) {
+		nlmsg_free(skb);
+		MPLS_DEBUG("Exit: EINVAL\n");
+		return;
+	}
+	genlmsg_multicast(skb, 0, MPLS_GRP_ILM, GFP_KERNEL);
+	MPLS_EXIT;
+}
+
+static int genl_mpls_ilm_new(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_in_label_req *mil;
+	struct mpls_instr_req *instr = NULL;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+
+	if (!info->attrs[MPLS_ATTR_ILM])
+		return -EINVAL;
+
+	if (info->attrs[MPLS_ATTR_INSTR]) {
+		instr = nla_data(info->attrs[MPLS_ATTR_INSTR]);
+	}
+
+	mil = nla_data(info->attrs[MPLS_ATTR_ILM]);
+
+	if (info->nlhdr->nlmsg_flags&NLM_F_CREATE)
+		retval = mpls_add_in_label(mil);
+	else
+		retval = 0;
+
+	if ((!retval) && instr &&
+		mil->mil_change_flag & MPLS_CHANGE_INSTR) {
+		memcpy(&instr->mir_label, &mil->mil_label,
+			sizeof(struct mpls_label));
+		retval = mpls_set_in_label_instrs(instr);
+
+		/* JLEU: should revert to old instr on failure */
+		if (retval)
+			mpls_del_in_label(mil);
+	}
+
+	if ((!retval) && mil->mil_change_flag & MPLS_CHANGE_PROTO)
+		retval = mpls_set_in_label_proto(mil);
+
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_ilm_del(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_in_label_req *mil;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+
+	mil = nla_data(info->attrs[MPLS_ATTR_ILM]);
+	retval = mpls_del_in_label(mil);
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_ilm_get(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_in_label_req *mil;
+	struct mpls_ilm *ilm;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+	if (!info->attrs[MPLS_ATTR_ILM])
+		goto err;
+
+	mil = nla_data(info->attrs[MPLS_ATTR_ILM]);
+
+	if (mil->mil_label.ml_type == MPLS_LABEL_KEY)
+		goto err;
+
+	ilm = mpls_get_ilm(mpls_label2key(mil->mil_label.ml_index,
+		&mil->mil_label));
+	if (!ilm) {
+		retval = -ESRCH;
+	} else {
+		if (mpls_fill_ilm(skb, ilm, info->snd_pid, info->snd_seq,
+			0, MPLS_CMD_NEWILM) < 0)
+			retval = -EINVAL;
+
+		mpls_ilm_release (ilm);
+	}
+	retval = genlmsg_unicast(skb, info->snd_pid);
+err:
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_ilm_dump(struct sk_buff *skb, struct netlink_callback *cb)
+{
+	struct mpls_ilm *ilm;
+	struct list_head *entry;
+	int entries_to_skip;
+	int entry_count;
+
+	entries_to_skip = cb->args[0];
+	entry_count = 0;
+
+	MPLS_DEBUG("Enter: entry %d\n", entries_to_skip);
+	rcu_read_lock();
+	list_for_each_rcu(entry, &mpls_ilm_list) {
+		MPLS_DEBUG("Dump: entry %d\n", entry_count);
+		ilm = list_entry(entry, struct mpls_ilm,global);
+		if (entry_count >= entries_to_skip) {
+			if (mpls_fill_ilm(skb, ilm, NETLINK_CB(cb->skb).pid,
+				cb->nlh->nlmsg_seq, NLM_F_MULTI,
+				MPLS_CMD_NEWILM) < 0) {
+				break;
+			}
+		}
+		entry_count++;
+	}
+	rcu_read_unlock();
+	cb->args[0] = entry_count;
+
+	MPLS_DEBUG("Exit: entry %d\n", entry_count);
+	return skb->len;
+}
+
+/* NHLFE netlink support */
+
+static int mpls_fill_nhlfe(struct sk_buff *skb, struct mpls_nhlfe *nhlfe,
+	u32 pid, u32 seq, int flag, int event)
+{
+	struct mpls_out_label_req mol;
+	struct gnet_stats_basic stats;
+	struct mpls_instr_req *instr;
+	void *hdr;
+
+	MPLS_ENTER;
+
+	hdr = genlmsg_put(skb, pid, seq, &genl_mpls, flag, event);
+
+	instr = kmalloc(sizeof(*instr), GFP_KERNEL);
+	if (unlikely(!instr))
+		goto nla_put_failure;
+
+	mol.mol_label.ml_type = MPLS_LABEL_KEY;
+	mol.mol_label.u.ml_key = nhlfe->nhlfe_key;
+	mol.mol_mtu = nhlfe->nhlfe_mtu;
+	mol.mol_propagate_ttl = nhlfe->nhlfe_propagate_ttl;
+	mpls_instrs_unbuild(nhlfe->nhlfe_instr, instr);
+	instr->mir_direction = MPLS_OUT;
+	memcpy(&stats, &nhlfe->nhlfe_stats, sizeof(stats));
+	/* need to get drops added here some how */
+
+	NLA_PUT(skb, MPLS_ATTR_NHLFE, sizeof(mol), &mol);
+	NLA_PUT(skb, MPLS_ATTR_INSTR, sizeof(*instr), instr);
+	NLA_PUT(skb, MPLS_ATTR_STATS, sizeof(stats), &stats);
+
+	kfree(instr);
+
+	MPLS_EXIT;
+	return genlmsg_end(skb, hdr);
+
+nla_put_failure:
+	if (instr)
+		kfree(instr);
+
+	genlmsg_cancel(skb, hdr);
+	MPLS_DEBUG("Exit: -1\n");
+	return -ENOMEM;
+}
+
+void mpls_nhlfe_event(int event, struct mpls_nhlfe *nhlfe, int seq, int pid)
+{
+	struct sk_buff *skb;
+	int err;
+
+	MPLS_ENTER;
+	skb = nlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
+	if (skb == NULL) {
+		MPLS_DEBUG("Exit: EINVAL\n");
+		return;
+	}
+
+	err = mpls_fill_nhlfe(skb, nhlfe, pid, seq, 0, event);
+	if (err < 0) {
+		nlmsg_free(skb);
+		MPLS_DEBUG("Exit: EINVAL\n");
+		return;
+	}
+	genlmsg_multicast(skb, 0, MPLS_GRP_NHLFE, GFP_KERNEL);
+	MPLS_EXIT;
+}
+
+static int genl_mpls_nhlfe_new(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_out_label_req *mol;
+	struct mpls_instr_req *instr = NULL;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+
+	if (!info->attrs[MPLS_ATTR_NHLFE])
+		return -EINVAL;
+
+	if (info->attrs[MPLS_ATTR_INSTR]) {
+		instr = nla_data(info->attrs[MPLS_ATTR_INSTR]);
+	}
+
+	mol = nla_data(info->attrs[MPLS_ATTR_NHLFE]);
+
+	if (info->nlhdr->nlmsg_flags&NLM_F_CREATE) {
+		if (mol->mol_label.ml_type != MPLS_LABEL_KEY ||
+		    mol->mol_label.u.ml_key)
+			retval = -EINVAL;
+		else {
+			retval = mpls_add_out_label(mol, info->snd_seq,
+				info->snd_pid);
+		}
+	} else {
+		retval = 0;
+	}
+
+	if ((!retval) && instr &&
+		mol->mol_change_flag & MPLS_CHANGE_INSTR) {
+		memcpy(&instr->mir_label, &mol->mol_label,
+			sizeof(struct mpls_label));
+		retval = mpls_set_out_label_instrs(instr);
+		/* JLEU: should revert to old instr on failure */
+	}
+
+	if ((!retval) &&  mol->mol_change_flag & MPLS_CHANGE_MTU)
+		retval = mpls_set_out_label_mtu(mol);
+
+	if ((!retval) && mol->mol_change_flag & MPLS_CHANGE_PROP_TTL)
+		retval = mpls_set_out_label_propagate_ttl(mol);
+
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_nhlfe_del(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_out_label_req *mol;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+
+	mol = nla_data(info->attrs[MPLS_ATTR_NHLFE]);
+	retval = mpls_del_out_label(mol);
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_nhlfe_get(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_out_label_req *mol;
+	struct mpls_nhlfe *nhlfe;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+	if (!info->attrs[MPLS_ATTR_NHLFE])
+		goto err;
+
+	mol = nla_data(info->attrs[MPLS_ATTR_NHLFE]);
+
+	if (mol->mol_label.ml_type != MPLS_LABEL_KEY)
+		goto err;
+
+	nhlfe = mpls_get_nhlfe(mol->mol_label.u.ml_key);
+	if (!nhlfe) {
+		retval = -ESRCH;
+	} else {
+		if (mpls_fill_nhlfe(skb, nhlfe, info->snd_pid, info->snd_seq,
+			0, MPLS_CMD_NEWNHLFE) < 0)
+			retval = -EINVAL;
+
+		mpls_nhlfe_release (nhlfe);
+	}
+	retval = genlmsg_unicast(skb, info->snd_pid);
+err:
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_nhlfe_dump(struct sk_buff *skb,
+	struct netlink_callback *cb)
+{
+	struct mpls_nhlfe *nhlfe;
+	struct list_head *entry;
+	int entries_to_skip;
+	int entry_count;
+
+	entries_to_skip = cb->args[0];
+	entry_count = 0;
+
+	MPLS_DEBUG("Enter: entry %d\n", entries_to_skip);
+	rcu_read_lock();
+	list_for_each_rcu(entry, &mpls_nhlfe_list) {
+		MPLS_DEBUG("Dump: entry %d\n", entry_count);
+		nhlfe = list_entry(entry, struct mpls_nhlfe, global);
+		if (entry_count >= entries_to_skip) {
+			if (mpls_fill_nhlfe(skb, nhlfe, NETLINK_CB(cb->skb).pid,
+				cb->nlh->nlmsg_seq, NLM_F_MULTI,
+				MPLS_CMD_NEWNHLFE) <= 0) {
+				break;
+			}
+		}
+		entry_count++;
+	}
+	rcu_read_unlock();
+	cb->args[0] = entry_count;
+
+	MPLS_DEBUG("Exit: entry %d\n", entry_count);
+	return skb->len;
+}
+
+/* XC netlink support */
+
+static int mpls_fill_xc(struct sk_buff *skb, struct mpls_ilm *ilm,
+	struct mpls_nhlfe *nhlfe, u32 pid, u32 seq, int flag, int event)
+{
+	struct mpls_xconnect_req xc;
+	void *hdr;
+
+	hdr = genlmsg_put(skb, pid, seq, &genl_mpls, flag, event);
+
+	memcpy(&xc.mx_in, &ilm->ilm_label, sizeof (struct mpls_label));
+	xc.mx_out.ml_type = MPLS_LABEL_KEY;
+	xc.mx_out.u.ml_key = nhlfe->nhlfe_key;
+
+	NLA_PUT(skb, MPLS_ATTR_XC, sizeof(xc), &xc);
+
+	MPLS_DEBUG("Exit: length\n");
+	return genlmsg_end(skb, hdr);
+
+nla_put_failure:
+	genlmsg_cancel(skb, hdr);
+	MPLS_DEBUG("Exit: -1\n");
+	return -ENOMEM;
+}
+
+void mpls_xc_event(int event, struct mpls_ilm *ilm,
+	struct mpls_nhlfe *nhlfe)
+{
+	struct sk_buff *skb;
+	int err;
+
+	MPLS_ENTER;
+	skb = nlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
+	if (skb == NULL) {
+		MPLS_DEBUG("Exit: EINVAL\n");
+		return;
+	}
+
+	err = mpls_fill_xc(skb, ilm, nhlfe, 0, 0, 0, event);
+	if (err < 0) {
+		nlmsg_free(skb);
+		MPLS_DEBUG("Exit: EINVAL\n");
+		return;
+	}
+	genlmsg_multicast(skb, 0, MPLS_GRP_XC, GFP_KERNEL);
+	MPLS_EXIT;
+}
+
+static int genl_mpls_xc_new(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_xconnect_req *xc;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+
+	if (!info->attrs[MPLS_ATTR_XC])
+		return -EINVAL;
+
+	xc = nla_data(info->attrs[MPLS_ATTR_XC]);
+
+	if (!(info->nlhdr->nlmsg_flags&NLM_F_CREATE))
+		retval = -EINVAL;
+	else
+		retval = mpls_attach_in2out(xc);
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_xc_del(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_xconnect_req *xc;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+
+	xc = nla_data(info->attrs[MPLS_ATTR_XC]);
+	retval = mpls_detach_in2out(xc);
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_xc_get(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_xconnect_req *xc;
+	struct mpls_ilm *ilm;
+	struct mpls_nhlfe *nhlfe;
+	struct mpls_instr *mi;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+	if (!info->attrs[MPLS_ATTR_XC])
+		goto err;
+
+	xc = nla_data(info->attrs[MPLS_ATTR_XC]);
+
+	if (xc->mx_in.ml_type == MPLS_LABEL_KEY) {
+		retval = -EINVAL;
+		goto err;
+	}
+
+	ilm = mpls_get_ilm(mpls_label2key(xc->mx_in.ml_index,
+		&xc->mx_in));
+	if (!ilm) {
+		retval = -ESRCH;
+	} else {
+		/* Fetch the last instr, make sure it is FWD */
+		for (mi = ilm->ilm_instr;
+		     mi->mi_next;mi = mi->mi_next); /* noop */
+
+		if (!mi || mi->mi_opcode != MPLS_OP_FWD) {
+			retval = -ENXIO;
+		} else {
+			nhlfe = mi->mi_data;
+
+			if (mpls_fill_xc(skb, ilm, nhlfe, info->snd_pid,
+				info->snd_seq, 0, MPLS_CMD_NEWXC) < 0)
+				retval = -EINVAL;
+		}
+		mpls_ilm_release (ilm);
+	}
+	retval = genlmsg_unicast(skb, info->snd_pid);
+err:
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_xc_dump(struct sk_buff *skb, struct netlink_callback *cb)
+{
+	struct mpls_ilm *ilm;
+	struct mpls_nhlfe *nhlfe;
+	struct mpls_instr *mi;
+	struct list_head *entry;
+	int entries_to_skip;
+	int entry_count;
+
+	entries_to_skip = cb->args[0];
+	entry_count = 0;
+
+	MPLS_DEBUG("Enter: entry %d\n", entries_to_skip);
+	rcu_read_lock();
+	list_for_each_rcu(entry, &mpls_ilm_list) {
+		MPLS_DEBUG("Dump: entry %d\n", entry_count);
+		ilm = list_entry(entry, struct mpls_ilm,global);
+		if (entry_count >= entries_to_skip) {
+			/* Fetch the last instr, make sure it is FWD */
+			for (mi = ilm->ilm_instr;
+			     mi->mi_next;mi = mi->mi_next); /* noop */
+
+			if (!mi || mi->mi_opcode != MPLS_OP_FWD)
+				continue;
+
+			nhlfe = mi->mi_data;
+
+			if (mpls_fill_xc(skb, ilm, nhlfe,
+				NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq,
+				NLM_F_MULTI, MPLS_CMD_NEWXC) < 0) {
+				break;
+			}
+		}
+		entry_count++;
+	}
+	rcu_read_unlock();
+	cb->args[0] = entry_count;
+
+	MPLS_DEBUG("Exit: entry %d\n", entry_count);
+	return skb->len;
+}
+
+/* LABELSPACE netlink support */
+
+static int mpls_fill_labelspace(struct sk_buff *skb, struct net_device *dev,
+	    u32 pid, u32 seq, int flag, int event)
+{
+	struct mpls_labelspace_req ls;
+	void *hdr;
+
+	hdr = genlmsg_put(skb, pid, seq, &genl_mpls, flag, event);
+
+	ls.mls_ifindex = dev->ifindex;
+	if (dev->mpls_ptr) {
+		ls.mls_labelspace =
+			((struct mpls_interface*)dev->mpls_ptr)->labelspace;
+	} else {
+		ls.mls_labelspace = -1;
+	}
+
+	NLA_PUT(skb, MPLS_ATTR_LABELSPACE, sizeof(ls), &ls);
+
+	MPLS_DEBUG("Exit: length\n");
+	return genlmsg_end(skb, hdr);
+
+nla_put_failure:
+	genlmsg_cancel(skb, hdr);
+	MPLS_DEBUG("Exit: -1\n");
+	return -ENOMEM;
+}
+
+void mpls_labelspace_event(int event, struct net_device *dev)
+{
+	struct sk_buff *skb;
+	int err;
+
+	MPLS_ENTER;
+	skb = nlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
+	if (skb == NULL) {
+		MPLS_DEBUG("Exit: EINVAL\n");
+		return;
+	}
+
+	err = mpls_fill_labelspace(skb, dev, 0, 0, 0, event);
+	if (err < 0) {
+		nlmsg_free(skb);
+		MPLS_DEBUG("Exit: EINVAL\n");
+		return;
+	}
+	genlmsg_multicast(skb, 0, MPLS_GRP_LABELSPACE, GFP_KERNEL);
+	MPLS_EXIT;
+}
+
+static int genl_mpls_labelspace_set(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_labelspace_req *ls;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+	ls = nla_data(info->attrs[MPLS_ATTR_LABELSPACE]);
+	retval = mpls_set_labelspace(ls);
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_labelspace_get(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_labelspace_req *ls;
+	struct net_device *dev;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+	if (!info->attrs[MPLS_ATTR_LABELSPACE])
+		goto err;
+
+	ls = nla_data(info->attrs[MPLS_ATTR_LABELSPACE]);
+	dev = dev_get_by_index(&init_net, ls->mls_ifindex);
+	if (!dev) {
+		retval = -ESRCH;
+	} else {
+		if (mpls_fill_labelspace(skb, dev, info->snd_pid,
+			info->snd_seq, 0, MPLS_CMD_SETLABELSPACE) < 0)
+			retval = -EINVAL;
+		dev_put (dev);
+	}
+	retval = genlmsg_unicast(skb, info->snd_pid);
+err:
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_labelspace_dump(struct sk_buff *skb,
+	struct netlink_callback *cb)
+{
+	struct net_device *dev;
+	int entries_to_skip;
+	int entry_count;
+
+	entries_to_skip = cb->args[0];
+	entry_count = 0;
+
+	MPLS_DEBUG("Enter: entry %d\n", entries_to_skip);
+	read_lock(&dev_base_lock);
+	for_each_netdev(&init_net, dev) {
+		MPLS_DEBUG("Dump: entry %d\n", entry_count);
+		if (entry_count >= entries_to_skip) {
+			if (mpls_fill_labelspace(skb, dev,
+				NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq,
+				NLM_F_MULTI, MPLS_CMD_SETLABELSPACE) < 0) {
+				break;
+			}
+		}
+		entry_count++;
+	}
+	read_unlock(&dev_base_lock);
+	cb->args[0] = entry_count;
+
+	MPLS_DEBUG("Exit: entry %d\n", entry_count);
+	return skb->len;
+}
+
+static struct nla_policy genl_mpls_policy[MPLS_ATTR_MAX+1] __read_mostly = {
+	[MPLS_ATTR_ILM] = { .len = sizeof(struct mpls_in_label_req) },
+	[MPLS_ATTR_NHLFE] = { .len = sizeof(struct mpls_out_label_req) },
+	[MPLS_ATTR_XC] = { .len = sizeof(struct mpls_xconnect_req) },
+	[MPLS_ATTR_LABELSPACE] = {.len = sizeof(struct mpls_labelspace_req)},
+	[MPLS_ATTR_INSTR] = { .len = sizeof(struct mpls_instr_req) },
+	[MPLS_ATTR_STATS] = { .len = sizeof(struct gnet_stats_basic) },
+};
+
+static struct genl_ops genl_mpls_ilm_new_ops = {
+	.cmd		= MPLS_CMD_NEWILM,
+	.doit		= genl_mpls_ilm_new,
+	.policy		= genl_mpls_policy,
+};
+static struct genl_ops genl_mpls_ilm_del_ops = {
+	.cmd		= MPLS_CMD_DELILM,
+	.doit		= genl_mpls_ilm_del,
+	.policy		= genl_mpls_policy,
+};
+static struct genl_ops genl_mpls_ilm_get_ops = {
+	.cmd		= MPLS_CMD_GETILM,
+	.doit		= genl_mpls_ilm_get,
+	.dumpit		= genl_mpls_ilm_dump,
+	.policy		= genl_mpls_policy,
+};
+
+static struct genl_ops genl_mpls_nhlfe_new_ops = {
+	.cmd		= MPLS_CMD_NEWNHLFE,
+	.doit		= genl_mpls_nhlfe_new,
+	.policy		= genl_mpls_policy,
+};
+static struct genl_ops genl_mpls_nhlfe_del_ops = {
+	.cmd		= MPLS_CMD_DELNHLFE,
+	.doit		= genl_mpls_nhlfe_del,
+	.policy		= genl_mpls_policy,
+};
+static struct genl_ops genl_mpls_nhlfe_get_ops = {
+	.cmd		= MPLS_CMD_GETNHLFE,
+	.doit		= genl_mpls_nhlfe_get,
+	.dumpit		= genl_mpls_nhlfe_dump,
+	.policy		= genl_mpls_policy,
+};
+
+static struct genl_ops genl_mpls_xc_new_ops = {
+	.cmd		= MPLS_CMD_NEWXC,
+	.doit		= genl_mpls_xc_new,
+	.policy		= genl_mpls_policy,
+};
+static struct genl_ops genl_mpls_xc_del_ops = {
+	.cmd		= MPLS_CMD_DELXC,
+	.doit		= genl_mpls_xc_del,
+	.policy		= genl_mpls_policy,
+};
+static struct genl_ops genl_mpls_xc_get_ops = {
+	.cmd		= MPLS_CMD_GETXC,
+	.doit		= genl_mpls_xc_get,
+	.dumpit		= genl_mpls_xc_dump,
+	.policy		= genl_mpls_policy,
+};
+
+static struct genl_ops genl_mpls_labelspace_set_ops = {
+	.cmd		= MPLS_CMD_SETLABELSPACE,
+	.doit		= genl_mpls_labelspace_set,
+	.policy		= genl_mpls_policy,
+};
+static struct genl_ops genl_mpls_labelspace_get_ops = {
+	.cmd		= MPLS_CMD_GETLABELSPACE,
+	.doit		= genl_mpls_labelspace_get,
+	.dumpit		= genl_mpls_labelspace_dump,
+	.policy		= genl_mpls_policy,
+};
+
+int __init mpls_netlink_init(void)
+{
+	int err;
+
+	err = genl_register_family(&genl_mpls);
+
+	err += genl_register_ops(&genl_mpls, &genl_mpls_ilm_new_ops);
+	err += genl_register_ops(&genl_mpls, &genl_mpls_ilm_del_ops);
+	err += genl_register_ops(&genl_mpls, &genl_mpls_ilm_get_ops);
+
+	err += genl_register_ops(&genl_mpls, &genl_mpls_nhlfe_new_ops);
+	err += genl_register_ops(&genl_mpls, &genl_mpls_nhlfe_del_ops);
+	err += genl_register_ops(&genl_mpls, &genl_mpls_nhlfe_get_ops);
+
+	err += genl_register_ops(&genl_mpls, &genl_mpls_xc_new_ops);
+	err += genl_register_ops(&genl_mpls, &genl_mpls_xc_del_ops);
+	err += genl_register_ops(&genl_mpls, &genl_mpls_xc_get_ops);
+
+	err += genl_register_ops(&genl_mpls, &genl_mpls_labelspace_set_ops);
+	err += genl_register_ops(&genl_mpls, &genl_mpls_labelspace_get_ops);
+
+	if (err) {
+		printk(MPLS_ERR "MPLS: failed to register with genetlink\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void __exit mpls_netlink_exit(void)
+{
+	genl_unregister_ops(&genl_mpls, &genl_mpls_labelspace_get_ops);
+	genl_unregister_ops(&genl_mpls, &genl_mpls_labelspace_set_ops);
+
+	genl_unregister_ops(&genl_mpls, &genl_mpls_xc_del_ops);
+	genl_unregister_ops(&genl_mpls, &genl_mpls_xc_new_ops);
+	genl_unregister_ops(&genl_mpls, &genl_mpls_xc_get_ops);
+
+	genl_unregister_ops(&genl_mpls, &genl_mpls_nhlfe_del_ops);
+	genl_unregister_ops(&genl_mpls, &genl_mpls_nhlfe_new_ops);
+	genl_unregister_ops(&genl_mpls, &genl_mpls_nhlfe_get_ops);
+
+	genl_unregister_ops(&genl_mpls, &genl_mpls_ilm_del_ops);
+	genl_unregister_ops(&genl_mpls, &genl_mpls_ilm_new_ops);
+	genl_unregister_ops(&genl_mpls, &genl_mpls_ilm_get_ops);
+
+	genl_unregister_family(&genl_mpls);
+}
diff -Naur linux-kernel-rpm-f8/net/mpls/mpls_nhlfe.c mpls-kernel-rpm-f8_modified/net/mpls/mpls_nhlfe.c
--- linux-kernel-rpm-f8/net/mpls/mpls_nhlfe.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/mpls/mpls_nhlfe.c	2008-10-17 09:45:01.000000000 +0200
@@ -0,0 +1,618 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *	  James Leu	<jleu@mindspring.com>
+ *	  Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu	<jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *
+ *	      It implements:
+ *	      -add/get/del/flush for the out label tree
+ *	      -binding of FEC to out label
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * Changes:
+ *	20040102 RCAS: Commented, and clean up. 
+ *		- nhlfe_list lacks proper management. This list
+ *		should be updated when a NHLFE object is deleted. 
+ *		A possible approach would be to modify nhlfe_release.
+ *
+ ****************************************************************************/
+
+#include <linux/autoconf.h>
+#include <net/mpls.h>
+#include <asm/uaccess.h>
+#include <asm/atomic.h>
+#include <net/dst.h>
+#include <linux/rtnetlink.h>
+#include <linux/in.h>		/* must be before route.h */
+#include <linux/ip.h>		/* must be before route.h */
+#include <linux/inetdevice.h>	/* must be before route.h */
+#include <net/route.h>		/* must be before ip_fib.h */
+#include <net/ip_fib.h>
+#include <linux/genetlink.h>
+#include <net/net_namespace.h>
+
+LIST_HEAD(mpls_nhlfe_list);
+
+/* forward declarations */
+static struct dst_entry *nhlfe_dst_check(struct dst_entry *dst, u32 cookie);
+static void              nhlfe_dst_destroy(struct dst_entry *dst);
+static struct dst_entry *nhlfe_dst_negative_advice(struct dst_entry *dst);
+static void              nhlfe_dst_link_failure(struct sk_buff *skb);
+static void              nhlfe_dst_update_pmtu(struct dst_entry *dst, u32 mtu);
+static int               nhlfe_dst_gc(struct dst_ops *ops);
+
+struct dst_ops nhlfe_dst_ops = {
+	.family		 =  AF_MPLS,
+	.protocol	 = __constant_htons(ETH_P_MPLS_UC),
+	.gc		 = nhlfe_dst_gc,
+	.check		 = nhlfe_dst_check,
+	.destroy	 = nhlfe_dst_destroy,
+	.negative_advice = nhlfe_dst_negative_advice,
+	.link_failure	 = nhlfe_dst_link_failure,
+	.update_pmtu	 = nhlfe_dst_update_pmtu,
+	.entry_size	 = sizeof(struct mpls_nhlfe),
+};
+
+static struct dst_entry *
+nhlfe_dst_check (struct dst_entry *dst, u32 cookie)
+{
+	MPLS_ENTER;
+	dst_release(dst);
+	MPLS_EXIT;
+	return NULL;
+}
+
+/**
+ *      nhlfe_dst_destroy - cleanup for a MPLS dst_entry
+ *      @dst: 'this', object that is being destroyed.
+ *
+ *      The object ends life here. Perform the necessary
+ *      clean up, but do not call dst_free(..) etc.
+ **/
+
+static void
+nhlfe_dst_destroy (struct dst_entry *dst)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+}
+
+static struct dst_entry *
+nhlfe_dst_negative_advice (struct dst_entry *dst)
+{
+	MPLS_ENTER;
+	dst_release(dst);
+	MPLS_EXIT;
+	return NULL;
+}
+
+static void
+nhlfe_dst_link_failure (struct sk_buff *skb)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+}
+
+static void
+nhlfe_dst_update_pmtu (struct dst_entry *dst, u32 mtu)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+}
+
+static int
+nhlfe_dst_gc (struct dst_ops *ops)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+	return 0;
+}
+
+/**
+ *      nhlfe_dst_alloc - construct a mpls_nhlfe entry.
+ *
+ **/
+
+struct mpls_nhlfe*
+nhlfe_dst_alloc(unsigned int key)
+{
+	struct mpls_nhlfe *nhlfe;
+
+	MPLS_ENTER;
+
+	nhlfe = dst_alloc (&nhlfe_dst_ops);
+	if (unlikely(!nhlfe))
+		goto nhlfe_dst_alloc_0;
+
+	nhlfe->u.dst.dev	= init_net.loopback_dev;
+	nhlfe->u.dst.input	= mpls_switch;
+	nhlfe->u.dst.output	= mpls_output;
+
+	INIT_LIST_HEAD(&nhlfe->list_out);
+	INIT_LIST_HEAD(&nhlfe->list_in);
+	INIT_LIST_HEAD(&nhlfe->nhlfe_entry);
+	INIT_LIST_HEAD(&nhlfe->dev_entry);
+	INIT_LIST_HEAD(&nhlfe->global);
+
+	nhlfe->nhlfe_instr		= NULL;
+	nhlfe->nhlfe_propagate_ttl	= 1;
+	nhlfe->nhlfe_age		= jiffies;
+	nhlfe->nhlfe_key		= key;
+
+	MPLS_EXIT;
+	return nhlfe;
+
+/* Error Path */
+nhlfe_dst_alloc_0:
+	MPLS_EXIT;
+	return NULL;
+}
+
+
+/**
+ * mpls_nhlfe_tree: Radix Tree to hold NHLFE objects
+ **/
+RADIX_TREE(mpls_nhlfe_tree,GFP_ATOMIC);
+
+/**
+ * mpls_nhlfe_lock: lock for tree access.
+ **/
+DEFINE_SPINLOCK(mpls_nhlfe_lock);
+
+
+/**
+ * mpls_insert_nhlfe - Inserts the given NHLFE object in the MPLS
+ *   Output Information Radix Tree using the given key.
+ * @key : key to use
+ * @nhlfe : nhlfe object.
+ *
+ * Returns 0 on success, or:
+ *     -ENOMEM : unable to allocate node in the radix tree.
+ *
+ * Caller must hold mpls_nhlfe_lock
+ *
+ **/
+
+int 
+mpls_insert_nhlfe (unsigned int key, struct mpls_nhlfe *nhlfe) 
+{
+	int retval = 0;
+	retval = radix_tree_insert (&mpls_nhlfe_tree, key, nhlfe);
+	if (unlikely(retval))
+		retval = -ENOMEM;
+
+	list_add_rcu(&nhlfe->global, &mpls_nhlfe_list);
+
+	/* hold it for being in the tree */
+	mpls_nhlfe_hold (nhlfe);
+	return retval;
+}
+
+
+/**
+ *	mpls_remove_nhlfe - Remove the node given the key from the MPLS
+ *	Output Information Radix Tree.
+ *	@key : key to use
+ *
+ *	Must be called while holding a write lock on mpls_nhlfe_lock
+ *
+ *	This function deletes the NHLFE object from the Radix Tree, but please
+ *	also note that the object is not freed, and that the caller is
+ *	responsible for	decreasing the refcount if necessary.
+ *
+ *	Returns the node removed from the tree (which still needs to be
+ *	released) or NULL if no such key/element exists in the tree.
+ *
+ **/
+
+struct mpls_nhlfe* 
+mpls_remove_nhlfe (unsigned int key)
+{
+	struct mpls_nhlfe *nhlfe = NULL;
+
+	MPLS_ENTER;
+
+	nhlfe = radix_tree_delete(&mpls_nhlfe_tree, key);
+	if (!nhlfe)
+		MPLS_DEBUG("NHLFE node with key %u not found.\n",key);
+
+	list_del_rcu(&nhlfe->global);
+
+	/* release the refcnt for the tree hold it */
+	mpls_nhlfe_release (nhlfe);
+
+	MPLS_EXIT;
+	return nhlfe;
+}
+
+
+/**
+ *	mpls_get_nhlfe - Get a reference to a NHLFE object.
+ *	@key : key to look for in the NHLFE Radix Tree.
+ *
+ *	This function can be used to get a reference to a NHLFE object
+ *	given a key.
+ *	Returns a pointer to the NHLFE object, NULL on error.
+ *
+ *	Remark: this function increases the refcount of the NHLFE object, since it
+ *	calls to mpls_nhlfe_hold. Caller is responsible to release the object
+ *	when it is no longer needed (by using "mpls_nhlfe_release").
+ **/
+
+struct mpls_nhlfe*  
+mpls_get_nhlfe (unsigned int key) 
+{
+	struct mpls_nhlfe *nhlfe = NULL;
+
+	rcu_read_lock();
+	nhlfe = radix_tree_lookup (&mpls_nhlfe_tree, key);
+	smp_read_barrier_depends();
+	if (likely(nhlfe)) {
+		mpls_nhlfe_hold(nhlfe);
+	}
+	rcu_read_unlock();
+
+	return nhlfe;
+}
+
+/**
+ *	mpls_get_out_key - generate a key for out tree.
+ *
+ *	Returns an unused unique key to insert a NHLFE in the output
+ *	radix tree. 0 is not allowed (has special semantics).
+ *	Called in User context.
+ **/
+ 
+unsigned int 
+mpls_get_out_key(void) 
+{
+	static int new_key = 1;
+	struct mpls_nhlfe* dummy = NULL;
+
+	rcu_read_lock();
+	for (;;) {
+		if (++new_key <= 0)
+			new_key = 1;
+		dummy = radix_tree_lookup (&mpls_nhlfe_tree, new_key);
+		if (!dummy)
+			goto out;	
+	}
+out:
+	rcu_read_unlock();
+	return new_key;
+}
+
+/**
+ *	mpls_destroy_out_instrs - Destroy NHLFE instruction list. 
+ *	@nhlfe:	NHLFE object
+ *
+ *      This function completely destroys the instruction list for this
+ *      NHLFE object.
+ *
+ *      nhlfe_instr is set to NULL.
+ **/
+
+void
+mpls_destroy_out_instrs (struct mpls_nhlfe *nhlfe)
+{
+	MPLS_ENTER;
+	mpls_instrs_free (nhlfe->nhlfe_instr);
+	nhlfe->nhlfe_instr = NULL;
+	MPLS_EXIT;
+}
+
+int
+mpls_set_out_instrs (struct mpls_instr_elem *mie, int length,
+		struct mpls_nhlfe *nhlfe)
+{
+	struct mpls_instr *instr = NULL;
+	
+	/* Build temporary opcode set from mie */
+	if (!mpls_instrs_build(mie, &instr, length, MPLS_OUT, nhlfe))
+		return -1;
+
+	/* Commit the new ones */
+	if (nhlfe->nhlfe_instr)
+		mpls_instrs_free(nhlfe->nhlfe_instr);
+	nhlfe->nhlfe_instr = instr;
+	
+	return 0;
+}
+
+/**
+ *	mpls_set_out_label_instrs - program the opcodes for this NHLFE
+ *	@mir: request detailing the list of opcodes and data.
+ *
+ *	Update the NHLFE object (using the key in the request) with the passed
+ *	instrs/opcodes. Typically, once this function finishes for a PUSH/SET
+ *	Instruction Set, the refcount of a newly created NHLFE object is 2:
+ **/
+ 
+int 
+mpls_set_out_label_instrs (struct mpls_instr_req *mir)
+{
+	struct mpls_label *ml     = &mir->mir_label;
+	unsigned int key	  = mpls_label2key(0,ml);
+	struct mpls_nhlfe *nhlfe = mpls_get_nhlfe(key);
+	int ret;
+
+	if (unlikely(!nhlfe)) 
+		return -ESRCH;
+
+	ret = mpls_set_out_instrs (mir->mir_instr,mir->mir_instr_length, nhlfe);
+	mpls_nhlfe_release(nhlfe);
+	return ret;
+}
+
+/**
+ *	mpls_set_out_label_propagate_ttl - set the propagate_ttl status
+ *	@mol: request with the NHLFE key and desired propagate_ttl status
+ *
+ *	Update the NHLFE object (using the key in the request) with the
+ *	propagate_ttl from the request
+ **/
+ 
+int
+mpls_set_out_label_propagate_ttl(struct mpls_out_label_req *mol)
+{
+	unsigned int key	  = mpls_label2key(0,&mol->mol_label);
+	struct mpls_nhlfe *nhlfe = mpls_get_nhlfe(key);
+	if (!nhlfe)
+		return -ESRCH;
+
+	nhlfe->nhlfe_propagate_ttl = mol->mol_propagate_ttl;
+
+	mpls_nhlfe_release(nhlfe);
+	return 0;
+}
+
+/**
+ *	mpls_add_out_label - Add a new outgoing label to the database.
+ *	@out:request containing the label
+ *
+ *	Adds a new outgoing label to the outgoing tree. We first obtain
+ *	a unique unused key, check that the entry does not exist, 
+ *	allocate a new NHLFE object and reset it.
+ **/
+
+int 
+mpls_add_out_label (struct mpls_out_label_req *out, int seq, int pid) 
+{
+	struct mpls_nhlfe *nhlfe = NULL; 
+	unsigned int key	  = 0;
+	int retval		  = 0;
+
+	MPLS_ENTER;
+	BUG_ON(!out);
+
+	/* Create a new key */
+	key = mpls_get_out_key();
+
+	/* 
+	 * Check if the NHLFE is already in the tree. 
+	 * It should not exist. In fact, it is impossible :) 
+	 */
+	nhlfe = mpls_get_nhlfe (key);
+
+	if (unlikely(nhlfe)) {
+		MPLS_DEBUG("Node %u already exists in radix tree\n",key);
+
+		/* release the refcnt held by mpls_get_nhlfe */
+		mpls_nhlfe_release (nhlfe);
+		retval = -EEXIST;
+		goto error;
+	}
+
+	/* 
+	 * Allocate a new Output Information/Label,
+	 */
+	nhlfe = nhlfe_dst_alloc (key);
+	if (unlikely(!nhlfe)) {
+		retval = -ENOMEM;
+		goto error;
+	}
+
+	/* Insert into NHLFE tree */
+	spin_lock_bh (&mpls_nhlfe_lock);
+	if (unlikely(mpls_insert_nhlfe (key,nhlfe))) {
+		spin_unlock_bh (&mpls_nhlfe_lock);
+		nhlfe->u.dst.obsolete = 1;
+		dst_free (&nhlfe->u.dst);
+		goto error;
+	}
+
+	/* make sure that the dst system doesn't delete this until we're
+	 * done with it
+	 */
+	dst_hold(&nhlfe->u.dst);
+
+	mpls_nhlfe_hold(nhlfe);
+	spin_unlock_bh (&mpls_nhlfe_lock);
+
+	/* we need to hold a ref to the nhlfe while calling
+	 * mpls_nhlfe_event so it can't disappear
+	 */
+	mpls_nhlfe_event(MPLS_CMD_NEWNHLFE, nhlfe, seq, pid);
+	mpls_nhlfe_release(nhlfe);
+
+	out->mol_label.ml_type  = MPLS_LABEL_KEY;
+	out->mol_label.u.ml_key = key;
+
+error:
+	MPLS_EXIT;
+
+	return retval; 
+}
+
+/** 
+ *	mpls_del_out_label - Remove a NHLFE from the tree
+ *	@out: request.
+ **/
+
+int 
+mpls_del_out_label(struct mpls_out_label_req *out) 
+{
+	struct mpls_nhlfe *nhlfe = NULL;
+	unsigned int key;
+
+	MPLS_ENTER;
+
+	key = mpls_label2key(0,&out->mol_label);
+
+        nhlfe = mpls_get_nhlfe(key);
+	if (unlikely(!nhlfe)) {
+		MPLS_DEBUG("Node %u was not in tree\n",key);
+		MPLS_EXIT;
+		return  -ESRCH;
+	}
+
+	spin_lock_bh (&mpls_nhlfe_lock);
+
+	/* at this point a NHLFE that can be deleted will have a refcnt
+	 * of 2, one from mpls_get_nhlfe() we just executed and the
+	 * other that from when it was added to the tree
+	 */
+	if (atomic_read(&nhlfe->__refcnt) > 2) {
+		/* someone else is hold a refcnt, we can't delete */
+
+		/* release the refcnt we aquired in mpls_get_nhlfe() */
+		mpls_nhlfe_release (nhlfe);
+		spin_unlock_bh (&mpls_nhlfe_lock);
+
+		MPLS_DEBUG("Node %u is being used\n",key);
+		MPLS_EXIT;
+		return -EBUSY;
+	}
+
+	/*
+	 *	This code starts the process of removing a NHLFE from the
+	 *	system.  The first thing we we do it remove it from the tree
+	 *	so no one else can get a reference to it.  Then we notify the
+	 *	higher layer protocols that they should give up thier references
+	 *	soon (does not need to happen immediatly, the dst system allows
+	 *	for this.  Finally we schedule the RCU system to call
+	 *	dst_rcu_free() which waits until all CPUs have finished
+	 *	thier current work and then calls dst_rcu_free() which
+	 *	kicks the dst system into action once the dst system knows
+	 *	everyone is done using this "dst" it calls mpls_dst_destroy().
+	 */
+
+	/* remove the NHLFE from the tree (which decs the refcnt we held when
+	 * it was added to the tree)
+	 */
+	mpls_remove_nhlfe(nhlfe->nhlfe_key);
+	spin_unlock_bh (&mpls_nhlfe_lock);
+
+	mpls_nhlfe_event(MPLS_CMD_DELNHLFE, nhlfe, 0, 0);
+
+	/* destrory the instructions on this nhlfe, so as to no longer
+	 * hold refs to interfaces and other NHLFEs.
+	 *
+	 * Remember NHLFEs may stick around in the dst system even
+	 * after we've removed it from the tree.  So this will result
+	 * in traffic using the NHLFE to be dropped
+	 */
+	mpls_destroy_out_instrs (nhlfe);
+
+	/* let the dst system know we're done with this NHLFE and
+	 * schedule all higher layer protocol to give up their references */
+	dst_release(&nhlfe->u.dst);
+	nhlfe->u.dst.obsolete = 1;
+	mpls_proto_cache_flush_all();
+
+	/* since high layer protocols may still be using us in there caches
+	 * we need to use call_rcu() and dst_rcu_free() to take care
+	 * of actually cleaning up NHLFE
+	 */
+	call_rcu(&nhlfe->u.dst.rcu_head, dst_rcu_free);
+
+	/* release the refcnt we aquired in mpls_get_nhlfe() */
+	mpls_nhlfe_release (nhlfe);
+
+	MPLS_EXIT;
+	return 0;
+}
+
+/**
+ * mpls_set_out_label_mtu - change the MTU for this NHLFE.
+ * @out: Request containing the new MTU.
+ *
+ * Update the NHLFE object (using the key in the request) with the passed
+ * MTU.
+ **/
+
+int mpls_set_out_label_mtu(struct mpls_out_label_req *out)
+{
+	struct mpls_nhlfe *nhlfe = NULL;
+	int retval = 0;
+	unsigned int key;
+
+	BUG_ON(!out);
+	MPLS_ENTER;
+
+	key = out->mol_label.u.ml_key;
+
+	nhlfe = mpls_get_nhlfe(key);
+
+	if (unlikely(!nhlfe)) {
+		MPLS_DEBUG("Node %u does not exists in radix tree\n", key);
+		MPLS_EXIT;
+		return -ESRCH;
+	}
+
+	/* Update the MTU if possible */
+	if (nhlfe->nhlfe_mtu_limit >= out->mol_mtu) {
+		nhlfe->nhlfe_mtu = out->mol_mtu;
+	} else {
+		MPLS_DEBUG("MTU is larger than lower layer (%d > %d)\n",
+			out->mol_mtu, nhlfe->nhlfe_mtu_limit);
+
+		/* release the refcnt held by mpls_get_nhlfe */
+		mpls_nhlfe_release(nhlfe);
+		return -EINVAL;
+	}
+
+	/* release the refcnt held by mpls_get_nhlfe */
+	mpls_nhlfe_release(nhlfe);
+
+	/* force the layer 3 protocols to re-find and dsts (NHLFEs),
+	 * thus picking up the new MTU
+	 */
+	mpls_proto_cache_flush_all();
+
+	MPLS_EXIT;
+	return retval;
+}
+
+int __init mpls_nhlfe_init(void)
+{
+	nhlfe_dst_ops.kmem_cachep = kmem_cache_create("nhlfe_dst_cache",
+		sizeof(struct mpls_nhlfe), 0, SLAB_HWCACHE_ALIGN, NULL);
+
+	if (!nhlfe_dst_ops.kmem_cachep) {
+		printk(MPLS_ERR "MPLS: failed to alloc nhlfe_dst_cache\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+void __exit mpls_nhlfe_exit(void)
+{
+	if (nhlfe_dst_ops.kmem_cachep)
+		kmem_cache_destroy(nhlfe_dst_ops.kmem_cachep);
+	return;
+}
+
+EXPORT_SYMBOL(mpls_get_nhlfe);
diff -Naur linux-kernel-rpm-f8/net/mpls/mpls_opcode.c mpls-kernel-rpm-f8_modified/net/mpls/mpls_opcode.c
--- linux-kernel-rpm-f8/net/mpls/mpls_opcode.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/mpls/mpls_opcode.c	2008-10-17 09:45:02.000000000 +0200
@@ -0,0 +1,1904 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *          James Leu        <jleu@mindspring.com>
+ *          Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu        <jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * Changes:
+ *       20031218 JLEU:
+ *              Moved per instruction code into mpls_ops
+ *	20040120 RCAS:
+ *		Formatted and commented opcodes. Changed key access.
+ ****************************************************************************/
+
+#include <linux/autoconf.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <net/dst.h>
+#include <net/mpls.h>
+#include <linux/socket.h>
+#include <linux/inetdevice.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <net/arp.h>
+#include <net/route.h>
+#include <linux/rtnetlink.h>
+#include <net/ip_fib.h>
+#include <linux/inet.h>
+#include <net/net_namespace.h>
+
+/**
+ * mpls_finish - Leave the socket buffer in a known (coherent) state.
+ * @skb: Socket buffer.
+ *
+ * In order to optimize socket buffer management, the MPLS implementation
+ * manages a "gap", so the common POP-PUSH chain is optimized. This function
+ * leaves the socket buffer in a coherent state.
+ **/
+ 
+void mpls_finish(struct sk_buff *skb) 
+{
+	unsigned int diff = 0;
+	MPLS_ENTER;
+	diff = MPLSCB(skb)->gap;
+	if(diff > 0) {
+		memmove(skb->data - diff,skb->data,skb->len);
+		MPLSCB(skb)->gap = 0;
+		skb->data   -= diff;
+		skb->transport_header  -= diff;
+		skb->network_header -= diff;
+		skb->tail   -= diff;
+	} else {
+		if(diff < 0)
+			MPLS_DEBUG("data - data_old < 0\n");
+	}
+	MPLS_EXIT;
+}
+
+
+
+/**
+ * mpls_opcode_peek - Peek the topmost label entry from the stack.
+ * @skb: Socket buffer.
+ *
+ * RCAS: this function should be renamed to mpls_label_entry_peek
+ **/
+ 
+int mpls_opcode_peek(struct sk_buff *skb) 
+{
+	u32 shim;
+
+#define CAN_WE_ASSUME_32BIT_ALIGNED 0
+#if CAN_WE_ASSUME_32BIT_ALIGNED
+	shim = ntohl(*((u32*)&skb->network_header));
+#else
+	memcpy(&shim,skb->network_header,sizeof(u32));
+	shim = ntohl(shim);
+#endif
+
+	if (!(MPLSCB(skb)->flag)) {
+		MPLSCB(skb)->ttl  = shim & 0xFF;
+		MPLSCB(skb)->flag = 1;
+	}
+	MPLSCB(skb)->bos   = (shim >> 8 ) & 0x1;
+	MPLSCB(skb)->exp   = (shim >> 9 ) & 0x7;
+	MPLSCB(skb)->label = (shim >> 12) & 0xFFFFF;
+
+	return MPLS_RESULT_RECURSE;
+}
+
+
+
+/**
+ * mpls_push - push a label entry.
+ * @skb: Socket buffer.
+ * @ml: label value to push.
+ *
+ **/
+ 
+int mpls_push (struct sk_buff **skb, struct mpls_label *ml) 
+{
+	struct sk_buff *o = NULL; 
+	struct sk_buff *n = NULL;
+	unsigned int label = 0;
+	u32 shim;
+
+	MPLS_ENTER;
+	o = *skb;
+	if (unlikely(!ml)) {
+		MPLS_DEBUG("no outgoing label\n");
+		return MPLS_RESULT_DROP;
+	}
+
+try_again:
+	if(likely((MPLSCB(o)->gap >= sizeof(u32)) || (o->data - o->head >= sizeof(u32)))) {
+		/*
+		 * if we have room between data and end of mac_header
+		 * just shift the data,transport_header,network_header pointers and use the room
+		 * this would happen if we had a pop previous to this
+		 */
+		MPLS_DEBUG("using gap\n");
+		skb_push(o,sizeof(u32));
+		o->transport_header -= sizeof(u32);
+		o->network_header -= sizeof(u32);
+		if (MPLSCB(o)->gap > 4) {
+			MPLSCB(o)->gap -= sizeof(u32);
+		} else {
+			MPLSCB(o)->gap = 0;
+		}
+	} else {
+		/*
+		 * we have no room in the inn, go ahead and create a new sk_buff
+		 * with enough extra room for one shim
+		 */
+		MPLS_DEBUG("creating larger packet\n");
+		
+		if(!(n = skb_realloc_headroom(o, 32))) {
+			return MPLS_RESULT_DROP;
+		}
+
+		MPLSCB(n)->gap = 0;
+
+		MPLS_DEBUG("dump old packet\n");
+		MPLS_DEBUG_CALL(mpls_skb_dump(o));
+		kfree_skb(o);
+
+		MPLS_DEBUG("dump new packet\n");
+		MPLS_DEBUG_CALL(mpls_skb_dump(n));
+
+		o = *skb = n;
+
+		goto try_again;
+	}
+
+	switch(ml->ml_type) {
+		case MPLS_LABEL_GEN:
+			label = ml->u.ml_gen;
+			break;
+		default:
+			MPLS_DEBUG("invalid label type(%d)\n",ml->ml_type);
+			goto push_end;
+	}
+
+	/*
+	 * no matter what layer 2 we are on, we need the shim! (mpls-encap RFC)
+	 */
+	shim = htonl(((label & 0xFFFFF) << 12) |
+		     ((MPLSCB(o)->exp & 0x7) << 9) |
+		     ((MPLSCB(o)->bos & 0x1) << 8) |
+		      (MPLSCB(o)->ttl & 0xFF));
+	memmove(o->data,&shim,sizeof(u32));
+	MPLSCB(o)->label = label;
+	MPLSCB(o)->bos = 0;
+	MPLSCB(o)->popped_bos = 0;
+
+push_end:
+	MPLS_EXIT;
+	return MPLS_RESULT_SUCCESS;;
+}
+
+
+/*
+ * Helper functions
+ */
+ 
+static inline void 
+mpls_list_del_init (struct list_head *entry)
+{
+	if (!list_empty(entry))
+		list_del_init(entry);
+}
+										
+static inline void 
+mpls_nhlfe_release_safe (struct mpls_nhlfe *nhlfe)
+{
+	if (nhlfe)
+		mpls_nhlfe_release (nhlfe);
+}
+
+/* 
+ * Generic function pointer to use when the opcode just
+ * needs to free the data pointer
+ */
+MPLS_CLEAN_OPCODE_PROTOTYPE(mpls_clean_opcode_generic) 
+{
+	kfree(data);
+}
+
+
+/*********************************************************************
+ * MPLS_OP_NOP
+ * DESC   : "No operation".
+ * EXEC   : mpls_op_nop
+ * INPUT  : true
+ * OUTPUT : true 
+ * DATA   : NULL 
+ * LAST   : true 
+ *********************************************************************/
+
+MPLS_OPCODE_PROTOTYPE(mpls_op_nop)
+{
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+
+/*********************************************************************
+ * MPLS_OP_POP
+ * DESC   : "Pop label from stack"
+ * EXEC   : mpls_in_op_pop
+ * BUILD  : mpls_build_opcode_pop
+ * UNBUILD: NULL
+ * INPUT  : true
+ * OUTPUT : false 
+ * DATA   : NULL 
+ * LAST   : false 
+ *********************************************************************/
+ 
+MPLS_IN_OPCODE_PROTOTYPE(mpls_in_op_pop)
+{
+	/*
+	 * Check that we have not popped the last label and
+	 * make sure that we can pull
+	 */
+	if (MPLSCB(*skb)->popped_bos || (((*skb)->data + sizeof(u32)) >= (*skb)->tail)) {
+		return MPLS_RESULT_DROP;
+	}
+
+	/*
+	 * Is this the last entry in the stack? then flag it
+	 */
+	if (MPLSCB(*skb)->bos) {
+		MPLSCB(*skb)->popped_bos = 1;
+	}
+
+	skb_pull(*skb, sizeof(u32));
+	(*skb)->transport_header     += sizeof(u32);
+	(*skb)->network_header    += sizeof(u32);
+	MPLSCB(*skb)->gap += sizeof(u32);
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_pop) 
+{
+	*data = NULL;
+	if (direction != MPLS_IN) {
+		MPLS_DEBUG("POP only valid for incoming labels\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+
+
+/*********************************************************************
+ * MPLS_OP_PEEK
+ * DESC   : "Peek the contents of the next label entry, no popping"
+ * EXEC   : mpls_in_opcode_peek
+ * BUILD  : mpls_build_opcode_peek
+ * UNBUILD: NULL
+ * INPUT  : true
+ * OUTPUT : false 
+ * DATA   : NULL 
+ * LAST   : true 
+ *********************************************************************/
+
+MPLS_IN_OPCODE_PROTOTYPE(mpls_in_op_peek)
+{
+	if (MPLSCB(*skb)->bos) {
+		return MPLS_RESULT_DLV;
+	}
+	mpls_opcode_peek(*skb);
+	return MPLS_RESULT_RECURSE;
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_peek) 
+{
+	*data = NULL;
+	if (direction != MPLS_IN) {
+		MPLS_DEBUG("PEEK only valid for incoming labels\n");
+		return -EINVAL;
+	}
+	*last_able = 1;
+	return 0;
+}
+
+
+
+/*********************************************************************
+ * MPLS_OP_PUSH
+ * DESC   : "Push a label entry"
+ * EXEC   : mpls_op_push
+ * BUILD  : mpls_build_opcode_push
+ * UNBUILD: mpls_unbuild_opcode_push
+ * CLEAN  : mpls_clean_opcode_push
+ * INPUT  : ? 
+ * OUTPUT : true 
+ * DATA   : Reference to label to push (struct mpls_label*)
+ * LAST   : false 
+ *********************************************************************/
+
+MPLS_OPCODE_PROTOTYPE(mpls_op_push)
+{
+	BUG_ON(!data);
+	return mpls_push(skb,(struct mpls_label*)data);
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_push) 
+{
+	struct mpls_label *ml = NULL;
+
+	MPLS_ENTER;
+	*data = kmalloc(sizeof(*ml), GFP_ATOMIC);
+	if (unlikely(!(*data))) {
+		MPLS_DEBUG("error building PUSH label instruction\n");
+		MPLS_EXIT;
+		return -ENOMEM;
+	} 
+
+	ml = _mpls_as_label(*data);
+	memcpy(ml,&instr->mir_push, sizeof(*ml));
+	(*num_push)++;
+	MPLS_EXIT;
+	return 0;
+}
+
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_push) 
+{
+	struct mpls_label *ml = NULL;
+	MPLS_ENTER;
+
+	ml = data;
+	memcpy(&instr->mir_push, ml, sizeof(*ml));
+
+	MPLS_EXIT;
+	return 0;
+}
+
+
+MPLS_CLEAN_OPCODE_PROTOTYPE(mpls_clean_opcode_push) 
+{
+	MPLS_ENTER;
+	kfree(data);
+	MPLS_EXIT;
+}
+
+
+
+/*********************************************************************
+ * MPLS_OP_DLV
+ * DESC   : "Deliver to the upper layers, set skb protocol to ILM's"
+ *          "Incoming L3 protocol"
+ * EXEC   : mpls_in_opcode_dlv
+ * BUILD  : mpls_build_opcode_dlv
+ * UNBUILD: NULL
+ * INPUT  : true
+ * OUTPUT : false 
+ * DATA   : NULL 
+ * LAST   : true 
+ *********************************************************************/
+
+MPLS_IN_OPCODE_PROTOTYPE(mpls_in_op_dlv)
+{
+	return MPLS_RESULT_DLV;
+}
+
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_dlv) 
+{
+	*data = NULL;
+	if (unlikely(direction != MPLS_IN)) {
+		MPLS_DEBUG("DLV only valid for incoming labels\n");
+		return -EINVAL;
+	}
+	*last_able = 1;
+	return 0;
+}
+
+
+
+/*********************************************************************
+ * MPLS_OP_FWD
+ * DESC   : "Forward packet, applying a given NHLFE"
+ * EXEC   : mpls_op_fwd
+ * BUILD  : mpls_build_opcode_fwd
+ * UNBUILD: mpls_unbuild_opcode_fwd
+ * CLEAN  : mpls_clean_opcode_fwd
+ * INPUT  : true
+ * OUTPUT : true
+ * DATA   : Reference to NHLFE object to apply
+ * LAST   : true
+ *********************************************************************/
+
+MPLS_OPCODE_PROTOTYPE(mpls_op_fwd)
+{
+	BUG_ON(!data);
+	*nhlfe = (struct mpls_nhlfe*)data;
+	return MPLS_RESULT_FWD;
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_fwd) 
+{
+	struct mpls_nhlfe *nhlfe = NULL;
+	unsigned int key = 0;
+
+	MPLS_ENTER;
+	*data      = NULL; 
+	/* 
+	 * Get NHLFE to apply given key
+	 */
+	key   = mpls_label2key(0, &instr->mir_fwd);
+	nhlfe   = mpls_get_nhlfe(key);
+	if (unlikely(!nhlfe)) {
+		MPLS_DEBUG("FWD: NHLFE key %08x not found\n", key);
+		MPLS_EXIT;
+		return -ESRCH;
+	}
+
+	if (direction == MPLS_OUT) {
+		struct mpls_nhlfe *pnhlfe = _mpls_as_nhlfe(parent);
+		pnhlfe->nhlfe_mtu = nhlfe->nhlfe_mtu - (4 * (*num_push));
+		pnhlfe->nhlfe_mtu_limit = pnhlfe->nhlfe_mtu;
+		/* Add parent NHLFE to this NHLFE list */
+		list_add(&pnhlfe->nhlfe_entry, &nhlfe->list_out);
+	} else {
+		struct mpls_ilm *pilm = _mpls_as_ilm(parent);
+		/* Add parent ILM to this NHLFE list */
+		list_add(&pilm->nhlfe_entry, &nhlfe->list_in);
+	}
+
+	*data      = nhlfe; 
+	*last_able = 1;
+	MPLS_EXIT;
+	return 0;
+}
+
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_fwd)
+{
+	struct mpls_nhlfe *nhlfe = NULL;
+
+	MPLS_ENTER;
+
+	nhlfe = data;
+	instr->mir_fwd.ml_type = MPLS_LABEL_KEY;
+	instr->mir_fwd.u.ml_key = nhlfe->nhlfe_key;
+
+	MPLS_EXIT;
+	return 0;
+}
+
+
+MPLS_CLEAN_OPCODE_PROTOTYPE(mpls_clean_opcode_fwd) 
+{
+	if (direction == MPLS_IN)
+		/* Remove parent NHLFE from this NHLFE list */
+		mpls_list_del_init(&_mpls_as_ilm(parent)->nhlfe_entry);
+	else
+		/* Remove parent NHLFE from this NHLFE list */
+		mpls_list_del_init(&_mpls_as_nhlfe(parent)->nhlfe_entry);
+
+	mpls_nhlfe_release(_mpls_as_nhlfe(data)); 
+}
+
+
+
+
+/*********************************************************************
+ * MPLS_OP_NF_FWD
+ * DESC   : "Forward packet, applying the NHLFE defined by skbuff mark"
+ * EXEC   : mpls_op_nf_fwd
+ * BUILD  : mpls_build_opcode_nf_fwd
+ * UNBUILD: mpls_unbuild_opcode_nf_fwd
+ * CLEAN  : mpls_clean_opcode_nf_fwd
+ * INPUT  : false 
+ * OUTPUT : true
+ * DATA   : NFI object (struct mpls_nfmark_fwd_info*)
+ *	o Each nfi_nhlfe element holds a ref to a NHLFE object
+ * LAST   : true
+ *********************************************************************/
+
+#ifdef CONFIG_NETFILTER
+
+MPLS_OUT_OPCODE_PROTOTYPE(mpls_out_op_nf_fwd)
+{
+	struct mpls_nfmark_fwd_info *nfi =  data;
+	*nhlfe = nfi->nfi_nhlfe[(*skb)->mark & nfi->nfi_mask];
+	if (unlikely(!(*nhlfe)))
+		return MPLS_RESULT_DROP;
+	return MPLS_RESULT_FWD;
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_nf_fwd) 
+{
+	struct mpls_nfmark_fwd_info *nfi = NULL;
+	struct mpls_nhlfe        *nhlfe = NULL;
+	unsigned int min_mtu = 0xFFFFFFFF;
+	unsigned int key     = 0;
+	int j = 0;
+
+	*data = NULL;
+	
+	/* Allocate NFI object to store in data */
+	nfi = kmalloc(sizeof(*nfi),GFP_ATOMIC);
+	if (unlikely(!nfi)) {
+		MPLS_DEBUG("NF_FWD error building NFMARK info\n");
+		return -ENOMEM;
+	}
+	memset(nfi,0,sizeof(*nfi));
+
+	
+	/* Set up NHLFE objects for each mark given the keys */
+	nfi->nfi_mask = instr->mir_nf_fwd.nf_mask;
+	if (nfi->nfi_mask >= MPLS_NFMARK_NUM) {
+		MPLS_DEBUG("NF_FWD mask(%02x) allows too large of values\n",
+			nfi->nfi_mask);
+		kfree (nfi);
+		return -EINVAL;
+	}
+
+	for (j=0; j<MPLS_NFMARK_NUM; j++) {
+		key = instr->mir_nf_fwd.nf_key[j];
+		if (!key) {
+			continue;
+		}
+		nhlfe = mpls_get_nhlfe(key);
+		if (unlikely(!nhlfe)) {
+			MPLS_DEBUG("NF_FWD: NHLFE - key %08x not found\n", key);
+			kfree (nfi);
+			return -ESRCH;
+		}
+		if (nhlfe->nhlfe_mtu < min_mtu) {
+			min_mtu = nhlfe->nhlfe_mtu;
+		}
+		nfi->nfi_nhlfe[j] = nhlfe;
+	}
+
+	/* 
+	 * Set the MTU according to the number of pushes. 
+	 * RCAS :If the opcode is only allowed in output the "if"  should be 
+	 * removed, and a check added at the beginning 
+	 */
+	if (direction == MPLS_OUT) {
+		struct mpls_nhlfe *pnhlfe = _mpls_as_nhlfe(parent);
+		pnhlfe->nhlfe_mtu = min_mtu - (4 * (*num_push));
+		pnhlfe->nhlfe_mtu_limit = pnhlfe->nhlfe_mtu;
+	}
+	*data = (void*)nfi;
+	*last_able = 1;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_nf_fwd) 
+{
+	struct mpls_nfmark_fwd_info *nfi;
+	struct mpls_nhlfe *nhlfe;
+	unsigned int key;
+	int j;
+
+	MPLS_ENTER;
+	
+	nfi = _mpls_as_nfi(data);
+	instr->mir_nf_fwd.nf_mask = nfi->nfi_mask;
+
+	for(j=0;j<MPLS_NFMARK_NUM;j++) {
+		nhlfe = nfi->nfi_nhlfe[j];
+
+		key = (nhlfe) ? nhlfe->nhlfe_key : 0;
+		instr->mir_nf_fwd.nf_key[j] = key;
+	}
+
+	MPLS_EXIT;
+	return 0;
+}
+
+MPLS_CLEAN_OPCODE_PROTOTYPE(mpls_clean_opcode_nf_fwd) 
+{
+	int i;
+	for (i=0;i<MPLS_NFMARK_NUM;i++) 
+		mpls_nhlfe_release_safe(_mpls_as_nfi(data)->nfi_nhlfe[i]);
+	kfree(data);
+}
+#endif
+
+
+
+
+/*********************************************************************
+ * MPLS_OP_DS_FWD
+ * DESC   : "Forward packet, applying the NHLFE defined by DS field in the"
+ *          "encapsulated IPv4/IPv6 packet"
+ * EXEC   : mpls_op_ds_fwd
+ * BUILD  : mpls_build_opcode_ds_fwd
+ * UNBUILD: mpls_unbuild_opcode_ds_fwd
+ * CLEAN  : mpls_clean_opcode_ds_fwd
+ * INPUT  : false 
+ * OUTPUT : true
+ * DATA   : DFI object (struct mpls_dsmark_fwd_info*)
+ *	o Each dfi_nhlfe element holds a ref to a NHLFE object
+ * LAST   : true
+ *********************************************************************/
+
+MPLS_OUT_OPCODE_PROTOTYPE(mpls_out_op_ds_fwd)
+{
+	struct mpls_dsmark_fwd_info *dfi = data;
+	unsigned char ds;
+
+	ds = MPLSCB(*skb)->prot->get_dsfield(*skb);
+
+	*nhlfe = dfi->dfi_nhlfe[ds];
+	if (unlikely(NULL == *nhlfe))
+		return MPLS_RESULT_DROP;
+
+	return MPLS_RESULT_FWD;
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_ds_fwd) 
+{
+	struct mpls_dsmark_fwd_info *dfi = NULL;
+	struct mpls_nhlfe        *nhlfe = NULL;
+	unsigned int min_mtu = 0xFFFFFFFF;
+	unsigned int key     = 0;
+	
+	int j = 0;
+
+	*data = NULL;
+	/* Allocate DFI object to store in data */
+	dfi = kmalloc(sizeof(*dfi),GFP_ATOMIC);
+	if (unlikely(!dfi)) {
+		MPLS_DEBUG("DS_FWD error building DSMARK info\n");
+		return -ENOMEM;
+	}
+	memset(dfi,0,sizeof(*dfi));
+	
+	
+	/* Set up NHLFE objects for each mark given the keys */
+	dfi->dfi_mask = instr->mir_ds_fwd.df_mask;
+	if (dfi->dfi_mask >= MPLS_DSMARK_NUM) {
+		MPLS_DEBUG("DS_FWD mask(%02x) allows too large of values\n",
+			dfi->dfi_mask);
+		kfree(dfi);
+		return -EINVAL;
+	}
+
+	for (j=0; j<MPLS_DSMARK_NUM; j++) {
+		key = instr->mir_ds_fwd.df_key[j];
+		if (!key) {
+			continue;
+		}
+		nhlfe = mpls_get_nhlfe(key);
+		if (unlikely(!nhlfe)) {
+			MPLS_DEBUG("DS_FWD: NHLFE key %08x not found\n", key);
+			kfree(dfi);
+			return -ESRCH;
+		}
+		if (nhlfe->nhlfe_mtu < min_mtu) {
+			min_mtu = nhlfe->nhlfe_mtu;
+		}
+		dfi->dfi_nhlfe[j] = nhlfe;
+	}
+
+	/* 
+	 * Set the MTU according to the number of pushes. 
+	 * RCAS :If the opcode is only allowed in output the "if"  should be 
+	 * removed, and a check added at the beginning 
+	 */
+	if (direction == MPLS_OUT) {
+		struct mpls_nhlfe *pnhlfe = _mpls_as_nhlfe(parent);
+		pnhlfe->nhlfe_mtu = min_mtu - (4 * (*num_push));
+		pnhlfe->nhlfe_mtu_limit = pnhlfe->nhlfe_mtu;
+	}
+	*data = (void*)dfi;
+	*last_able = 1;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_ds_fwd) 
+{
+	struct mpls_dsmark_fwd_info *dfi;
+	struct mpls_nhlfe *nhlfe;
+	unsigned int key;
+	int j;
+
+	MPLS_ENTER;
+	
+	dfi = _mpls_as_dfi(data);
+	instr->mir_ds_fwd.df_mask = dfi->dfi_mask;
+
+	for(j=0;j<MPLS_DSMARK_NUM;j++) {
+		nhlfe = dfi->dfi_nhlfe[j];
+
+		key = (nhlfe) ? nhlfe->nhlfe_key : 0;
+		instr->mir_ds_fwd.df_key[j] = key;
+	}
+
+	MPLS_EXIT;
+	return 0;
+}
+
+MPLS_CLEAN_OPCODE_PROTOTYPE(mpls_clean_opcode_ds_fwd) 
+{
+	int i;
+	for (i=0;i<MPLS_DSMARK_NUM;i++) 
+		mpls_nhlfe_release_safe(_mpls_as_dfi(data)->dfi_nhlfe[i]);
+	kfree(data);
+}
+
+
+
+/*********************************************************************
+ * MPLS_OP_EXP_FWD
+ * DESC   : "Forward packet, applying the NHLFE defined by DS the 3 EXP"
+ *          "bits in lable entry"
+ * EXEC   : mpls_op_exp_fwd
+ * BUILD  : mpls_build_opcode_exp_fwd
+ * UNBUILD: mpls_unbuild_opcode_exp_fwd
+ * CLEAN  : mpls_clean_opcode_exp_fwd
+ * INPUT  : true 
+ * OUTPUT : true
+ * DATA   : EFI object (struct mpls_exp_fwd_info*)
+ *	o Each efi_nhlfe element holds a ref to a NHLFE object
+ * LAST   : true
+ *********************************************************************/
+
+MPLS_OPCODE_PROTOTYPE(mpls_op_exp_fwd)
+{
+	struct mpls_exp_fwd_info *efi = data;
+	/*
+	 * Apply the NHLFE defined by the  given 3 EXP bits in label entry
+	 */
+	*nhlfe = efi->efi_nhlfe[MPLSCB(*skb)->exp & 0x7];
+	if (unlikely(NULL == *nhlfe))
+		return MPLS_RESULT_DROP;
+	return MPLS_RESULT_FWD;
+}
+
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_exp_fwd) 
+{
+	struct mpls_exp_fwd_info *efi = NULL;
+	struct mpls_nhlfe     *nhlfe = NULL;
+	unsigned int min_mtu = 0xFFFFFFFF;
+	unsigned int key     = 0;
+	int j = 0;
+
+	*data = NULL;
+	/* Allocate EFI object to store in data */
+	efi = kmalloc(sizeof(*efi),GFP_ATOMIC);
+	if (unlikely(!efi)) {
+		MPLS_DEBUG("EXP_FWD error building EXP info\n");
+		return -ENOMEM;
+	}
+	memset(efi,0,sizeof(*efi));
+
+	/* Set up NHLFE objects for each EXP value, given the keys */
+	for (j=0; j<MPLS_EXP_NUM; j++) {
+		key = instr->mir_exp_fwd.ef_key[j];
+		if (!key) {
+			continue;
+		}
+		nhlfe = mpls_get_nhlfe(key);
+		if (unlikely(!nhlfe)) {
+			MPLS_DEBUG("EXP_FWD: NHLFE key %08x not found\n", key);
+			kfree(efi);
+			return -ESRCH;
+		}
+		if (nhlfe->nhlfe_mtu < min_mtu) {
+			min_mtu = nhlfe->nhlfe_mtu;
+		}
+		efi->efi_nhlfe[j] = nhlfe;
+	}
+
+	/* 
+	 * Set the MTU according to the number of pushes. 
+	 */
+	if (direction == MPLS_OUT) {
+		struct mpls_nhlfe *pnhlfe = _mpls_as_nhlfe(parent);
+		pnhlfe->nhlfe_mtu = min_mtu - (4 * (*num_push));
+		pnhlfe->nhlfe_mtu_limit = pnhlfe->nhlfe_mtu;
+	}
+	*data = (void*)efi;
+	*last_able = 1;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_exp_fwd) 
+{
+	struct mpls_exp_fwd_info *efi;
+	struct mpls_nhlfe *nhlfe;
+	unsigned int key;
+	int j;
+
+	MPLS_ENTER;
+	
+	efi = _mpls_as_efi(data);
+
+	for(j=0;j<MPLS_EXP_NUM;j++) {
+		nhlfe = efi->efi_nhlfe[j];
+
+		key = (nhlfe) ? nhlfe->nhlfe_key : 0;
+		instr->mir_exp_fwd.ef_key[j] = key;
+	}
+
+	MPLS_EXIT;
+	return 0;
+}
+
+
+MPLS_CLEAN_OPCODE_PROTOTYPE(mpls_clean_opcode_exp_fwd) 
+{
+	int i;
+	struct mpls_exp_fwd_info *efi = NULL;
+	
+	efi = _mpls_as_efi(data);
+
+	/* Release all NHLFEs held in efi (data) */
+	for (i=0;i<MPLS_EXP_NUM;i++) 
+		mpls_nhlfe_release_safe(efi->efi_nhlfe[i]);
+
+	/* Free the EFI (data) */
+	kfree(efi);
+}
+
+
+/*********************************************************************
+ * MPLS_OP_SET_RX
+ * DESC   : "Artificially change the incoming network device"
+ * EXEC   : mpls_in_op_set_rx
+ * BUILD  : mpls_build_opcode_set_rx
+ * UNBUILD: mpls_unbuild_opcode_set_rx
+ * CLEAN  : mpls_clean_opcode_set_rx
+ * INPUT  : true 
+ * OUTPUT : false 
+ * DATA   : Reference to a net_device (struct net_device*)
+ * LAST   : false
+ * 
+ * Remark : If the interface goes down/unregistered, mpls_netdev_event
+ *          (cf. mpls_init.c) will change this opcode.
+ *********************************************************************/
+
+MPLS_IN_OPCODE_PROTOTYPE(mpls_in_op_set_rx)
+{
+	/* 
+	 * Change the incoming net_device for the socket buffer
+	 */
+	(*skb)->dev = (struct net_device*)data;
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+/* 
+ * Changes: 
+ *	20040120 RCAS: The device must be MPLS enabled (mpls_ptr != NULL)
+ *		and its labelspace != -1
+ */
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_set_rx) 
+{
+	struct mpls_interface *mpls_if = NULL; 
+	struct mpls_ilm       *pilm    = NULL; 
+	struct net_device     *dev     = NULL;
+	unsigned int if_index          = 0; /* Incoming If Index */
+
+	MPLS_ENTER;
+	*data = NULL;
+	if (direction != MPLS_IN) {
+		MPLS_DEBUG("SET_RX only valid for incoming labels\n");
+		MPLS_EXIT;
+		return -EINVAL;
+	}
+
+	pilm = _mpls_as_ilm(parent);
+	/*
+	 * Get a reference to the device given the interface index
+	 */
+	
+	if_index = instr->mir_set_rx;
+	dev = dev_get_by_index(&init_net, if_index);
+	if (unlikely(!dev)) {
+		MPLS_DEBUG("SET_RX if_index %d unknown\n", if_index);
+		MPLS_EXIT;
+		return -ESRCH;
+	}
+
+	/*
+	 * Check Interface to see if its MPLS enabled
+	 */
+	mpls_if = dev->mpls_ptr;
+
+	if ( (!mpls_if) || (mpls_if->labelspace == -1)) {
+		MPLS_DEBUG("SET_RX if_index %d MPLS disabled\n", if_index);
+		dev_put (dev);
+		MPLS_EXIT;
+		return -ESRCH;
+	}
+	
+	*data = (void*)dev;
+
+	/* 
+	 * Add to the device list of ILMs (list_in) 
+	 * NOTE: we're still holding a ref to dev.
+	 * 
+	 */
+	list_add(&pilm->dev_entry, &(mpls_if->list_in));
+	MPLS_EXIT;
+	return 0;
+}
+
+/* Get the ifIndex of the device and returns it */
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_set_rx)
+{
+	struct net_device *dev;
+
+	MPLS_ENTER;
+	dev = _mpls_as_netdev(data);
+	instr->mir_set_rx = dev->ifindex;
+	MPLS_EXIT;
+	return 0;
+}
+
+MPLS_CLEAN_OPCODE_PROTOTYPE(mpls_clean_opcode_set_rx) 
+{
+	struct net_device *dev   = NULL;
+	/* dev is already being held */
+	dev = _mpls_as_netdev(data); 
+	mpls_list_del_init(& _mpls_as_ilm(parent)->dev_entry);
+	dev_put(dev);
+}
+
+
+
+/*********************************************************************
+ * MPLS_OP_SET
+ * DESC   : "Define the outgoing interface and next hop"
+ * EXEC   : mpls_out_op_set
+ * BUILD  : mpls_build_opcode_set
+ * UNBUILD: mpls_unbuild_opcode_set
+ * CLEAN  : mpls_clean_opcode_set
+ * INPUT  : false 
+ * OUTPUT : true 
+ * DATA   : Reference to MPLS destination cache entry (struct mpls_dst*) 
+ * LAST   : true 
+ * 
+ * Remark : If the interface goes down/unregistered, mpls_netdev_event
+ *          (cf. mpls_init.c) will change this opcode.
+ *********************************************************************/
+ 
+MPLS_OUT_OPCODE_PROTOTYPE(mpls_out_op_set)
+{
+	struct mpls_dst *md = data;
+
+	MPLS_ENTER;
+
+	/* Release the current dst in the socket buffer */
+	if ((*skb)->dst) {
+		dst_release((*skb)->dst);
+	}
+
+	/*
+	 * Update the dst field of the skbuffer in "real time" 
+	 */
+	dst_hold(&md->u.dst);
+	(*skb)->dst = &md->u.dst;
+	
+
+	/* don't hold the dev we place in skb->dev, the dst is already */
+	/* holding it for us */
+
+	(*skb)->dev = md->u.dst.dev;
+
+	MPLS_EXIT;
+
+	return MPLS_RESULT_SUCCESS;
+}
+
+/*
+ * RCAS: I don't think that allocing a mpls_ptr here is a good idea. If the 
+ * mpls_ptr is NULL, this function should return an error.
+ *
+ * JLEU: Are there cases where we do not want to assign a labelspace (which
+ * creates the mpls_ptr) and still originate MPLS traffic?
+ *
+ * Changes: 
+ *	20040120 RCAS: The device must be MPLS enabled (mpls_ptr != NULL)
+ *		and its labelspace != -1
+ */
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_set) 
+{
+	struct mpls_interface *mpls_if = NULL; 
+	struct mpls_nhlfe  *pnhlfe    = NULL; 
+	struct net_device     *dev     = NULL;
+	struct mpls_dst       *md      = NULL;
+	unsigned int if_index          = 0; /* Outgoing interface index */
+
+	MPLS_ENTER;
+
+	*data = NULL;
+	if (direction != MPLS_OUT) {
+		MPLS_DEBUG("SET only valid for outgoing labels\n");
+		MPLS_EXIT;
+		return -EINVAL;
+	}
+
+	if_index = instr->mir_set.mni_if;
+	dev = dev_get_by_index(&init_net, if_index);
+	
+	if (unlikely(!dev)) {
+		MPLS_DEBUG("SET if_index %d unknown\n", if_index);
+		MPLS_EXIT;
+		return -ESRCH;
+	}
+
+	mpls_if = dev->mpls_ptr;
+	if (!mpls_if) {
+		mpls_if = mpls_create_if_info();
+		dev->mpls_ptr = mpls_if;
+		if (unlikely(!mpls_if)) {
+			dev_put(dev);
+			MPLS_DEBUG("SET error building MPLS IF info\n");
+			MPLS_EXIT;
+			return -ENOMEM;
+		}
+	}
+
+	/* 
+	 * This opcode will use the passed NHLFE 
+	 */
+	pnhlfe = _mpls_as_nhlfe(parent);
+	WARN_ON(!pnhlfe);
+	
+	/* 
+	 * NOTE: mpls_dst_alloc holds the dev,
+	 * so release the hold from dev lookup
+	 * mpls_dst_alloc calls dst_hold
+	 */
+	md = mpls_dst_alloc(dev, &instr->mir_set.mni_addr);
+	dev_put(dev);
+
+	if (unlikely(!md)) {
+		MPLS_DEBUG("SET error building DST info\n");
+		*data = NULL;
+		MPLS_EXIT;
+		return -ENOMEM;
+	}
+
+
+	/* 
+	 * Update the NHLFE MTU according to the number of pushes. 
+	 */
+	pnhlfe->nhlfe_mtu = dev->mtu - (4 * (*num_push));
+	pnhlfe->nhlfe_mtu_limit = pnhlfe->nhlfe_mtu;
+
+	/* 
+	 * Add to the device list of NHLFEs (list_out) 
+	 * 
+	 */
+	list_add(&pnhlfe->dev_entry, &mpls_if->list_out);
+	*data      = (void*)md;
+	*last_able = 1;
+	MPLS_EXIT;
+	return 0;
+}
+
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_set)
+{
+        struct mpls_dst *md;
+
+        MPLS_ENTER;
+
+	md = data;
+        memcpy(&instr->mir_set.mni_addr, &md->md_nh, sizeof(struct sockaddr));
+        instr->mir_set.mni_if = md->u.dst.dev->ifindex;
+
+        MPLS_EXIT;
+
+        return 0;
+}
+
+
+
+/*
+ *	Clean tasks: 
+ *	- release the mpls_dst (opcode data)
+ *	- remove this nhlfe from the device's list.
+ * 	JLEU: hold device so mpls_dst_release doesn't delete it 
+ *	RCAS: Why do we need to hold the dev ? 
+ */
+MPLS_CLEAN_OPCODE_PROTOTYPE(mpls_clean_opcode_set) 
+{
+	struct mpls_dst   *mdst  = data;
+	struct net_device *dev   = NULL;
+
+	MPLS_ENTER;
+	dev  = mdst->u.dst.dev;
+	dev_hold(dev);
+	mpls_dst_release (mdst);
+	mpls_list_del_init (&_mpls_as_nhlfe(parent)->dev_entry);
+	dev_put(dev);
+	MPLS_EXIT;
+}
+
+
+/*********************************************************************
+ * MPLS_OP_SET_TC
+ * DESC   : "Define the socket buffer (IN/OUT) tc index" 
+ * EXEC   : mpls_out_op_set_tc
+ * BUILD  : mpls_build_opcode_set_tc
+ * UNBUILD: mpls_unbuild_opcode_set_tc
+ * CLEAN  : mpls_clean_opcode_generic 
+ * INPUT  : true 
+ * OUTPUT : true 
+ * DATA   : TC index to apply to skb. (unsigned short *) 
+ * LAST   : false 
+ *********************************************************************/
+#ifdef CONFIG_NET_SCHED
+MPLS_OPCODE_PROTOTYPE(mpls_op_set_tc)
+{
+	unsigned short *tc = NULL;
+	tc = data;
+	(*skb)->tc_index = *tc;
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_set_tc) 
+{
+	unsigned short *tc = NULL;
+
+	*data = NULL;
+	tc = kmalloc(sizeof(*tc),GFP_ATOMIC);
+	if (unlikely(!tc)) {
+		MPLS_DEBUG("SET_TC error building TC info\n");
+		return -ENOMEM;
+	}
+	*tc   = instr->mir_set_tc;
+	*data = (void*)tc;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_set_tc)
+{
+	MPLS_ENTER;
+	instr->mir_set_tc = *(unsigned short *)data;
+	MPLS_EXIT;
+	return 0;
+}
+#endif
+
+
+
+
+/*********************************************************************
+ * MPLS_OP_SET_DS
+ * DESC   : "Changes the DS field of the IPv4/IPv6 packet"
+ * EXEC   : mpls_in_op_set_ds
+ * BUILD  : mpls_build_opcode_set_ds
+ * UNBUILD: mpls_unbuild_opcode_set_ds
+ * CLEAN  : mpls_clean_opcode_generic 
+ * INPUT  : true 
+ * OUTPUT : false 
+ * DATA   : DS field (unsigned short *) 
+ * LAST   : false 
+ *********************************************************************/
+#ifdef CONFIG_NET_SCHED
+
+MPLS_IN_OPCODE_PROTOTYPE(mpls_in_op_set_ds)
+{
+	unsigned short *ds = data;
+
+	if (!MPLSCB(*skb)->bos) {
+		MPLS_DEBUG("SET_DS and not BOS\n");
+		return MPLS_RESULT_DROP;
+	}
+	MPLSCB(*skb)->prot->change_dsfield(*skb, (*ds));
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_set_ds) 
+{
+	unsigned char  *ds = NULL;
+	*data = NULL;
+	ds = kmalloc(sizeof(*ds),GFP_ATOMIC);
+	if (unlikely(!ds)) {
+		MPLS_DEBUG("SET_DS error building DS info\n");
+		return -ENOMEM;
+	}
+	*ds = instr->mir_set_ds;
+	if (*ds > 0x3f) {
+		MPLS_DEBUG("SET_DS DS(%02x) too big\n",*ds);
+		return -EINVAL;
+	}
+	*data = (void*)ds;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_set_ds)
+{
+	MPLS_ENTER;
+	instr->mir_set_ds = *(unsigned short *)data;
+	MPLS_EXIT;
+	return 0;
+}
+#endif
+
+
+
+/*********************************************************************
+ * MPLS_OP_SET_EXP
+ * DESC   : "Changes the 3 EXP bits of the label entry"
+ * EXEC   : mpls_op_set_exp
+ * BUILD  : mpls_build_opcode_set_exp
+ * UNBUILD: mpls_unbuild_opcode_set_exp
+ * CLEAN  : mpls_clean_opcode_generic 
+ * INPUT  : true 
+ * OUTPUT : true 
+ * DATA   : EXP value (binary 000-111) (unsigned char *) 
+ * LAST   : false 
+ *********************************************************************/
+
+MPLS_OPCODE_PROTOTYPE(mpls_op_set_exp)
+{
+	unsigned char *exp = data;
+	MPLSCB(*skb)->exp = *exp;
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_set_exp) 
+{
+	unsigned char  *exp = NULL;
+	*data = NULL;
+	exp = kmalloc(sizeof(*exp),GFP_ATOMIC);
+	if (unlikely(!exp)) {
+		MPLS_DEBUG("SET_EXP error building EXP info\n");
+		return -ENOMEM;
+	}
+	*exp = instr->mir_set_exp;
+	if (*exp >= MPLS_EXP_NUM) {
+		MPLS_DEBUG("SET_EXP EXP(%d) too big\n",*exp);
+		kfree(exp);
+		return -EINVAL;
+	}
+	*data = (void*)exp;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_set_exp)
+{
+	MPLS_ENTER;
+	instr->mir_set_exp = *(unsigned char *)data;
+	MPLS_EXIT;
+	return 0;
+}
+
+
+
+/*********************************************************************
+ * MPLS_OP_EXP2TC
+ * DESC   : "Changes the TC index of the socket buffer according to"
+ *          "the EXP bits in label entry"
+ * EXEC   : mpls_op_exp2tc
+ * BUILD  : mpls_build_opcode_exp2tc
+ * UNBUILD: mpls_unbuild_opcode_exp2tc
+ * CLEAN  : mpls_clean_opcode_generic 
+ * INPUT  : true 
+ * OUTPUT : true 
+ * DATA   : e2ti (struct mpls_exp2tcindex_info*) - No ILM/NHLFE are held. 
+ * LAST   : false 
+ *********************************************************************/
+
+#ifdef CONFIG_NET_SCHED
+
+MPLS_OPCODE_PROTOTYPE(mpls_op_exp2tc)
+{
+	struct mpls_exp2tcindex_info *e2ti = NULL;
+
+	BUG_ON(!data);
+	BUG_ON(!(*skb));
+	e2ti = data;
+	if (e2ti->e2t[MPLSCB(*skb)->exp & 0x7] != 0xffff) {
+		(*skb)->tc_index = e2ti->e2t[MPLSCB(*skb)->exp & 0x7];
+	}
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_exp2tc) 
+{
+	struct mpls_exp2tcindex_info *e2ti = NULL;
+	int j;
+
+	*data = NULL;
+	/*
+	 * Allocate e2ti object 
+	 */
+	e2ti = kmalloc(sizeof(*e2ti),GFP_ATOMIC);
+	if (unlikely(!e2ti)) {
+		MPLS_DEBUG("EXP2TC error building TC info\n");
+		return -ENOMEM;
+	}
+	/*
+	 * Define (as per instruction) how to map EXP values
+	 * to TC indexes
+	 */
+	for (j = 0;j<MPLS_EXP_NUM; j++) {
+		e2ti->e2t[j] = instr->mir_exp2tc.e2t[j];
+	}
+
+	*data = (void*)e2ti;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_exp2tc)
+{
+	struct mpls_exp2tcindex_info *e2ti = data;
+	int j;
+
+	MPLS_ENTER;
+
+	for(j=0;j<MPLS_EXP_NUM;j++) {
+		instr->mir_exp2tc.e2t[j] = e2ti->e2t[j];
+	}
+
+	MPLS_EXIT;
+	return 0;
+}
+#endif
+
+
+
+
+
+
+/*********************************************************************
+ * MPLS_OP_EXP2DS
+ * DESC   : "Changes the DS field of the IPv4/IPv6 packet according to"
+ *          "the EXP bits in label entry"
+ * EXEC   : mpls_op_exp2ds
+ * BUILD  : mpls_build_opcode_exp2ds
+ * UNBUILD: mpls_unbuild_opcode_exp2ds
+ * CLEAN  : mpls_clean_opcode_generic 
+ * INPUT  : true 
+ * OUTPUT : false 
+ * DATA   : e2di (struct mpls_exp2dsmark_info*) - No ILM/NHLFE are held. 
+ * LAST   : false 
+ *********************************************************************/
+MPLS_IN_OPCODE_PROTOTYPE(mpls_in_op_exp2ds)
+{
+	struct mpls_exp2dsmark_info *e2di = data;
+
+	if (e2di->e2d[MPLSCB(*skb)->exp & 0x7] == 0xff)
+		return MPLS_RESULT_SUCCESS;
+
+	MPLSCB(*skb)->prot->change_dsfield(*skb, e2di->e2d[MPLSCB(*skb)->exp & 0x7]);
+
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_exp2ds) 
+{
+	struct mpls_exp2dsmark_info *e2di  = NULL;
+	int j;
+
+	*data = NULL;
+	/*
+	 * Allocate e2di object 
+	 */
+	e2di = kmalloc(sizeof(*e2di),GFP_ATOMIC);
+	if (unlikely(!e2di)) {
+		MPLS_DEBUG("error building DSMARK info\n");
+		return -ENOMEM;
+	}
+
+	/*
+	 * Define (as per instruction) how to map EXP values
+	 * to DS fields. 
+	 */
+	for (j = 0; j<MPLS_EXP_NUM; j++) {
+		e2di->e2d[j] = instr->mir_exp2ds.e2d[j];
+	}
+	*data = (void*)e2di;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_exp2ds)
+{
+	struct mpls_exp2dsmark_info *e2di = data;
+	int j;
+
+	MPLS_ENTER;
+
+	for(j=0;j<MPLS_EXP_NUM;j++) {
+		instr->mir_exp2ds.e2d[j] = e2di->e2d[j];
+	}
+
+	MPLS_EXIT;
+	return 0;
+}
+
+
+/*********************************************************************
+ * MPLS_OP_TC2EXP
+ * DESC   : "Changes the EXP bits of the topmost label entry according"
+ *          "to the TC index in skb & mask"
+ * EXEC   : mpls_op_tc2exp
+ * BUILD  : mpls_build_opcode_tc2exp
+ * UNBUILD: mpls_unbuild_opcode_tc2exp
+ * CLEAN  : mpls_clean_opcode_generic 
+ * INPUT  : false 
+ * OUTPUT : true 
+ * DATA   : t2ei (struct mpls_tcindex2exp_info*) - No ILM/NHLFE are held. 
+ * LAST   : false 
+ *********************************************************************/
+#ifdef CONFIG_NET_SCHED
+
+MPLS_OUT_OPCODE_PROTOTYPE(mpls_out_op_tc2exp)
+{
+	struct mpls_tcindex2exp_info *t2ei = data;
+	unsigned short tc;
+
+	tc = (*skb)->tc_index & t2ei->t2e_mask;
+	if (t2ei->t2e[tc] != 0xFF) {
+		MPLSCB(*skb)->exp = t2ei->t2e[tc];
+	}
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_tc2exp) 
+{
+	struct mpls_tcindex2exp_info *t2ei = NULL;
+	int j;
+
+	*data = NULL;
+	/*
+	 * Allocate t2ei object 
+	 */
+	t2ei = kmalloc(sizeof(*t2ei),GFP_ATOMIC);
+	if (unlikely(!t2ei)) {
+		MPLS_DEBUG("TC2EXP error building EXP info\n");
+		return -ENOMEM;
+	}
+	
+	/*
+	 * Define (as per instruction) the mask to apply
+	 */
+	t2ei->t2e_mask = instr->mir_tc2exp.t2e_mask;
+	if (t2ei->t2e_mask >= MPLS_TCINDEX_NUM) {
+		MPLS_DEBUG("TC2EXP mask(%02x) too large\n", t2ei->t2e_mask);
+		kfree (t2ei);
+		return -EINVAL;
+	}
+
+	/*
+	 * Define (as per instruction) how to map TC indexes
+	 * to EXP bits 
+	 */
+	for (j = 0; j<MPLS_TCINDEX_NUM; j++) {
+		t2ei->t2e[j] = instr->mir_tc2exp.t2e[j];
+	}
+	*data = (void*)t2ei;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_tc2exp) 
+{
+	struct mpls_tcindex2exp_info *t2ei = data;
+	int j;
+
+	MPLS_ENTER;
+
+	instr->mir_tc2exp.t2e_mask = t2ei->t2e_mask;
+
+	for (j=0;j<MPLS_TCINDEX_NUM;j++) {
+		instr->mir_tc2exp.t2e[j] = t2ei->t2e[j];
+	}
+
+	MPLS_EXIT;
+	return 0;
+}
+#endif
+
+
+
+/*********************************************************************
+ * MPLS_OP_DS2EXP
+ * DESC   : "Changes the EXP bits of the topmost label entry according"
+ *          "to the DS field of the IPv4/IPv6 packet"
+ * EXEC   : mpls_op_ds2exp
+ * BUILD  : mpls_build_opcode_ds2exp
+ * UNBUILD: mpls_unbuild_opcode_ds2exp
+ * CLEAN  : mpls_clean_opcode_generic 
+ * INPUT  : false 
+ * OUTPUT : true 
+ * DATA   : d2ei (struct mpls_dsmark2exp_info*) - No ILM/NHLFE are held. 
+ * LAST   : false 
+ *********************************************************************/
+MPLS_OUT_OPCODE_PROTOTYPE(mpls_out_op_ds2exp)
+{
+	struct mpls_dsmark2exp_info *d2ei = data;
+	unsigned char ds;
+
+	ds = MPLSCB(*skb)->prot->get_dsfield(*skb);
+
+	if (d2ei->d2e[ds] != 0xFF) {
+		MPLSCB(*skb)->exp = d2ei->d2e[ds];
+	}
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_ds2exp) 
+{
+	struct mpls_dsmark2exp_info *d2ei  = NULL;
+	int j;
+
+	*data = NULL;
+	/*
+	 * Allocate d2ei object 
+	 */
+	d2ei = kmalloc(sizeof(*d2ei),GFP_ATOMIC);
+	if (unlikely(!d2ei)) {
+		MPLS_DEBUG("DS2EXP error building EXP info\n");
+		return -ENOMEM;
+	}
+
+	/*
+	 * Define (as per instruction) the mask to apply
+	 */
+	d2ei->d2e_mask = instr->mir_ds2exp.d2e_mask;
+	if (d2ei->d2e_mask >= MPLS_DSMARK_NUM) {
+		MPLS_DEBUG("DS2EXP mask(%02x) too large\n", d2ei->d2e_mask);
+		kfree(d2ei);
+		return -EINVAL;
+	}
+
+	/*
+	 * Define (as per instruction) how to map DS marks 
+	 * to EXP bits 
+	 */
+	for (j = 0; j<MPLS_DSMARK_NUM; j++) {
+		d2ei->d2e[j] = instr->mir_ds2exp.d2e[j];
+	}
+	*data = (void*)d2ei;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_ds2exp) 
+{
+	struct mpls_dsmark2exp_info *d2ei = data;
+	int j;
+
+	MPLS_ENTER;
+
+	instr->mir_ds2exp.d2e_mask = d2ei->d2e_mask;
+
+	for (j=0;j<MPLS_DSMARK_NUM;j++) {
+		instr->mir_ds2exp.d2e[j] = d2ei->d2e[j];
+	}
+
+	MPLS_EXIT;
+	return 0;
+}
+
+
+
+
+
+/*********************************************************************
+ * MPLS_OP_NF2EXP
+ * DESC   : "Changes the EXP bits of the topmost label entry according"
+ *          "to the NF mark of the socket buffer". 
+ * EXEC   : mpls_op_nf2exp
+ * BUILD  : mpls_build_opcode_nf2exp
+ * UNBUILD: mpls_build_opcode_nf2exp
+ * CLEAN  : mpls_clean_opcode_generic 
+ * INPUT  : false 
+ * OUTPUT : true 
+ * DATA   : n2ei (struct mpls_nfmark2exp_info*) - No ILM/NHLFE are held. 
+ * LAST   : false 
+ *********************************************************************/
+
+#ifdef CONFIG_NETFILTER
+MPLS_OUT_OPCODE_PROTOTYPE(mpls_out_op_nf2exp)
+{
+	struct mpls_nfmark2exp_info *n2ei = NULL;
+	unsigned short nf = 0;
+
+	BUG_ON(NULL == data);
+	BUG_ON(NULL == *skb);
+	n2ei = data;
+	nf   = (*skb)->mark & n2ei->n2e_mask;
+	if (n2ei->n2e[nf] != 0xFF) {
+		MPLSCB(*skb)->exp = n2ei->n2e[nf];
+	}
+
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_nf2exp)
+{
+	struct mpls_nfmark2exp_info *n2ei  = NULL;
+	int j;
+
+	*data = NULL;
+	/*
+	 * Allocate d2ei object 
+	 */
+	n2ei = kmalloc(sizeof(*n2ei),GFP_ATOMIC);
+	if(unlikely(!n2ei)) {
+		MPLS_DEBUG("NF2EXP error building EXP info\n");
+		return -ENOMEM;
+	}
+
+	/*
+	 * Define (as per instruction) the mask to apply
+	 */
+	n2ei->n2e_mask = instr->mir_nf2exp.n2e_mask;
+	if (n2ei->n2e_mask >= MPLS_NFMARK_NUM) {
+		MPLS_DEBUG("NF2EXP mask(%02x) too large\n", n2ei->n2e_mask);
+		kfree(n2ei);
+		return -EINVAL;
+	}
+
+	/*
+	 * Define (as per instruction) how to map NF marks 
+	 * to EXP bits 
+	 */
+	for (j = 0; j<MPLS_NFMARK_NUM; j++) {
+		n2ei->n2e[j] = instr->mir_nf2exp.n2e[j];
+	}
+	*data = (void*)n2ei;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_nf2exp)
+{
+	struct mpls_nfmark2exp_info *n2ei = data;
+	int j;
+
+	MPLS_ENTER;
+
+	instr->mir_nf2exp.n2e_mask = n2ei->n2e_mask;
+
+	for(j=0;j<MPLS_NFMARK_NUM;j++) {
+		instr->mir_nf2exp.n2e[j] = n2ei->n2e[j];
+	}
+
+	MPLS_EXIT;
+	return 0;
+}
+
+#endif
+
+
+
+
+
+
+
+
+/*********************************************************************
+ * Main data type to hold metainformation on opcodes
+ * IN      : Function pointer to execute in ILM object
+ * OUT     : Function pointer to execute in NHLFE object
+ * BUILD   : Function pointer to build the opcode 
+ * CLEANUP : Function pointer to clean the opcode 
+ * EXTRA   : Ready to transmit (SET)
+ * MSG     : Human readable format
+ *********************************************************************/
+
+struct mpls_ops mpls_ops[MPLS_OP_MAX] = {
+	[MPLS_OP_NOP] = {
+		.in      = mpls_op_nop,
+		.out     = mpls_op_nop,
+		.build   = NULL,
+		.unbuild = NULL,
+		.cleanup = NULL,
+		.extra   = 0,
+		.msg     = "NOP",
+	},
+	[MPLS_OP_POP] = {
+		.in      = mpls_in_op_pop,
+		.out     = NULL,
+		.build   = mpls_build_opcode_pop,
+		.unbuild = NULL,
+		.cleanup = NULL,
+		.extra   = 0,
+		.msg     = "POP",
+	},
+	[MPLS_OP_PEEK] = {
+		.in      = mpls_in_op_peek,
+		.out     = NULL,
+		.build   = mpls_build_opcode_peek,
+		.unbuild = NULL,
+		.cleanup = NULL,
+		.extra   = 0,
+		.msg     = "PEEK",
+	},
+	[MPLS_OP_PUSH] = {
+		.in      = mpls_op_push,
+		.out     = mpls_op_push,
+		.build   = mpls_build_opcode_push,
+		.unbuild = mpls_unbuild_opcode_push,
+		.cleanup = mpls_clean_opcode_push,
+		.extra   = 0,
+		.msg     = "PUSH",
+	},
+	[MPLS_OP_DLV] = {
+		.in      = mpls_in_op_dlv,
+		.out     = NULL,
+		.build   = mpls_build_opcode_dlv,
+		.unbuild = NULL,
+		.cleanup = NULL,
+		.extra   = 0,
+		.msg     = "DLV",
+	},
+	[MPLS_OP_FWD] = {
+		.in      = mpls_op_fwd,
+		.out     = mpls_op_fwd,
+		.build   = mpls_build_opcode_fwd,
+		.unbuild = mpls_unbuild_opcode_fwd,
+		.cleanup = mpls_clean_opcode_fwd,
+		.extra   = 0,
+		.msg     = "FWD",
+	},
+#ifdef CONFIG_NETFILTER
+	[MPLS_OP_NF_FWD] = {
+		.in      = NULL,
+		.out     = mpls_out_op_nf_fwd,
+		.build   = mpls_build_opcode_nf_fwd,
+		.unbuild = mpls_unbuild_opcode_nf_fwd,
+		.cleanup = mpls_clean_opcode_nf_fwd,
+		.extra   = 0,
+		.msg     = "NF_FWD",
+	},
+#endif
+	[MPLS_OP_DS_FWD] = {
+		.in      = NULL,
+		.out     = mpls_out_op_ds_fwd,
+		.build   = mpls_build_opcode_ds_fwd,
+		.unbuild = mpls_unbuild_opcode_ds_fwd,
+		.cleanup = mpls_clean_opcode_ds_fwd,
+		.extra   = 0,
+		.msg     = "DS_FWD",
+	},
+	[MPLS_OP_EXP_FWD] = {
+		.in      = mpls_op_exp_fwd,
+		.out     = mpls_op_exp_fwd,
+		.build   = mpls_build_opcode_exp_fwd,
+		.unbuild = mpls_unbuild_opcode_exp_fwd,
+		.cleanup = mpls_clean_opcode_exp_fwd,
+		.extra   = 0,
+		.msg     = "EXP_FWD",
+	},
+	[MPLS_OP_SET_RX] = {
+		.in      = mpls_in_op_set_rx,
+		.out     = NULL,
+		.build   = mpls_build_opcode_set_rx,
+		.unbuild = mpls_unbuild_opcode_set_rx,
+		.cleanup = mpls_clean_opcode_set_rx,
+		.extra   = 0,
+		.msg     = "SET_RX",
+	},
+	[MPLS_OP_SET] = {
+		.in      = NULL,
+		.out     = mpls_out_op_set,
+		.build   = mpls_build_opcode_set,
+		.unbuild = mpls_unbuild_opcode_set,
+		.cleanup = mpls_clean_opcode_set,
+		.extra   = 1,
+		.msg     = "SET",
+	},
+#ifdef CONFIG_NET_SCHED
+	[MPLS_OP_SET_TC] = {
+		.in      = mpls_op_set_tc,
+		.out     = mpls_op_set_tc,
+		.build   = mpls_build_opcode_set_tc,
+		.unbuild = mpls_unbuild_opcode_set_tc,
+		.cleanup = mpls_clean_opcode_generic,
+		.extra   = 0,
+		.msg     = "SET_TC",
+	},
+	[MPLS_OP_SET_DS] = {
+		.in      = mpls_in_op_set_ds,
+		.out     = NULL,
+		.build   = mpls_build_opcode_set_ds,
+		.unbuild = mpls_unbuild_opcode_set_ds,
+		.cleanup = mpls_clean_opcode_generic,
+		.extra   = 0,
+		.msg     = "SET_DS",
+	},
+#endif
+	[MPLS_OP_SET_EXP] = {
+		.in      = mpls_op_set_exp,
+		.out     = mpls_op_set_exp,
+		.build   = mpls_build_opcode_set_exp,
+		.unbuild = mpls_unbuild_opcode_set_exp,
+		.cleanup = mpls_clean_opcode_generic,
+		.extra   = 0,
+		.msg     = "SET_EXP",
+	},
+#ifdef CONFIG_NET_SCHED
+	[MPLS_OP_EXP2TC] = {
+		.in      = mpls_op_exp2tc,
+		.out     = mpls_op_exp2tc,
+		.build   = mpls_build_opcode_exp2tc,
+		.unbuild = mpls_unbuild_opcode_exp2tc,
+		.cleanup = mpls_clean_opcode_generic,
+		.extra   = 0,
+		.msg     = "EXP2TC",
+	},
+#endif
+	[MPLS_OP_EXP2DS] = {
+		.in      = mpls_in_op_exp2ds,
+		.out     = NULL,
+		.build   = mpls_build_opcode_exp2ds,
+		.unbuild = mpls_unbuild_opcode_exp2ds,
+		.cleanup = mpls_clean_opcode_generic,
+		.extra   = 0,
+		.msg     = "EXP2DS",
+	},
+#ifdef CONFIG_NET_SCHED
+	[MPLS_OP_TC2EXP] = {
+		.in      = NULL,
+		.out     = mpls_out_op_tc2exp,
+		.build   = mpls_build_opcode_tc2exp,
+		.unbuild = mpls_unbuild_opcode_tc2exp,
+		.cleanup = mpls_clean_opcode_generic,
+		.extra   = 0,
+		.msg     = "TC2EXP",
+	},
+#endif
+	[MPLS_OP_DS2EXP] = {
+		.in      = NULL,
+		.out     = mpls_out_op_ds2exp,
+		.build   = mpls_build_opcode_ds2exp,
+		.unbuild = mpls_unbuild_opcode_ds2exp,
+		.cleanup = mpls_clean_opcode_generic,
+		.extra   = 0,
+		.msg     = "DS2EXP",
+	},
+#ifdef CONFIG_NETFILTER
+	[MPLS_OP_NF2EXP] = {
+		.in      = NULL,
+		.out     = mpls_out_op_nf2exp,
+		.build   = mpls_build_opcode_nf2exp,
+		.unbuild = mpls_unbuild_opcode_nf2exp,
+		.cleanup = mpls_clean_opcode_generic,
+		.extra   = 0,
+		.msg     = "NF2EXP",
+	},
+#endif
+};
diff -Naur linux-kernel-rpm-f8/net/mpls/mpls_output.c mpls-kernel-rpm-f8_modified/net/mpls/mpls_output.c
--- linux-kernel-rpm-f8/net/mpls/mpls_output.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/mpls/mpls_output.c	2008-10-17 09:45:02.000000000 +0200
@@ -0,0 +1,381 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *          James Leu        <jleu@mindspring.com>
+ *          Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu        <jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ ****************************************************************************/
+
+#include <linux/autoconf.h>
+#include <net/ip.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <net/dst.h>
+#include <net/ip_fib.h>
+#include <net/mpls.h>
+#include <linux/ip.h>
+#include <net/dsfield.h>
+
+/**
+ *	mpls_send - Send a labelled packet.
+ *	@skb: Ready to go socket buffer.
+ *	@mtu: MTU of the NHLFE that got us here.
+ *
+ *	Send the socket buffer to the next hop. It assumes that everything has
+ *	been properly set up. In order to forward/send the packet, there are two 
+ *	methods, using either:
+ *	a) hh->hh_output(skb);
+ *	b) skb->dst->neighbour->output(skb);
+ *
+ *	Please note that this function is only called from mpls_output2, and  
+ *	even in the case of a transmission error, the sbk is not freed (it will 
+ *	be freed by the caller).
+ *	Returns: MPLS_RESULT_SUCCESS or MPLS_RESULT_DROP
+ **/
+
+static int 
+mpls_send (struct sk_buff *skb, int mtu) 
+{
+#ifdef HH_DOES_NOT_HAVE_L3_HEAD
+	struct hh_cache *hh = NULL;
+#endif
+	int retval = MPLS_RESULT_SUCCESS;
+	struct mpls_prot_driver *prot = MPLSCB(skb)->prot;
+
+	if (MPLSCB(skb)->popped_bos) {
+		if (MPLSCB(skb)->ttl < MPLSCB(skb)->prot->get_ttl(skb)) {
+			prot->set_ttl(skb, MPLSCB(skb)->ttl);
+		}
+		switch(prot->family) {
+			case AF_INET:
+				skb->protocol = htons(ETH_P_IP);
+				break;
+			case AF_INET6:
+				skb->protocol = htons(ETH_P_IPV6);
+				break;
+			case AF_PACKET:
+				skb->protocol = 0;
+				skb->mac_header = skb->network_header;
+				break;
+			default:
+				MPLS_ASSERT(0);
+		}
+	} else {
+		skb->protocol = htons(ETH_P_MPLS_UC);
+	}
+
+	MPLS_DEBUG("output device = %s\n",skb->dev->name);
+
+#ifdef WE_NEED_TO_FIX_HH_HEADER_BEFORE_SENDING
+	mpls_finish(skb);
+#endif
+	MPLS_DEBUG_CALL(mpls_skb_dump(skb));
+
+	if (skb->len > skb->dst->dev->mtu) {
+
+		printk("MPLS: packet exceeded MTU %d > %d (%d)\n", skb->len,
+		    skb->dev->mtu, mtu);
+
+		retval = prot->mtu_exceeded(&skb, mtu);
+
+		if (retval)
+			goto mpls_send_exit;
+
+		/* otherwise prot->mtu_exceeded() has returned a
+		 * modified skb that it wants to be forwarded
+		 * down the LSP
+		 */
+	}
+
+        if (unlikely(skb->protocol &&
+		(skb_headroom(skb) < LL_RESERVED_SPACE(skb->dst->dev)) &&
+		skb->dst->dev->header_ops)) {
+		struct sk_buff *skb2;
+
+		MPLS_DEBUG("alloc'ing more headroom\n");
+		if (!(skb2 = skb_realloc_headroom(skb,
+			LL_RESERVED_SPACE(skb->dst->dev)))) {
+			retval = MPLS_RESULT_DROP;
+			goto mpls_send_exit;
+                }
+		if (skb->sk)
+			skb_set_owner_w(skb2, skb->sk);
+		kfree_skb(skb);
+		skb = skb2;
+        }
+
+#ifdef HH_DOES_NOT_HAVE_L3_HEAD
+	if (skb->dst->hh) {
+		MPLS_DEBUG("using hh\n");
+		neigh_hh_output(skb->dst->hh, skb);
+	} else 
+#endif
+	if(skb->dst->neighbour) {
+		MPLS_DEBUG("using neighbour (%p)\n",skb);
+		skb->dst->neighbour->output(skb);
+	} else {
+		MPLS_DEBUG("no hh no neighbor!?\n");
+		retval = MPLS_RESULT_DROP;
+	}
+mpls_send_exit:
+	MPLS_DEBUG("mpls_send result %d\n",retval);
+	return retval;
+}
+
+/**
+ *	mpls_output2 - Apply out segment to socket buffer 
+ *	@sbk: Socket buffer.
+ *	@nhlfe: NHLFE object containint the list of opcodes to apply.
+ *
+ *	This function is either called by mpls_input or mpls_output, and 
+ *	iterates the set of output opcodes that are configured for this nhlfe.
+ **/
+
+int mpls_output2 (struct sk_buff *skb,struct mpls_nhlfe *nhlfe)
+{
+	struct mpls_instr *mi;
+	int result = 0;
+	int ready_to_tx = 0;
+	int mtu = nhlfe->nhlfe_mtu;
+
+	MPLS_OUT_OPCODE_PROTOTYPE(*func);
+
+	MPLS_ENTER;
+
+	/* about to mangle skb, copy it */
+	if (skb_cow(skb, skb_headroom(skb))) {
+		goto mpls_output2_drop;
+	}
+
+/* Support of rec. output */
+mpls_output2_start:
+	ready_to_tx = 0;
+	nhlfe->nhlfe_stats.packets++;
+	nhlfe->nhlfe_stats.bytes += skb->len;
+
+	/* Iterate all the opcodes for this ILM */
+	for (mi = nhlfe->nhlfe_instr; mi; mi = mi->mi_next) {
+		int opcode = mi->mi_opcode;
+		void* data = mi->mi_data;
+		char* msg  = mpls_ops[opcode].msg;
+		MPLS_DEBUG("opcode %s\n",msg);
+
+		if (mpls_ops[opcode].extra) 
+			ready_to_tx = 1;
+
+		if ((func = mpls_ops[opcode].out)) {
+			switch ( func (&skb,NULL,&nhlfe,data)) {
+				case MPLS_RESULT_RECURSE:
+				case MPLS_RESULT_DLV:
+				case MPLS_RESULT_DROP:
+					goto mpls_output2_drop;
+				case MPLS_RESULT_FWD:
+					goto mpls_output2_start;
+				case MPLS_RESULT_SUCCESS:
+					break;
+			}
+		}
+	}
+
+	/* 
+	 * The control plane should have let the opcodes in a coherent
+	 * state. The last one should have enabled tx. 
+	 */
+	if (!ready_to_tx) 
+		goto mpls_output2_drop;
+
+	/*
+	 * Actually do the forwarding
+	 */
+	result = mpls_send (skb, mtu);
+	
+	if (result != MPLS_RESULT_SUCCESS)
+		goto mpls_output2_drop;
+
+	MPLS_EXIT;
+	return NET_XMIT_SUCCESS;
+
+mpls_output2_drop:
+	MPLS_DEBUG("FWD F'ed up instruction!\n");
+	if (nhlfe) 
+		nhlfe->nhlfe_drops++;
+	kfree_skb(skb);
+	MPLS_EXIT;
+	return NET_XMIT_DROP;
+}
+
+/**
+ *	mpls_output_shim - Push a label entry and send the packet.
+ *	@skb: socket buffer.
+ *	@nhlfe: NHLFE object to apply.
+ *
+ *	This function is *only* called by mpls_output, and calls 
+ *	mpls_output2 with a MPLS "push data" struct filled up 
+ *	with default values. The "bottom of stack" flag is asserted.
+ **/
+
+int mpls_output_shim (struct sk_buff *skb, struct mpls_nhlfe *nhlfe)
+{
+	struct mpls_prot_driver *prot;
+	int retval = 0;
+	int ttl;
+
+	prot = mpls_proto_find_by_ethertype(skb->protocol);
+	if (unlikely(!prot)) {
+		printk("MPLS: unable to find a protocol driver(%d)\n",
+			htons(skb->protocol));
+		goto mpls_output_error;
+	}
+
+	/*
+	 * JLEU: we only propagate the TTL if the SKB came from
+	 * IP[46] _and_ nhlfe_propagate_ttl is set to 1, otherwise we
+	 * set the TTL sysctl_mpls_default_ttl
+	 */
+	ttl = sysctl_mpls_default_ttl;
+	if (nhlfe->nhlfe_propagate_ttl) {
+		ttl = prot->get_ttl(skb);
+	}
+
+	MPLSCB(skb)->prot = prot;
+	MPLSCB(skb)->label = 0;
+	MPLSCB(skb)->ttl = ttl;
+	MPLSCB(skb)->exp = 0;
+	MPLSCB(skb)->bos = 1;
+	MPLSCB(skb)->flag = 0;
+	MPLSCB(skb)->popped_bos = 1;
+	MPLSCB(skb)->gap = 0;
+
+	retval = mpls_output2(skb,nhlfe);
+	/* release since we held above and the packet is now gone */
+	mpls_proto_release(prot);
+	return retval;
+
+mpls_output_error:
+	kfree_skb(skb);
+	return NET_XMIT_DROP;
+}
+
+
+
+/**
+ *	mpls_output - Send a packet using MPLS forwarding.
+ *	@skb: socket buffer containing the packet to send.
+ *
+ *	This function is called by the upper layers, in order to 
+ *	forward a data packet using MPLS. It assumes that the buffer
+ *	is ready, most notably, that skb->dst field is valid and
+ *	is part of a valid NHLFE. After some error checking, calls 
+ *	mpls_output_shim. 
+ *
+ *	NOTE: Please note that we *push* a label. A cross-connect (SWAP)
+ *	is a ILM/POP + NHLFE/PUSH
+ **/
+
+int mpls_output (struct sk_buff *skb) 
+{
+	struct mpls_nhlfe* nhlfe = NULL;
+
+	MPLS_ENTER;
+
+	if (unlikely(!skb->dst)) {
+		printk("MPLS: No dst in skb\n");
+		goto mpls_output_drop;
+	}
+	if (unlikely(skb->dst->ops->protocol != htons(ETH_P_MPLS_UC))) {
+		printk("MPLS: Not a MPLS dst in skb\n");
+		goto mpls_output_drop;
+	}
+	nhlfe = container_of(skb->dst, struct mpls_nhlfe, u.dst);
+	if (unlikely(!nhlfe)) {
+		printk("MPLS: unable to find NHLFE from dst\n");
+		goto mpls_output_drop;
+	}
+
+	/* we do the 'share' here, because, Layer 3 enters via this function,
+	 * and we only have to worry about 'sharing' when the packet came from
+	 * a layer 3 protocol
+	 */
+	skb = skb_share_check(skb, GFP_ATOMIC);
+	if (unlikely(!skb)) {
+		printk("MPLS: unable to share skb\n");
+		goto mpls_output_drop;
+	}
+
+	/*
+	 * if this packet thinks the hardware is going to do the
+	 * checksum, it had better think again.  By the time this
+	 * packet makes it to the hardware, it will be an MPLS packet
+	 * and the IP packet will mearly be the MPLS payload.
+	 * The hardware will not know how to add a checksum to the
+	 * payload of a MPLS packet ....
+	 */
+	if (skb->ip_summed == CHECKSUM_COMPLETE) {
+		if (skb_checksum_help(skb))
+			goto mpls_output_drop;
+	}
+
+	MPLS_EXIT;
+	return mpls_output_shim(skb,nhlfe);
+
+mpls_output_drop:
+	kfree_skb(skb);
+	MPLS_EXIT;
+	return NET_XMIT_DROP;
+}
+
+/**
+ *	mpls_switch - Label switch a packet coming from mpls_input
+ *	@skb: socket buffer containing the packet to send.
+ *
+ *	This function is called by mpls_input, in order to 
+ *	label switch a data packet. It assumes that the socket
+ *	is ready, most notably, that skb->dst field is valid and
+ *	is part of a valid NHLFE. After some error checking, calls 
+ *	mpls_output2. 
+ *	NOTE: Please note that we *push* a label. The current label was
+ *	already poped in mpls_input.
+ **/
+int mpls_switch (struct sk_buff *skb) 
+{
+	struct mpls_nhlfe* nhlfe = NULL;
+	struct mpls_prot_driver *prot;
+	int retval;
+
+	if (unlikely(!skb->dst)) {
+		printk("MPLS: No dst in skb\n");
+		goto mpls_switch_drop;
+	}
+	if (unlikely(skb->dst->ops->protocol != htons(ETH_P_MPLS_UC))) {
+		printk("MPLS: Not a MPLS dst in skb\n");
+		goto mpls_switch_drop;
+	}
+	nhlfe = container_of(skb->dst, struct mpls_nhlfe, u.dst);
+	if (unlikely(!nhlfe)) {
+		printk("MPLS: unable to find NHLFE from dst\n");
+		goto mpls_switch_drop;
+	}
+
+	prot = MPLSCB(skb)->prot;
+	retval = mpls_output2(skb,nhlfe);
+	/* mpls_input() does a mpls_proto_hold() */
+	mpls_proto_release(prot);
+	return retval;
+
+mpls_switch_drop:
+	kfree_skb(skb);
+	return NET_XMIT_DROP;
+}
+
+EXPORT_SYMBOL(mpls_output2);
+EXPORT_SYMBOL(mpls_output_shim);
diff -Naur linux-kernel-rpm-f8/net/mpls/mpls_procfs.c mpls-kernel-rpm-f8_modified/net/mpls/mpls_procfs.c
--- linux-kernel-rpm-f8/net/mpls/mpls_procfs.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/mpls/mpls_procfs.c	2008-10-17 09:45:02.000000000 +0200
@@ -0,0 +1,139 @@
+/*
+ *      Network mpls interface for protocols that live below L3 and above L2
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ *	Heavily borrowed from dev_remove_pack/dev_add_pack
+ *
+ *	Authors:	James R. Leu <jleu@mindspring.com>
+ */
+
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <asm/byteorder.h>
+#include <linux/list.h>
+#include <net/mpls.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <net/net_namespace.h>
+
+extern spinlock_t mpls_proto_lock;
+extern struct list_head mpls_proto_list;
+
+/*
+ * MODULE Information and attributes
+ */
+
+MODULE_AUTHOR("James R. Leu <jleu@mindspring.com>");
+MODULE_DESCRIPTION("net-mpls procfs module");
+MODULE_LICENSE("GPL");
+
+/*
+ * The following few functions build the content of /proc/net/mpls
+ */
+
+/* starting at mpls, find the next registered protocol */
+static struct mpls_prot_driver *mpls_skip(struct mpls_prot_driver *mpls)
+{
+	struct mpls_prot_driver *mpls1;
+	int next = 0;
+
+	if (!mpls)
+		next = 1;
+		
+	list_for_each_entry(mpls1, &mpls_proto_list, list) {
+		if (next)
+			return mpls1;
+
+		if (mpls1 == mpls)
+			next = 1;
+	}
+
+	return NULL;
+}
+
+										
+/* start read of /proc/net/mpls */
+static void *mpls_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	struct mpls_prot_driver *mpls;
+	loff_t i = 1;
+
+	spin_lock_bh(&mpls_proto_lock);
+
+	if (*pos == 0)
+		return SEQ_START_TOKEN;
+
+	for (mpls = mpls_skip(NULL); mpls && i < *pos;
+		mpls = mpls_skip(mpls), ++i);
+										
+	return (i == *pos) ? mpls : NULL;
+}
+
+static void *mpls_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	++*pos;
+										
+	return mpls_skip((v == SEQ_START_TOKEN)
+			    ? NULL
+			    : (struct mpls_prot_driver *)v);
+}
+										
+static void mpls_seq_stop(struct seq_file *seq, void *v)
+{
+	spin_unlock_bh(&mpls_proto_lock);
+}
+
+static int mpls_seq_show(struct seq_file *seq, void *v)
+{
+	struct mpls_prot_driver* mpls = (struct mpls_prot_driver*)v;
+	if (v != SEQ_START_TOKEN)
+		seq_printf(seq, "%s\t%d\n",
+		    mpls->name ? mpls->name : "(none)",
+		    atomic_read(&mpls->__refcnt));
+	return 0;
+}
+
+/*
+ *      Generic /proc/net/mpls file and inode operations
+ */
+										
+static struct seq_operations mpls_seq_ops = {
+	.start = mpls_seq_start,
+	.next = mpls_seq_next,
+	.stop = mpls_seq_stop,
+	.show = mpls_seq_show,
+};
+										
+static int mpls_seq_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &mpls_seq_ops);
+}
+										
+static struct file_operations mpls_seq_fops = {
+	.owner   = THIS_MODULE,
+	.open    = mpls_seq_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = seq_release,
+};
+
+int __init mpls_procfs_init(void)
+{
+	if (!proc_net_fops_create(&init_net, "mpls",  S_IRUGO,
+				  &mpls_seq_fops)) {
+		printk(MPLS_ERR "MPLS: failed to register with procfs\n");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+void __exit mpls_procfs_exit(void)
+{
+	proc_net_remove(&init_net, "mpls");
+}
diff -Naur linux-kernel-rpm-f8/net/mpls/mpls_proto.c mpls-kernel-rpm-f8_modified/net/mpls/mpls_proto.c
--- linux-kernel-rpm-f8/net/mpls/mpls_proto.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/mpls/mpls_proto.c	2008-10-17 09:45:02.000000000 +0200
@@ -0,0 +1,153 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching) Architecture for Linux.
+ *
+ * mpls_proto.c: MPLS Proto management
+ *
+ * Copyright (C) David S. Miller (davem@redhat.com),
+ *		 James R. Leu (jleu@mindspring.com)
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * Changes:
+ *	RCAS: minor changes (formatting) and added addr
+ *	JLEU: added mpls_prot_cache_flush_all()
+ *	JLEU: rewrote most of the functions to allow for more
+ *	       families then just IPv4 and IPv6
+ *****************************************************************************/
+
+#include <linux/autoconf.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/skbuff.h>
+#include <net/mpls.h>
+
+DEFINE_SPINLOCK(mpls_proto_lock);
+LIST_HEAD(mpls_proto_list);
+
+int mpls_proto_add(struct mpls_prot_driver *proto)
+{
+        spin_lock_bh(&mpls_proto_lock);
+
+        atomic_set(&proto->__refcnt, 1);
+        list_add_rcu(&proto->list, &mpls_proto_list);
+
+        spin_unlock_bh(&mpls_proto_lock);
+	return 0;
+}
+
+int mpls_proto_remove(struct mpls_prot_driver *proto)
+{
+        struct mpls_prot_driver *proto1;
+        int retval = -EPROTONOSUPPORT;
+
+        spin_lock_bh(&mpls_proto_lock);
+
+        list_for_each_entry(proto1, &mpls_proto_list, list) {
+                if (proto == proto1) {
+                        if (atomic_read(&proto->__refcnt) != 1) {
+                                retval = -EADDRINUSE;
+                        } else {
+                                list_del_rcu(&proto->list);
+                                retval = 0;
+                        }
+                        break;
+                }
+        }
+        spin_unlock_bh(&mpls_proto_lock);
+
+        synchronize_net();
+        return retval;
+}
+
+struct mpls_prot_driver *mpls_proto_find_by_family(unsigned short fam)
+{
+        struct mpls_prot_driver *proto;
+
+	rcu_read_lock();
+        list_for_each_entry_rcu(proto, &mpls_proto_list, list) {
+                if (fam == proto->family) {
+                        mpls_proto_hold(proto);
+                        goto out;
+                }
+        }
+        proto = NULL;
+out:
+	rcu_read_unlock();
+
+        return proto;
+}
+
+struct mpls_prot_driver *mpls_proto_find_by_ethertype(unsigned short type)
+{
+        struct mpls_prot_driver *proto;
+
+	rcu_read_lock();
+        list_for_each_entry_rcu(proto, &mpls_proto_list, list) {
+                if (type == proto->ethertype) {
+                        mpls_proto_hold(proto);
+                        goto out;
+                }
+        }
+        proto = NULL;
+out:
+	rcu_read_unlock();
+
+        return proto;
+}
+
+struct mpls_prot_driver *mpls_proto_find_by_name(char *name)
+{
+        struct mpls_prot_driver *proto;
+
+	rcu_read_lock();
+        list_for_each_entry_rcu(proto, &mpls_proto_list, list) {
+                if (!strncmp(name, proto->name, MPLSPROTONAMSIZ)) {
+                        mpls_proto_hold(proto);
+                        goto out;
+                }
+        }
+        proto = NULL;
+out:
+	rcu_read_unlock();
+
+        return proto;
+}
+
+void mpls_proto_cache_flush_all(void)
+{
+        struct mpls_prot_driver *proto;
+
+	rcu_read_lock();
+        list_for_each_entry_rcu(proto, &mpls_proto_list, list) {
+		proto->cache_flush();
+        }
+	rcu_read_unlock();
+}
+
+void __init mpls_proto_init(void)
+{
+	printk("MPLS: protocol driver interface - <jleu@mindspring.com>\n");
+}
+
+void __exit mpls_proto_exit(void)
+{
+}
+
+EXPORT_SYMBOL(mpls_proto_add);
+EXPORT_SYMBOL(mpls_proto_remove);
+EXPORT_SYMBOL(mpls_proto_find_by_family);
+EXPORT_SYMBOL(mpls_proto_find_by_ethertype);
+EXPORT_SYMBOL(mpls_proto_find_by_name);
+EXPORT_SYMBOL(mpls_proto_cache_flush_all);
+EXPORT_SYMBOL(mpls_proto_lock);
+EXPORT_SYMBOL(mpls_proto_list);
diff -Naur linux-kernel-rpm-f8/net/mpls/mpls_shim.c mpls-kernel-rpm-f8_modified/net/mpls/mpls_shim.c
--- linux-kernel-rpm-f8/net/mpls/mpls_shim.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/mpls/mpls_shim.c	2008-10-17 09:45:02.000000000 +0200
@@ -0,0 +1,105 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *          James Leu        <jleu@mindspring.com>
+ *
+ *   (c) 1999-2005   James Leu        <jleu@mindspring.com>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * Changes:
+ * 20051122 JLEU
+ *	- seperate shim code from init
+ ****************************************************************************/
+
+#include <linux/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <net/shim.h>
+#include <net/mpls.h>
+
+/**
+ *	mpls_set_nexthop2
+ *	@nhlfe: the nhlfe object to apply to the dst
+ *	@dst: dst_entry 
+ *
+ *	Called from outside the MPLS subsystem. 
+ **/
+
+int mpls_set_nexthop2(struct mpls_nhlfe *nhlfe, struct dst_entry *dst)
+{
+	MPLS_ENTER;
+
+	dst->metrics[RTAX_MTU-1] = nhlfe->nhlfe_mtu;
+	dst->child = dst_clone(&nhlfe->u.dst);
+	MPLS_DEBUG("nhlfe: %p mtu: %d dst: %p\n", nhlfe, nhlfe->nhlfe_mtu,
+		&nhlfe->u.dst);
+
+	MPLS_EXIT;
+	return 0;
+}
+
+/**
+ *	mpls_set_nexthop
+ *	@shim:holds the key to look up the NHLFE object to apply.
+ *	@dst: dst_entry 
+ *
+ *	Called from outside the MPLS subsystem. 
+ **/
+
+int mpls_set_nexthop (struct shim_blk *sblk, struct dst_entry *dst)
+{
+	struct mpls_nhlfe *nhlfe = NULL;
+	unsigned int key;
+	int ret;
+
+	MPLS_ENTER;
+
+	memcpy(&key, sblk->data, sizeof(key));
+	nhlfe = mpls_get_nhlfe(key);
+	if (unlikely(!nhlfe)) {
+		MPLS_EXIT;
+		return -ENXIO;
+	}
+
+	ret = mpls_set_nexthop2(nhlfe, dst);
+	mpls_nhlfe_release(nhlfe);
+	MPLS_EXIT;
+ 	return ret;
+}
+
+/**
+ *	mpls_uc_shim - "SPECIAL" next hop Management for MPLS UC traffic.
+ *	@name: name of the struct.
+ *	@build: Callback used to build
+ *
+ *	e.g. for a MPLS enabled iproute2:
+ *	ip route add a.b.c.d/n via x.y.z.w shim mpls 0x2
+ *	The key (0x2) is the "data" for NHLFE lookup.
+ **/
+ 
+static struct shim mpls_uc_shim = {
+	.name = "mpls",
+	.build = mpls_set_nexthop,
+};
+
+void __init mpls_shim_init (void) 
+{
+	shim_proto_add(&mpls_uc_shim);
+}
+
+void __exit mpls_shim_exit (void)
+{
+	shim_proto_remove (&mpls_uc_shim);
+	synchronize_net();
+}
+
+EXPORT_SYMBOL(mpls_set_nexthop2);
+EXPORT_SYMBOL(mpls_set_nexthop);
diff -Naur linux-kernel-rpm-f8/net/mpls/mpls_tunnel.c mpls-kernel-rpm-f8_modified/net/mpls/mpls_tunnel.c
--- linux-kernel-rpm-f8/net/mpls/mpls_tunnel.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/mpls/mpls_tunnel.c	2008-10-17 09:45:02.000000000 +0200
@@ -0,0 +1,529 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching) Architecture for Linux.
+ *
+ * mpls_tunnel.c
+ *         * Management of MPLS tunnels, virtual devices named by default
+ *           mpls%d and that can be managed using userspace tools like
+ *           ip route, ifconfig, etc. As per RFC, LSPs are unidirectional.
+ *  Usage:
+ *         Creation    : mpls_tunnel_create
+ *         Destruction : mpls_tunnel_destroy
+ *         EXPORT_SYMBOL(mpls_tunnel_create);
+ *         EXPORT_SYMBOL(mpls_tunnel_destroy);
+ *
+ * Authors:
+ *   (c) 1999-2005   James Leu        <jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * ChangeLog
+ *	v-0.97 20040207 RCAS 
+ *		o set up netlink links. 
+ *	v-0.98 20040208 RCAS 
+ *		o remove private list. 
+ *		o fixed some MTU issues. Use dev_set_mtu
+ *	20050105 JLEU
+ *		o implement netlink interface
+ *	20050827 JLEU
+ *		o remove netlink code
+ *		o module loading creates one interface, unload deletes it
+ *		o implemented device IOCTL for setting NHLFE
+ *****************************************************************************/
+
+#include <linux/autoconf.h>
+#include <linux/in.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/ip.h>
+#include <linux/if_tunnel.h>
+#include <linux/netdevice.h>
+#include <linux/rtnetlink.h>
+#include <net/net_namespace.h>
+#include <net/mpls.h>
+
+/**
+ * MODULE Information and attributes
+ **/
+
+
+static struct net_device *mpls_tunnel_dev;
+static void mpls_tunnel_setup (struct net_device *dev);
+
+MODULE_AUTHOR("James R. Leu <jleu@mindspring.com>, Ramon Casellas <casellas@infres.enst.fr>");
+MODULE_DESCRIPTION("MultiProtocol Label Switching Tunnel Module");
+MODULE_LICENSE("GPL");
+
+/*  Obtain private MPLS extension for a netdevice */
+#define mpls_dev2mtp(MPLSDEV) \
+	((struct mpls_tunnel_private *)((MPLSDEV)->priv))
+
+/* Obtain mentor netdevice for a given (private) tunnel */
+#define mpls_mtp2dev(MPLSMTP) \
+	((struct net_device *)((MPLSMTP)->mtp_dev))
+
+
+/**
+ *	mpls_tunnel_set_nhlfe - sets the nhlfe for this virtual device.
+ *	@dev: netdevice "mpls%d" 
+ *	@key: nhlfe key. 
+ *
+ *	Sets the NHLFE for this mpls net_device according to the key: if the
+ *	key is zero, this function releases and resets the tunnel's nhlfe.
+ *	Otherwise, it holds a reference to the new nhlfe (as per key),
+ *	updates the MTU
+ *
+ *	The mtp_nhlfe member of the tunnel private structure holds a
+ *	reference to the new NHLFE object.
+ *	Returns 0 if ok.
+ *
+ *	Remarks:
+ *	     o This function increases the reference count of the NHLFE
+ *	       determined by the key if the key is non zero, since the
+ *	       NHLFE will be held by the device private part.
+ *	Changes:
+ *	     o RCAS 20040207. Use dev_set_mtu
+ **/
+
+static int mpls_tunnel_set_nhlfe (struct net_device* dev, unsigned int key) 
+{
+	struct mpls_nhlfe *nhlfe = NULL;
+	struct mpls_nhlfe *newnhlfe = NULL;
+
+	MPLS_ENTER;
+
+	/* Get previous NHLFE (it is held by mtp)  */ 
+	nhlfe = mpls_dev2mtp(dev)->mtp_nhlfe;
+
+	/* If key is zero, the nhlfe for tunnel is reset, we are done */ 
+	if (!key) {
+		if (nhlfe) {
+			MPLS_DEBUG("dropping old nhlfe %x\n", nhlfe->nhlfe_key);
+			mpls_nhlfe_release(nhlfe);
+		}
+		MPLS_DEBUG("reset nhlfe %x\n", key);
+		mpls_dev2mtp(dev)->mtp_nhlfe = NULL;
+		dev->iflink = 0;
+		MPLS_EXIT;
+		return 0; 
+	}
+
+	/* Get a reference for new NHLFE */
+	newnhlfe = mpls_get_nhlfe(key);
+	if (unlikely(!newnhlfe)) {
+		MPLS_DEBUG("error fetching new nhlfe with key %u\n",key);
+		MPLS_DEBUG("keeping old nhlfe %x\n", nhlfe->nhlfe_key);
+		MPLS_EXIT;
+		return -ESRCH;
+	}
+
+	/* Drop old NHLFE */
+	if (nhlfe) {
+		dev_close(dev);
+		MPLS_DEBUG("dropping old nhlfe %x\n", nhlfe->nhlfe_key);
+		mpls_nhlfe_release(nhlfe);
+	}
+
+	/* Commit Set new NHLFE (it is held by mtp)  */ 
+ 	mpls_dev2mtp(dev)->mtp_nhlfe = newnhlfe;
+
+	if (newnhlfe) {
+		/* Set new MTU for the tunnel device */
+		dev_set_mtu(dev,newnhlfe->nhlfe_mtu);
+		dev_open(dev);
+	}
+
+	MPLS_EXIT;
+	return 0;
+}
+
+
+
+/**
+ *	mpls_tunnel_destructor - say tunnel goodbye.
+ *	@dev: mpls tunnel
+ *
+ *	This callback gets called when the core system destroys the net_device.
+ *	Remember that it was allocated with  alloc_netdev(netdev + privdata),
+ *	and dev->priv points to the "extension" (privdata). So we just reset to
+ *	NULL. cf. dev.c "It must be the very last action, after this 'dev' may
+ *	point to freed up memory.". the refcount of the object at this point is
+ *	zero.
+ *
+ *	Changes:
+ *	    20040118 RCAS: When destroying the tunnel, release the NHLFE
+ *	              object if it was there.
+ **/
+
+static void 
+mpls_tunnel_destructor (struct net_device *dev) 
+{
+	MPLS_ENTER;
+	mpls_tunnel_set_nhlfe (dev,0);
+	free_netdev (dev);
+	MPLS_EXIT;
+}
+
+
+/**
+ *	mpls_tunnel_xmit - transmit a socket buffer via the device.
+ *	@skb: data
+ *	@dev: mpls tunnel
+ *
+ *	This callback gets called when the core system wants to send a socket
+ *	buffer. the "mpls_output2" symbol will take care of it. This only
+ *	happens of course if someone set a valid NHLFE (e.g. PUSH/.../SET) for
+ *	the device
+ **/
+
+static int 
+mpls_tunnel_xmit (struct sk_buff *skb, struct net_device *dev) 
+{
+	const char *err_nonhlfe = "NHLFE was invalid";
+	int result = 0;
+
+	MPLS_ENTER;
+
+	MPLSCB(skb)->label = 0;
+	MPLSCB(skb)->ttl = 255;
+	MPLSCB(skb)->exp = 0;
+	MPLSCB(skb)->bos = (skb->protocol == htons(ETH_P_MPLS_UC)) ? 0 : 1;
+	MPLSCB(skb)->flag = 0;
+	MPLSCB(skb)->popped_bos = (MPLSCB(skb)->bos) ? 0 : 1;
+
+	dev->trans_start = jiffies;
+	if (mpls_dev2mtp(dev)->mtp_nhlfe) {
+		MPLS_DEBUG(
+		"Skb to Send\n"
+		"Device %s \n"
+		"DST %p\n"
+		"Protocol ID %04x\n",
+		skb->dev? skb->dev->name : "<>",
+		skb->dst ? skb->dst : NULL,
+		ntohs(skb->protocol)
+		);
+			
+		MPLS_DEBUG("Using NHLFE %08x\n", 
+			mpls_dev2mtp(dev)->mtp_nhlfe->nhlfe_key);
+		mpls_dev2mtp(dev)->stat.tx_packets++;
+		mpls_dev2mtp(dev)->stat.tx_bytes += skb->len;
+		MPLS_DEBUG_CALL(mpls_skb_dump(skb));
+		result = mpls_output2 (skb,mpls_dev2mtp(dev)->mtp_nhlfe);
+		MPLS_EXIT;
+		return result; 
+	}
+
+	dev_kfree_skb(skb);
+	mpls_dev2mtp(dev)->stat.tx_errors++;
+	MPLS_DEBUG("exit - %s\n", err_nonhlfe);
+	return 0;
+}
+
+
+
+/**
+ *	mpls_tunnel_get_stats - get sender statistics for this tunnel 
+ *	@dev: virtual "mpls%d" device.
+ **/
+
+static struct net_device_stats* 
+mpls_tunnel_get_stats (struct net_device *dev) 
+{
+	return &((mpls_dev2mtp(dev))->stat);
+}
+
+
+
+
+/**
+ *	mpls_tunnel_change_mtu - Grant new MTU value for device. 
+ *	@dev: virtual "mpls%d" device.
+ *	@new_mtu: new value 
+ *
+ *	Called by dev_set_mtu (see net/code/dev.c). May veto the new value.
+ *	Returns 0 if Ok. -EINVAL otherwise. 
+ *	dev_set_mtu(dev,new) takes care of the actual assignement.
+ **/
+
+static int 
+mpls_tunnel_change_mtu (struct net_device *dev, int new_mtu) 
+{
+	int retval = 0;
+	MPLS_ENTER;
+	if (new_mtu < 4 || new_mtu > mpls_dev2mtp(dev)->mtp_nhlfe->nhlfe_mtu)
+		retval = -EINVAL;
+	MPLS_EXIT;
+	return retval;
+}
+
+static int mpls_tunnel_alloc(struct mpls_tunnel_req *mtr) {
+	struct mpls_nhlfe *nhlfe = NULL;
+	struct net_device *dev;
+	int retval;
+
+	MPLS_ENTER;
+	retval = -ESRCH;
+	if (mtr->mt_nhlfe_key && !(nhlfe = mpls_get_nhlfe(mtr->mt_nhlfe_key)))
+		goto error;
+
+	if (__dev_get_by_name(&init_net, mtr->mt_ifname)) {
+		mpls_nhlfe_release(nhlfe);
+		goto error;
+	}
+
+	retval = -ENOMEM;
+	if (!(dev = alloc_netdev (sizeof(struct mpls_tunnel_private),
+		mtr->mt_ifname, mpls_tunnel_setup))) {
+		mpls_nhlfe_release(nhlfe);
+		goto error;
+	}
+
+	retval = -ENOBUFS;
+	if (register_netdevice(dev)) {
+		mpls_nhlfe_release(nhlfe);
+		free_netdev(dev);
+		goto error;
+	}
+
+	mpls_dev2mtp(dev)->mtp_nhlfe = nhlfe;
+	dev_hold(dev);
+	retval = 0;
+error:
+	MPLS_EXIT;
+	return retval;
+}
+
+static struct mpls_tunnel_private *
+mpls_tunnel_lookup(struct mpls_tunnel_req *mtr) {
+	struct net_device *dev;
+	struct mpls_tunnel_private *mtp;
+	MPLS_ENTER;
+	dev = __dev_get_by_name(&init_net, mtr->mt_ifname);
+	mtp = dev ? mpls_dev2mtp(dev) : NULL;
+	MPLS_EXIT;
+	return mtp;
+}
+
+
+/**
+ *	mpls_tunnel_ioctl - callback for device private IOCTL calls
+ *	@dev: virtual "mpls%d" device.
+ *	@ifr: IOCTL request data
+ *	@cmd: IOCTL command
+ *
+ *	Called in response to a userland IOCTL call for configuring
+ *	this tunnel interface
+ *	Returns 0 if Ok. < 0 on error
+ **/
+
+static int
+mpls_tunnel_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	struct mpls_tunnel_private *mtp = NULL;
+	struct mpls_tunnel_req mtr;
+	int retval = 0;
+
+	MPLS_ENTER;
+	switch (cmd) {
+	    case SIOCGETTUNNEL:
+		if (dev == mpls_tunnel_dev) {
+			retval = -EFAULT;
+			if (copy_from_user(&mtr, ifr->ifr_data, sizeof(mtr)))
+				break;
+
+			retval = -ENOENT;
+			if (!(mtp = mpls_tunnel_lookup(&mtr)))
+				break;
+		}
+		if (!mtp)
+			mtp = mpls_dev2mtp(dev);
+
+		strcpy(mtr.mt_ifname, mpls_mtp2dev(mtp)->name);
+		mtr.mt_nhlfe_key =
+			mtp->mtp_nhlfe ? mtp->mtp_nhlfe->nhlfe_key : 0;
+
+		if (copy_to_user(ifr->ifr_data, &mtr, sizeof(mtr)))
+			retval = -EFAULT;
+		break;
+	    case SIOCADDTUNNEL:
+	    case SIOCCHGTUNNEL:
+		retval = -EPERM;
+		if (!capable(CAP_NET_ADMIN))
+			goto error;
+
+                retval = -EFAULT;
+		if (copy_from_user(&mtr, ifr->ifr_data, sizeof(mtr)))
+			goto error;
+
+		retval = -EINVAL;
+		if (dev == mpls_tunnel_dev && cmd == SIOCADDTUNNEL) {
+			retval = mpls_tunnel_alloc(&mtr);
+			break;
+		} else if (dev == mpls_tunnel_dev && cmd == SIOCCHGTUNNEL) {
+			retval = -ENOENT;
+			if (!(mtp = mpls_tunnel_lookup(&mtr)))
+				break;
+		} else if (dev != mpls_tunnel_dev && cmd == SIOCCHGTUNNEL) {
+			mtp = mpls_dev2mtp(dev);
+		}
+		retval = mpls_tunnel_set_nhlfe(mpls_mtp2dev(mtp),
+			mtr.mt_nhlfe_key);
+		break;
+	    case SIOCDELTUNNEL:
+		retval = -EPERM;
+		if (!capable(CAP_NET_ADMIN))
+			goto error;
+
+		if (dev == mpls_tunnel_dev) {
+			retval = -EFAULT;
+			if (copy_from_user(&mtr, ifr->ifr_data, sizeof(mtr)))
+				goto error;
+
+			retval = -ENOENT;
+			if (!(mtp = mpls_tunnel_lookup(&mtr)))
+				break;
+			dev = mpls_mtp2dev(mtp);
+		}
+		unregister_netdevice(dev);
+		retval = 0;
+		break;
+	    default:
+		retval = -EINVAL;
+	}
+
+error:
+	MPLS_ENTER;
+	return retval;
+}
+
+static int mpls_tunnel_init(struct net_device *dev)
+{
+	struct mpls_tunnel_private *mtp =  mpls_dev2mtp(dev);
+	MPLS_ENTER;
+	mtp->mtp_dev = dev;
+	MPLS_EXIT;
+	return 0;
+}
+
+static void mpls_tunnel_uninit(struct net_device *dev)
+{
+	MPLS_ENTER;
+	dev_put(dev);
+	MPLS_EXIT;
+}
+
+/**
+ *	mpls_tunnel_setup - main setup callback
+ *	@dev - mpls%d
+ *
+ *	Main setup function. Called by net/core/dev.c after a successful
+ *	netdev_alloc. We just set the function pointer table, device type and
+ *	flags. Initial MTU value is arbitrary, since the tunnel hasn't a valid
+ *	NHLFE object (NHLFE objects know the number of pushes and the MTU of the
+ *	real physical device).
+ **/
+
+static void 
+mpls_tunnel_setup (struct net_device *dev) 
+{
+	MPLS_ENTER;
+
+	/* Callbacks */
+	dev->open            = NULL; 
+	dev->init            = mpls_tunnel_init;
+	dev->uninit	     = mpls_tunnel_uninit;
+	dev->do_ioctl        = mpls_tunnel_ioctl;
+	dev->destructor	     = mpls_tunnel_destructor;
+	dev->hard_start_xmit = mpls_tunnel_xmit;
+	dev->get_stats	     = mpls_tunnel_get_stats;
+	dev->change_mtu	     = mpls_tunnel_change_mtu;
+
+	/* Properties of mpls%d devices */
+	dev->type            = ARPHRD_MPLS_TUNNEL;
+	dev->hard_header_len = sizeof(u32);
+	dev->mtu	     = 1500;
+	dev->flags	     = IFF_NOARP|IFF_POINTOPOINT;
+	dev->iflink	     = 0;
+	dev->addr_len	     = 4;
+	MPLS_EXIT;
+}
+
+/*
+ * Same as mpls_tunnel_init except it holds a ref to the netdevice
+ * and is only used by the initial mpls tunnel device
+ */
+static int __init mpls_tunnel_dev_init(struct net_device *dev)
+{
+	struct mpls_tunnel_private *mtp =  mpls_dev2mtp(dev);
+	mtp->mtp_dev = dev;
+	dev_hold(dev);
+	return 0;
+}
+
+/**
+ *	mpls_tunnel_init_module - main tunnel init routine.
+ *
+ *	Init method called when the module is loaded, initiliazes the 
+ *	list of created tunnels to zero, initializes and registers the 
+ *	mpls_tunnel kset (which depends on the mpls subsystem) and creates
+ *	/proc/net/mpls/tunnel entry.
+ **/
+
+static int __init 
+mpls_tunnel_init_module (void) 
+{
+	int retval = -EINVAL;
+
+	mpls_tunnel_dev = alloc_netdev (sizeof(struct mpls_tunnel_private),
+		"mpls0", mpls_tunnel_setup);
+	if (unlikely(!mpls_tunnel_dev)) {
+		retval = -ENOMEM;
+		goto err;
+	}
+
+	mpls_tunnel_dev->init = mpls_tunnel_dev_init;
+	if (unlikely((retval = register_netdev(mpls_tunnel_dev)))) {
+		free_netdev(mpls_tunnel_dev);
+		goto err;
+	}
+
+	retval = 0;
+err:
+	return retval;
+}
+
+static void __exit mpls_destroy_tunnels(void)
+{
+	struct net_device *dev;
+	struct net_device *ndev;
+
+	for_each_netdev_safe(&init_net, dev, ndev) {
+		if (dev->type == ARPHRD_MPLS_TUNNEL)
+			unregister_netdev(dev);
+	}
+}
+
+
+/**
+ *	mpls_tunnel_exit_module - Module unload exit method.
+ *	
+ **/
+
+static void __exit 
+mpls_tunnel_exit_module (void) 
+{
+	rtnl_lock();
+	mpls_destroy_tunnels();
+	rtnl_unlock();
+	return;
+}
+
+module_init(mpls_tunnel_init_module);
+module_exit(mpls_tunnel_exit_module);
diff -Naur linux-kernel-rpm-f8/net/mpls/mpls_utils.c mpls-kernel-rpm-f8_modified/net/mpls/mpls_utils.c
--- linux-kernel-rpm-f8/net/mpls/mpls_utils.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/mpls/mpls_utils.c	2008-10-17 09:45:02.000000000 +0200
@@ -0,0 +1,229 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *	  James Leu	<jleu@mindspring.com>
+ *	  Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu	<jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *	      It implements:
+ *	      -various common functions called by the rest of the MPLS
+ *	       stack
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * RCAS BUGS: struct mpls_label should use u32, u16...
+ ****************************************************************************/
+
+#include <linux/autoconf.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/kobject.h>
+#include <net/neighbour.h>
+#include <net/route.h>
+#include <net/mpls.h>
+
+/**************
+  ATM
+   0		   1		   2		   3
+   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |Label Space(10)    |    VPI (8)    |	  VCI(16)		  |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |typ|     index(8)  |	   VPI (8)    |	  VCI(16)		  |
+  +---------------------------------------------------------------+
+  |	       mark (key)				          |
+  +---------------------------------------------------------------+
+
+  Generic
+   0		   1		   2		   3
+   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |   Label Space(12)     |       Generic Label Value(20)	  |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |typ|    index(10)      |		   gen(20)		  | 
+  +---------------------------------------------------------------+
+  |	       mark (key)				          |
+  +---------------------------------------------------------------+
+
+  Frame Relay
+   0		   1		   2		   3
+   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |Label Space(12)  	  |	      DLCI(20)			  |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |typ|    index(10)      |		   fr(20)		  | 
+  +---------------------------------------------------------------+
+  |	       mark (key)				          |
+  +---------------------------------------------------------------+
+
+ *************/
+
+struct mpls_atm_key {
+	unsigned int type:2;
+	unsigned int index:8;
+	unsigned int vpi:8;
+	unsigned int vci:14;
+};
+
+struct mpls_gen_key {
+	unsigned int type:2;
+	unsigned int index:10;
+	unsigned int gen:20;
+};
+
+struct mpls_fr_key {
+	unsigned int type:2;
+	unsigned int index:10;
+	unsigned int fr:20;
+};
+
+struct mpls_key {
+	union {
+		struct mpls_atm_key atm;
+		struct mpls_gen_key gen;
+		struct mpls_fr_key  fr;
+		unsigned int mark:32;
+	} u;
+};
+
+
+
+/** 
+ *	mpls_label2key - Obtain a lookup key given a index or labelspace
+ *	and a label value.
+ *	@index: labelspace
+ *	@label: struct containing the label type/value.
+ *
+ *	Returns a given key that can be used to store/read objects in a 
+ *	data structure (e.g. a Radix Tree).
+ *
+ *	Bugs: RCAS: this function must be *faast* optimize!
+ **/
+
+unsigned int  
+mpls_label2key (const int index, const struct mpls_label *label) 
+{
+	struct mpls_key temp;
+
+	switch(label->ml_type) {
+		case MPLS_LABEL_GEN:
+			temp.u.gen.index = index;
+			temp.u.gen.gen   = label->u.ml_gen;
+			temp.u.gen.type  = label->ml_type;
+			break;
+		case MPLS_LABEL_ATM:
+			temp.u.atm.index = index;
+			temp.u.atm.vpi   = label->u.ml_atm.mla_vpi;
+			temp.u.atm.vci   = label->u.ml_atm.mla_vci;
+			temp.u.atm.type  = label->ml_type;
+			break;
+		case MPLS_LABEL_FR:
+			temp.u.fr.index  = index;
+			temp.u.fr.fr     = label->u.ml_fr;
+			temp.u.fr.type   = label->ml_type;
+			break;
+		case MPLS_LABEL_KEY:
+			temp.u.mark      = label->u.ml_key;
+			break;
+	}
+	return temp.u.mark;
+}
+
+/**
+ *	mpls_find_payload - find the beinging of the data under the
+ *	mpls shim
+ *	@skb - the packet to work on
+ *
+ *	assumes valid data in MPLSCB(skb)->popped_bos and that
+ *	that skb->network_header is pointing to a label in the MPLS shim
+ *	returns a unsigned char* which point to the first byte after the MPLS
+ *	shim.
+ *
+ **/
+
+char
+mpls_find_payload (struct sk_buff* skb)
+{
+	unsigned char *ptr = skb->data;
+	unsigned char count = 0;
+        u32 shim;
+
+	if (MPLSCB(skb)->popped_bos)
+		return count;
+
+try_again:
+
+	if ((size_t)ptr > (size_t)skb->tail)
+		return -1;
+
+#define CAN_WE_ASSUME_32BIT_ALIGNED 0
+#if CAN_WE_ASSUME_32BIT_ALIGNED
+        shim = ntohl(*((u32*)ptr));
+#else
+        memcpy(&shim,ptr,sizeof(u32));
+        shim = ntohl(shim);
+#endif
+
+	ptr = &ptr[sizeof(u32)];
+	count += 4;
+
+        if ((shim >> 8 ) & 0x1)
+	    return count;
+
+	goto try_again;
+
+        return 0;
+}
+
+
+
+
+/**
+ *	mpls_skb_dump - dump socket buffer to kernel log.
+ *	@sk received socket buffer
+ *	
+ *	Dumps the content of the socket buffer to the kernel log buffer. Can be 
+ *	called from anywhere, but typically it is called upon reception of a
+ *	labelled packet.
+ *
+ **/
+
+void 
+mpls_skb_dump (struct sk_buff* sk) 
+{
+	unsigned int i;
+	printk("MPLS mpls_skb_dump: from %s with len %d (%d)" 
+	       "headroom=%d tailroom=%d\n",
+			sk->dev?sk->dev->name:" net stack ",
+			sk->len,
+			sk->truesize,
+			skb_headroom(sk),
+			skb_tailroom(sk));
+
+	for (i=(unsigned int)sk->head; i<=(unsigned int)sk->tail; i++) {
+		if (i == (unsigned int)sk->data)
+			printk("{"); 
+		if (i == (unsigned int)sk->transport_header)
+			printk("#");
+		if (i == (unsigned int)sk->network_header) 
+			printk("|"); 
+		if (i == (unsigned int)sk->mac_header) 
+			printk("*"); 
+		printk("%02x",*((unsigned char*)i));
+		if (i == (unsigned int)sk->tail)
+			printk("}"); 
+	}
+	printk("\n");
+}
+
+EXPORT_SYMBOL(mpls_label2key);
+EXPORT_SYMBOL(mpls_find_payload);
+EXPORT_SYMBOL(mpls_skb_dump);
diff -Naur linux-kernel-rpm-f8/net/mpls/sysctl_net_mpls.c mpls-kernel-rpm-f8_modified/net/mpls/sysctl_net_mpls.c
--- linux-kernel-rpm-f8/net/mpls/sysctl_net_mpls.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/mpls/sysctl_net_mpls.c	2008-10-17 09:45:02.000000000 +0200
@@ -0,0 +1,48 @@
+/*
+ * sysctl_net_mpls.c: sysctl interface to net MPLS subsystem.
+ */
+
+#include <linux/mm.h>
+#include <linux/sysctl.h>
+#include <net/mpls.h>
+
+static ctl_table mpls_table[] = {
+	{
+		.ctl_name	= NET_MPLS_DEBUG,
+		.procname	= "debug",
+		.data		= &sysctl_mpls_debug,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{
+		.ctl_name	= NET_MPLS_DEFAULT_TTL,
+		.procname	= "default_ttl",
+		.data		= &sysctl_mpls_default_ttl,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{ .ctl_name = 0 }
+};
+
+static struct ctl_path mpls_path[] = {
+	{ .procname = "net", .ctl_name = CTL_NET, },
+	{ .procname = "mpls", .ctl_name = NET_MPLS, },
+	{ }
+};
+
+static struct ctl_table_header *mpls_table_header;
+
+int __init mpls_sysctl_init(void)
+{
+	mpls_table_header = register_sysctl_paths(mpls_path, mpls_table);
+	if (!mpls_table_header)
+		return -ENOMEM;
+	return 0;
+}
+
+void mpls_sysctl_exit(void)
+{
+	unregister_sysctl_table(mpls_table_header);
+}
diff -Naur linux-kernel-rpm-f8/net/mpls/TODO mpls-kernel-rpm-f8_modified/net/mpls/TODO
--- linux-kernel-rpm-f8/net/mpls/TODO	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/mpls/TODO	2008-10-17 09:45:01.000000000 +0200
@@ -0,0 +1,20 @@
+* PRIO1 20040207
+  RCAS :Allocations in control plane use GPF_ATOMIC because we are working
+  under a spinlock. This is suboptimal. We should define a better locking
+  scheme (most MII/MOI modifications are performed in user context, after
+  a IOCTL).  We could define a better locking scheme and revert to GPF_KERNEL
+
+* RCAS : Use event management for "external" MOI/MII references: Any
+  protocol, device or module (e.g. tunnel) that holds a reference to a
+  MII/MOI should register for removal notification, and cleanup and put
+  back the reference if they receive a MOI or MII remove event.
+
+* RCAS: With the current implementation, &mpls_mii_lock and &mpls_moi_lock
+  are used to synchronize access to the input and output trees.  I think
+  that we may need to control access to individual MII/MOI objects too,
+  don't we? : Reader gets a MII pointer locking and
+  unlocking the reader lock that controls the tree, and holds the pointer. 
+  Writer locks tree and updates an object. Race? Think bout the locking 
+ scheme (per cpu, local irq dis?)
+
+* JLEU: bind instructions to name and make them a RTAs in the SHIM_INSTR RTA
diff -Naur linux-kernel-rpm-f8/net/netfilter/Kconfig mpls-kernel-rpm-f8_modified/net/netfilter/Kconfig
--- linux-kernel-rpm-f8/net/netfilter/Kconfig	2008-10-17 10:01:04.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/netfilter/Kconfig	2008-10-17 09:45:05.000000000 +0200
@@ -348,6 +348,16 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_TARGET_MPLS
+	tristate '"mpls" target support'
+	depends on NETFILTER_XTABLES
+	depends on MPLS
+	help
+	  This option adds a `mpls' target, which allows you to create rules
+	  in the `mangle' table which map packets to a MPLS LSP
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 config NETFILTER_XT_TARGET_NFQUEUE
 	tristate '"NFQUEUE" target Support'
 	depends on NETFILTER_XTABLES
diff -Naur linux-kernel-rpm-f8/net/netfilter/Makefile mpls-kernel-rpm-f8_modified/net/netfilter/Makefile
--- linux-kernel-rpm-f8/net/netfilter/Makefile	2008-10-17 10:01:04.000000000 +0200
+++ mpls-kernel-rpm-f8_modified/net/netfilter/Makefile	2008-10-17 09:45:05.000000000 +0200
@@ -43,6 +43,7 @@
 obj-$(CONFIG_NETFILTER_XT_TARGET_CONNSECMARK) += xt_CONNSECMARK.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_DSCP) += xt_DSCP.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_MARK) += xt_MARK.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_MPLS) += xt_mpls.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_NFLOG) += xt_NFLOG.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_NFQUEUE) += xt_NFQUEUE.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_NOTRACK) += xt_NOTRACK.o
diff -Naur linux-kernel-rpm-f8/net/netfilter/xt_mpls.c mpls-kernel-rpm-f8_modified/net/netfilter/xt_mpls.c
--- linux-kernel-rpm-f8/net/netfilter/xt_mpls.c	1970-01-01 01:00:00.000000000 +0100
+++ mpls-kernel-rpm-f8_modified/net/netfilter/xt_mpls.c	2008-10-17 09:45:02.000000000 +0200
@@ -0,0 +1,106 @@
+/* This is a module which is used for redirecting packets into MPLS land. */
+
+/* (C) 1999-2007 James R. Leu <jleu@mindspring.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <net/route.h>
+#include <net/mpls.h>
+#include <net/checksum.h>
+
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_mpls.h>
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("James R. Leu <jle@mindspring.com>");
+MODULE_DESCRIPTION("ip[6]tables mpls module");
+MODULE_ALIAS("ipt_mpls");
+MODULE_ALIAS("ip6t_mpls");
+
+static unsigned int
+target(struct sk_buff *skb,
+	  const struct net_device *in,
+	  const struct net_device *out,
+	  unsigned int hooknum,
+	  const struct xt_target *target,
+	  const void *targinfo)
+{
+	const struct xt_mpls_target_info *mplsinfo = targinfo;
+	struct mpls_nhlfe *nhlfe = mplsinfo->nhlfe;
+
+	if (mpls_set_nexthop2(nhlfe, skb->dst)) {
+		return NF_DROP;
+	}
+	return XT_CONTINUE;
+}
+
+static bool
+checkentry(const char *tablename,
+	      const void *entry,
+	      const struct xt_target *target,
+	      void *targinfo,
+	      unsigned int hook_mask)
+{
+	struct xt_mpls_target_info *mplsinfo = targinfo;
+
+	mplsinfo->nhlfe = mpls_get_nhlfe(mplsinfo->key);
+	if (!mplsinfo->nhlfe) {
+		printk(KERN_WARNING "mpls: unable to find NHLFE with key %x\n",
+			mplsinfo->key);
+		return 0;
+	}
+
+	return 1;
+}
+
+static void
+destroy(const struct xt_target *target, void *targinfo)
+{
+	struct xt_mpls_target_info *mplsinfo = targinfo;
+	if (mplsinfo->nhlfe)
+		mpls_nhlfe_release(mplsinfo->nhlfe);
+}
+
+static struct xt_target xt_mpls_target[] = {
+	{
+		.name		= "mpls",
+		.family		= AF_INET,
+		.revision	= 0,
+		.checkentry	= checkentry,
+		.target		= target,
+		.destroy	= destroy,
+		.targetsize	= sizeof(struct xt_mpls_target_info),
+		.table		= "mangle",
+		.me		= THIS_MODULE,
+	},
+	{
+		.name		= "mpls",
+		.family		= AF_INET6,
+		.revision	= 0,
+		.checkentry	= checkentry,
+		.target		= target,
+		.destroy	= destroy,
+		.targetsize	= sizeof(struct xt_mpls_target_info),
+		.table		= "mangle",
+		.me		= THIS_MODULE,
+	},
+};
+
+static int __init xt_mpls_init(void)
+{
+	return xt_register_targets(xt_mpls_target, ARRAY_SIZE(xt_mpls_target));
+}
+
+static void __exit xt_mpls_fini(void)
+{
+	xt_unregister_targets(xt_mpls_target, ARRAY_SIZE(xt_mpls_target));
+}
+
+module_init(xt_mpls_init);
+module_exit(xt_mpls_fini);
